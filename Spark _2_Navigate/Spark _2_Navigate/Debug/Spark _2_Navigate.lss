
Spark _2_Navigate.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000140a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  0000140a  0000149e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000045  0080006e  0080006e  000014ac  2**0
                  ALLOC
  3 .stab         0000216c  00000000  00000000  000014ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000006a8  00000000  00000000  00003618  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000a0  00000000  00000000  00003cc0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001973  00000000  00000000  00003d60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000043a  00000000  00000000  000056d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000082c  00000000  00000000  00005b0d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000698  00000000  00000000  0000633c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006fb  00000000  00000000  000069d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000e6f  00000000  00000000  000070cf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 3f 03 	jmp	0x67e	; 0x67e <__vector_1>
       8:	0c 94 64 03 	jmp	0x6c8	; 0x6c8 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 e7 03 	jmp	0x7ce	; 0x7ce <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 7d 02 	jmp	0x4fa	; 0x4fa <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e0       	ldi	r30, 0x0A	; 10
      68:	f4 e1       	ldi	r31, 0x14	; 20
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ae 36       	cpi	r26, 0x6E	; 110
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	ae e6       	ldi	r26, 0x6E	; 110
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3b       	cpi	r26, 0xB3	; 179
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 d6 07 	call	0xfac	; 0xfac <main>
      8a:	0c 94 03 0a 	jmp	0x1406	; 0x1406 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <buzzer_on>:
		}
	return 0; 
}
void buzzer_on (void)
{
	PORTC = PORTC | 0b00001000; 
      92:	ab 9a       	sbi	0x15, 3	; 21
}
      94:	08 95       	ret

00000096 <buzzer_off>:
void buzzer_off (void)
{
	PORTC = PORTC & 0b11110111;
      96:	ab 98       	cbi	0x15, 3	; 21
      98:	08 95       	ret

0000009a <readSensor>:
	}
	stop(); //Stop robot
}

void readSensor()
{
      9a:	cf 93       	push	r28
      9c:	df 93       	push	r29
	highcurrent=0;
      9e:	10 92 6f 00 	sts	0x006F, r1
      a2:	10 92 6e 00 	sts	0x006E, r1
	highcount=0;
      a6:	10 92 71 00 	sts	0x0071, r1
      aa:	10 92 70 00 	sts	0x0070, r1
	sensor(0,th[0],avg[0]);
      ae:	c6 ed       	ldi	r28, 0xD6	; 214
      b0:	d2 e0       	ldi	r29, 0x02	; 2
      b2:	60 91 76 00 	lds	r22, 0x0076
      b6:	70 91 77 00 	lds	r23, 0x0077
      ba:	40 91 66 00 	lds	r20, 0x0066
      be:	50 91 67 00 	lds	r21, 0x0067
      c2:	80 e0       	ldi	r24, 0x00	; 0
      c4:	90 e0       	ldi	r25, 0x00	; 0
      c6:	fe 01       	movw	r30, r28
      c8:	09 95       	icall
	sensor(1,th[1],avg[1]);
      ca:	60 91 78 00 	lds	r22, 0x0078
      ce:	70 91 79 00 	lds	r23, 0x0079
      d2:	40 91 68 00 	lds	r20, 0x0068
      d6:	50 91 69 00 	lds	r21, 0x0069
      da:	81 e0       	ldi	r24, 0x01	; 1
      dc:	90 e0       	ldi	r25, 0x00	; 0
      de:	fe 01       	movw	r30, r28
      e0:	09 95       	icall
	sensor(2,th[2],avg[2]);
      e2:	60 91 7a 00 	lds	r22, 0x007A
      e6:	70 91 7b 00 	lds	r23, 0x007B
      ea:	40 91 6a 00 	lds	r20, 0x006A
      ee:	50 91 6b 00 	lds	r21, 0x006B
      f2:	82 e0       	ldi	r24, 0x02	; 2
      f4:	90 e0       	ldi	r25, 0x00	; 0
      f6:	fe 01       	movw	r30, r28
      f8:	09 95       	icall
	
	if(th[0] == 1){PORTC |= 0b00000001;}
      fa:	80 91 76 00 	lds	r24, 0x0076
      fe:	90 91 77 00 	lds	r25, 0x0077
     102:	81 30       	cpi	r24, 0x01	; 1
     104:	91 05       	cpc	r25, r1
     106:	11 f4       	brne	.+4      	; 0x10c <readSensor+0x72>
     108:	a8 9a       	sbi	0x15, 0	; 21
     10a:	03 c0       	rjmp	.+6      	; 0x112 <readSensor+0x78>
	else if(th[0] == 0){PORTC &= 0b11111110;}
     10c:	00 97       	sbiw	r24, 0x00	; 0
     10e:	09 f4       	brne	.+2      	; 0x112 <readSensor+0x78>
     110:	a8 98       	cbi	0x15, 0	; 21
	if(th[1]==1){PORTC |= 0b00000010;}	
     112:	80 91 78 00 	lds	r24, 0x0078
     116:	90 91 79 00 	lds	r25, 0x0079
     11a:	81 30       	cpi	r24, 0x01	; 1
     11c:	91 05       	cpc	r25, r1
     11e:	11 f4       	brne	.+4      	; 0x124 <readSensor+0x8a>
     120:	a9 9a       	sbi	0x15, 1	; 21
     122:	03 c0       	rjmp	.+6      	; 0x12a <readSensor+0x90>
	else if(th[1]==0){PORTC &= 0b11111101;}
     124:	00 97       	sbiw	r24, 0x00	; 0
     126:	09 f4       	brne	.+2      	; 0x12a <readSensor+0x90>
     128:	a9 98       	cbi	0x15, 1	; 21
	if(th[2] == 1){PORTC |= 0b00000100;}
     12a:	80 91 7a 00 	lds	r24, 0x007A
     12e:	90 91 7b 00 	lds	r25, 0x007B
     132:	81 30       	cpi	r24, 0x01	; 1
     134:	91 05       	cpc	r25, r1
     136:	09 f4       	brne	.+2      	; 0x13a <readSensor+0xa0>
     138:	aa 9a       	sbi	0x15, 2	; 21
	else if(th[2] == 1){PORTC &= 0b11111011;}
	
}
     13a:	df 91       	pop	r29
     13c:	cf 91       	pop	r28
     13e:	08 95       	ret

00000140 <proportional>:
		th[n]=0;
	}
	//lcd_print(1, 3-n, th[n], 1);
}
void proportional()
{
     140:	cf 92       	push	r12
     142:	df 92       	push	r13
     144:	ef 92       	push	r14
     146:	ff 92       	push	r15
	error = ((double)highcurrent/highcount)-target;
     148:	60 91 6e 00 	lds	r22, 0x006E
     14c:	70 91 6f 00 	lds	r23, 0x006F
     150:	88 27       	eor	r24, r24
     152:	77 fd       	sbrc	r23, 7
     154:	80 95       	com	r24
     156:	98 2f       	mov	r25, r24
     158:	0e 94 00 09 	call	0x1200	; 0x1200 <__floatsisf>
     15c:	6b 01       	movw	r12, r22
     15e:	7c 01       	movw	r14, r24
     160:	60 91 70 00 	lds	r22, 0x0070
     164:	70 91 71 00 	lds	r23, 0x0071
     168:	88 27       	eor	r24, r24
     16a:	77 fd       	sbrc	r23, 7
     16c:	80 95       	com	r24
     16e:	98 2f       	mov	r25, r24
     170:	0e 94 00 09 	call	0x1200	; 0x1200 <__floatsisf>
     174:	9b 01       	movw	r18, r22
     176:	ac 01       	movw	r20, r24
     178:	c7 01       	movw	r24, r14
     17a:	b6 01       	movw	r22, r12
     17c:	0e 94 65 08 	call	0x10ca	; 0x10ca <__divsf3>
     180:	6b 01       	movw	r12, r22
     182:	7c 01       	movw	r14, r24
     184:	60 91 64 00 	lds	r22, 0x0064
     188:	70 91 65 00 	lds	r23, 0x0065
     18c:	88 27       	eor	r24, r24
     18e:	77 fd       	sbrc	r23, 7
     190:	80 95       	com	r24
     192:	98 2f       	mov	r25, r24
     194:	0e 94 00 09 	call	0x1200	; 0x1200 <__floatsisf>
     198:	9b 01       	movw	r18, r22
     19a:	ac 01       	movw	r20, r24
     19c:	c7 01       	movw	r24, r14
     19e:	b6 01       	movw	r22, r12
     1a0:	0e 94 00 08 	call	0x1000	; 0x1000 <__subsf3>
     1a4:	0e 94 cd 08 	call	0x119a	; 0x119a <__fixsfsi>
     1a8:	ab 01       	movw	r20, r22
     1aa:	bc 01       	movw	r22, r24
     1ac:	ca 01       	movw	r24, r20
     1ae:	50 93 75 00 	sts	0x0075, r21
     1b2:	40 93 74 00 	sts	0x0074, r20
	p=(kp*error);
     1b6:	40 91 62 00 	lds	r20, 0x0062
     1ba:	50 91 63 00 	lds	r21, 0x0063
     1be:	84 9f       	mul	r24, r20
     1c0:	90 01       	movw	r18, r0
     1c2:	85 9f       	mul	r24, r21
     1c4:	30 0d       	add	r19, r0
     1c6:	94 9f       	mul	r25, r20
     1c8:	30 0d       	add	r19, r0
     1ca:	11 24       	eor	r1, r1
     1cc:	30 93 73 00 	sts	0x0073, r19
     1d0:	20 93 72 00 	sts	0x0072, r18
	if(th[0]==0 && th[1]==0 && th[2]==0)
     1d4:	80 91 76 00 	lds	r24, 0x0076
     1d8:	90 91 77 00 	lds	r25, 0x0077
     1dc:	00 97       	sbiw	r24, 0x00	; 0
     1de:	81 f4       	brne	.+32     	; 0x200 <proportional+0xc0>
     1e0:	80 91 78 00 	lds	r24, 0x0078
     1e4:	90 91 79 00 	lds	r25, 0x0079
     1e8:	00 97       	sbiw	r24, 0x00	; 0
     1ea:	51 f4       	brne	.+20     	; 0x200 <proportional+0xc0>
     1ec:	80 91 7a 00 	lds	r24, 0x007A
     1f0:	90 91 7b 00 	lds	r25, 0x007B
     1f4:	00 97       	sbiw	r24, 0x00	; 0
     1f6:	21 f4       	brne	.+8      	; 0x200 <proportional+0xc0>
	{
		p=0;
     1f8:	10 92 73 00 	sts	0x0073, r1
     1fc:	10 92 72 00 	sts	0x0072, r1
	}
}
     200:	ff 90       	pop	r15
     202:	ef 90       	pop	r14
     204:	df 90       	pop	r13
     206:	cf 90       	pop	r12
     208:	08 95       	ret

0000020a <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     20a:	95 b3       	in	r25, 0x15	; 21
     20c:	9f 70       	andi	r25, 0x0F	; 15
     20e:	95 bb       	out	0x15, r25	; 21
	lcd_port |= temp;
     210:	95 b3       	in	r25, 0x15	; 21
/*****Function to Write Command on LCD*****/
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     212:	28 2f       	mov	r18, r24
     214:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     216:	92 2b       	or	r25, r18
     218:	95 bb       	out	0x15, r25	; 21
	cbit(lcd_port,RS);
     21a:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);
     21c:	a9 98       	cbi	0x15, 1	; 21
	sbit(lcd_port,EN);
     21e:	aa 9a       	sbi	0x15, 2	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     220:	ef ef       	ldi	r30, 0xFF	; 255
     222:	f3 e2       	ldi	r31, 0x23	; 35
     224:	31 97       	sbiw	r30, 0x01	; 1
     226:	f1 f7       	brne	.-4      	; 0x224 <lcd_wr_command+0x1a>
     228:	00 c0       	rjmp	.+0      	; 0x22a <lcd_wr_command+0x20>
     22a:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     22c:	aa 98       	cbi	0x15, 2	; 21
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     22e:	95 b3       	in	r25, 0x15	; 21
     230:	9f 70       	andi	r25, 0x0F	; 15
     232:	95 bb       	out	0x15, r25	; 21
	lcd_port |= cmd;
     234:	95 b3       	in	r25, 0x15	; 21
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     236:	82 95       	swap	r24
     238:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     23a:	89 2b       	or	r24, r25
     23c:	85 bb       	out	0x15, r24	; 21
	cbit(lcd_port,RS);
     23e:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);
     240:	a9 98       	cbi	0x15, 1	; 21
	sbit(lcd_port,EN);
     242:	aa 9a       	sbi	0x15, 2	; 21
     244:	8f ef       	ldi	r24, 0xFF	; 255
     246:	93 e2       	ldi	r25, 0x23	; 35
     248:	01 97       	sbiw	r24, 0x01	; 1
     24a:	f1 f7       	brne	.-4      	; 0x248 <lcd_wr_command+0x3e>
     24c:	00 c0       	rjmp	.+0      	; 0x24e <lcd_wr_command+0x44>
     24e:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     250:	aa 98       	cbi	0x15, 2	; 21
}
     252:	08 95       	ret

00000254 <lcd_set_4bit>:
     254:	83 e3       	ldi	r24, 0x33	; 51
     256:	97 e0       	ldi	r25, 0x07	; 7
     258:	01 97       	sbiw	r24, 0x01	; 1
     25a:	f1 f7       	brne	.-4      	; 0x258 <lcd_set_4bit+0x4>
/*****Function to Reset LCD*****/
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     25c:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     25e:	a9 98       	cbi	0x15, 1	; 21
	lcd_port = 0x30;				//Sending 3
     260:	80 e3       	ldi	r24, 0x30	; 48
     262:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,EN);				//Set Enable Pin
     264:	aa 9a       	sbi	0x15, 2	; 21
     266:	ef ef       	ldi	r30, 0xFF	; 255
     268:	f3 e2       	ldi	r31, 0x23	; 35
     26a:	31 97       	sbiw	r30, 0x01	; 1
     26c:	f1 f7       	brne	.-4      	; 0x26a <lcd_set_4bit+0x16>
     26e:	00 c0       	rjmp	.+0      	; 0x270 <lcd_set_4bit+0x1c>
     270:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     272:	aa 98       	cbi	0x15, 2	; 21
     274:	e3 e3       	ldi	r30, 0x33	; 51
     276:	f7 e0       	ldi	r31, 0x07	; 7
     278:	31 97       	sbiw	r30, 0x01	; 1
     27a:	f1 f7       	brne	.-4      	; 0x278 <lcd_set_4bit+0x24>

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     27c:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     27e:	a9 98       	cbi	0x15, 1	; 21
	lcd_port = 0x30;				//Sending 3
     280:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,EN);				//Set Enable Pin
     282:	aa 9a       	sbi	0x15, 2	; 21
     284:	ef ef       	ldi	r30, 0xFF	; 255
     286:	f3 e2       	ldi	r31, 0x23	; 35
     288:	31 97       	sbiw	r30, 0x01	; 1
     28a:	f1 f7       	brne	.-4      	; 0x288 <lcd_set_4bit+0x34>
     28c:	00 c0       	rjmp	.+0      	; 0x28e <lcd_set_4bit+0x3a>
     28e:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     290:	aa 98       	cbi	0x15, 2	; 21
     292:	e3 e3       	ldi	r30, 0x33	; 51
     294:	f7 e0       	ldi	r31, 0x07	; 7
     296:	31 97       	sbiw	r30, 0x01	; 1
     298:	f1 f7       	brne	.-4      	; 0x296 <lcd_set_4bit+0x42>

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     29a:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     29c:	a9 98       	cbi	0x15, 1	; 21
	lcd_port = 0x30;				//Sending 3
     29e:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,EN);				//Set Enable Pin
     2a0:	aa 9a       	sbi	0x15, 2	; 21
     2a2:	8f ef       	ldi	r24, 0xFF	; 255
     2a4:	93 e2       	ldi	r25, 0x23	; 35
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	f1 f7       	brne	.-4      	; 0x2a6 <lcd_set_4bit+0x52>
     2aa:	00 c0       	rjmp	.+0      	; 0x2ac <lcd_set_4bit+0x58>
     2ac:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     2ae:	aa 98       	cbi	0x15, 2	; 21
     2b0:	e3 e3       	ldi	r30, 0x33	; 51
     2b2:	f7 e0       	ldi	r31, 0x07	; 7
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	f1 f7       	brne	.-4      	; 0x2b4 <lcd_set_4bit+0x60>

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     2b8:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     2ba:	a9 98       	cbi	0x15, 1	; 21
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     2bc:	80 e2       	ldi	r24, 0x20	; 32
     2be:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,EN);				//Set Enable Pin
     2c0:	aa 9a       	sbi	0x15, 2	; 21
     2c2:	8f ef       	ldi	r24, 0xFF	; 255
     2c4:	93 e2       	ldi	r25, 0x23	; 35
     2c6:	01 97       	sbiw	r24, 0x01	; 1
     2c8:	f1 f7       	brne	.-4      	; 0x2c6 <lcd_set_4bit+0x72>
     2ca:	00 c0       	rjmp	.+0      	; 0x2cc <lcd_set_4bit+0x78>
     2cc:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     2ce:	aa 98       	cbi	0x15, 2	; 21

	
}
     2d0:	08 95       	ret

000002d2 <lcd_init>:

/*****Function to Initialize LCD*****/
void lcd_init()
{
     2d2:	cf 93       	push	r28
     2d4:	df 93       	push	r29
     2d6:	83 e3       	ldi	r24, 0x33	; 51
     2d8:	97 e0       	ldi	r25, 0x07	; 7
     2da:	01 97       	sbiw	r24, 0x01	; 1
     2dc:	f1 f7       	brne	.-4      	; 0x2da <lcd_init+0x8>
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     2de:	c5 e0       	ldi	r28, 0x05	; 5
     2e0:	d1 e0       	ldi	r29, 0x01	; 1
     2e2:	88 e2       	ldi	r24, 0x28	; 40
     2e4:	90 e0       	ldi	r25, 0x00	; 0
     2e6:	fe 01       	movw	r30, r28
     2e8:	09 95       	icall
	lcd_wr_command(0x01);
     2ea:	81 e0       	ldi	r24, 0x01	; 1
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	fe 01       	movw	r30, r28
     2f0:	09 95       	icall
	lcd_wr_command(0x06);
     2f2:	86 e0       	ldi	r24, 0x06	; 6
     2f4:	90 e0       	ldi	r25, 0x00	; 0
     2f6:	fe 01       	movw	r30, r28
     2f8:	09 95       	icall
	lcd_wr_command(0x0E);
     2fa:	8e e0       	ldi	r24, 0x0E	; 14
     2fc:	90 e0       	ldi	r25, 0x00	; 0
     2fe:	fe 01       	movw	r30, r28
     300:	09 95       	icall
	lcd_wr_command(0x80);
     302:	80 e8       	ldi	r24, 0x80	; 128
     304:	90 e0       	ldi	r25, 0x00	; 0
     306:	fe 01       	movw	r30, r28
     308:	09 95       	icall
		
}
     30a:	df 91       	pop	r29
     30c:	cf 91       	pop	r28
     30e:	08 95       	ret

00000310 <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     310:	95 b3       	in	r25, 0x15	; 21
     312:	9f 70       	andi	r25, 0x0F	; 15
     314:	95 bb       	out	0x15, r25	; 21
	lcd_port |= temp;
     316:	95 b3       	in	r25, 0x15	; 21
/*****Function to Write Data on LCD*****/
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     318:	28 2f       	mov	r18, r24
     31a:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     31c:	92 2b       	or	r25, r18
     31e:	95 bb       	out	0x15, r25	; 21
	sbit(lcd_port,RS);
     320:	a8 9a       	sbi	0x15, 0	; 21
	cbit(lcd_port,RW);
     322:	a9 98       	cbi	0x15, 1	; 21
	sbit(lcd_port,EN);
     324:	aa 9a       	sbi	0x15, 2	; 21
     326:	ef ef       	ldi	r30, 0xFF	; 255
     328:	f3 e2       	ldi	r31, 0x23	; 35
     32a:	31 97       	sbiw	r30, 0x01	; 1
     32c:	f1 f7       	brne	.-4      	; 0x32a <lcd_wr_char+0x1a>
     32e:	00 c0       	rjmp	.+0      	; 0x330 <lcd_wr_char+0x20>
     330:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     332:	aa 98       	cbi	0x15, 2	; 21

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     334:	95 b3       	in	r25, 0x15	; 21
     336:	9f 70       	andi	r25, 0x0F	; 15
     338:	95 bb       	out	0x15, r25	; 21
	lcd_port |= letter;
     33a:	95 b3       	in	r25, 0x15	; 21
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     33c:	82 95       	swap	r24
     33e:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     340:	89 2b       	or	r24, r25
     342:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,RS);
     344:	a8 9a       	sbi	0x15, 0	; 21
	cbit(lcd_port,RW);
     346:	a9 98       	cbi	0x15, 1	; 21
	sbit(lcd_port,EN);
     348:	aa 9a       	sbi	0x15, 2	; 21
     34a:	8f ef       	ldi	r24, 0xFF	; 255
     34c:	93 e2       	ldi	r25, 0x23	; 35
     34e:	01 97       	sbiw	r24, 0x01	; 1
     350:	f1 f7       	brne	.-4      	; 0x34e <lcd_wr_char+0x3e>
     352:	00 c0       	rjmp	.+0      	; 0x354 <lcd_wr_char+0x44>
     354:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     356:	aa 98       	cbi	0x15, 2	; 21
}
     358:	08 95       	ret

0000035a <lcd_home>:


void lcd_home()
{
	lcd_wr_command(0x80);
     35a:	80 e8       	ldi	r24, 0x80	; 128
     35c:	0e 94 05 01 	call	0x20a	; 0x20a <lcd_wr_command>
}
     360:	08 95       	ret

00000362 <lcd_string>:


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
     362:	cf 93       	push	r28
     364:	df 93       	push	r29
     366:	ec 01       	movw	r28, r24
	while(*str != '\0')
     368:	88 81       	ld	r24, Y
     36a:	88 23       	and	r24, r24
     36c:	31 f0       	breq	.+12     	; 0x37a <lcd_string+0x18>
	lcd_wr_command(0x80);
}


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
     36e:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     370:	0e 94 88 01 	call	0x310	; 0x310 <lcd_wr_char>


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
	while(*str != '\0')
     374:	89 91       	ld	r24, Y+
     376:	88 23       	and	r24, r24
     378:	d9 f7       	brne	.-10     	; 0x370 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     37a:	df 91       	pop	r29
     37c:	cf 91       	pop	r28
     37e:	08 95       	ret

00000380 <lcd_cursor>:

/*** Position the LCD cursor at "row", "column". ***/

void lcd_cursor (char row, char column)
{
	switch (row) {
     380:	82 30       	cpi	r24, 0x02	; 2
     382:	79 f0       	breq	.+30     	; 0x3a2 <lcd_cursor+0x22>
     384:	83 30       	cpi	r24, 0x03	; 3
     386:	18 f4       	brcc	.+6      	; 0x38e <lcd_cursor+0xe>
     388:	81 30       	cpi	r24, 0x01	; 1
     38a:	c9 f4       	brne	.+50     	; 0x3be <lcd_cursor+0x3e>
     38c:	05 c0       	rjmp	.+10     	; 0x398 <lcd_cursor+0x18>
     38e:	83 30       	cpi	r24, 0x03	; 3
     390:	69 f0       	breq	.+26     	; 0x3ac <lcd_cursor+0x2c>
     392:	84 30       	cpi	r24, 0x04	; 4
     394:	a1 f4       	brne	.+40     	; 0x3be <lcd_cursor+0x3e>
     396:	0f c0       	rjmp	.+30     	; 0x3b6 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     398:	86 2f       	mov	r24, r22
     39a:	81 58       	subi	r24, 0x81	; 129
     39c:	0e 94 05 01 	call	0x20a	; 0x20a <lcd_wr_command>
     3a0:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     3a2:	86 2f       	mov	r24, r22
     3a4:	81 54       	subi	r24, 0x41	; 65
     3a6:	0e 94 05 01 	call	0x20a	; 0x20a <lcd_wr_command>
     3aa:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     3ac:	86 2f       	mov	r24, r22
     3ae:	8d 56       	subi	r24, 0x6D	; 109
     3b0:	0e 94 05 01 	call	0x20a	; 0x20a <lcd_wr_command>
     3b4:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     3b6:	86 2f       	mov	r24, r22
     3b8:	8d 52       	subi	r24, 0x2D	; 45
     3ba:	0e 94 05 01 	call	0x20a	; 0x20a <lcd_wr_command>
     3be:	08 95       	ret

000003c0 <lcd_print>:
	}
}

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     3c0:	0f 93       	push	r16
     3c2:	1f 93       	push	r17
     3c4:	cf 93       	push	r28
     3c6:	df 93       	push	r29
     3c8:	8a 01       	movw	r16, r20
     3ca:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     3cc:	88 23       	and	r24, r24
     3ce:	11 f0       	breq	.+4      	; 0x3d4 <lcd_print+0x14>
     3d0:	66 23       	and	r22, r22
     3d2:	19 f4       	brne	.+6      	; 0x3da <lcd_print+0x1a>
	{
		lcd_home();
     3d4:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_home>
     3d8:	02 c0       	rjmp	.+4      	; 0x3de <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     3da:	0e 94 c0 01 	call	0x380	; 0x380 <lcd_cursor>
	}
	if(digits==5 || flag==1)
     3de:	c5 30       	cpi	r28, 0x05	; 5
     3e0:	d1 05       	cpc	r29, r1
     3e2:	71 f4       	brne	.+28     	; 0x400 <lcd_print+0x40>
	{
		million=value/10000+48;
     3e4:	c8 01       	movw	r24, r16
     3e6:	60 e1       	ldi	r22, 0x10	; 16
     3e8:	77 e2       	ldi	r23, 0x27	; 39
     3ea:	0e 94 ef 09 	call	0x13de	; 0x13de <__udivmodhi4>
     3ee:	cb 01       	movw	r24, r22
     3f0:	c0 96       	adiw	r24, 0x30	; 48
     3f2:	90 93 9c 00 	sts	0x009C, r25
     3f6:	80 93 9b 00 	sts	0x009B, r24
		lcd_wr_char(million);
     3fa:	0e 94 88 01 	call	0x310	; 0x310 <lcd_wr_char>
     3fe:	03 c0       	rjmp	.+6      	; 0x406 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     400:	c4 30       	cpi	r28, 0x04	; 4
     402:	d1 05       	cpc	r29, r1
     404:	b9 f4       	brne	.+46     	; 0x434 <lcd_print+0x74>
	{
		temp = value/1000;
     406:	c8 01       	movw	r24, r16
     408:	68 ee       	ldi	r22, 0xE8	; 232
     40a:	73 e0       	ldi	r23, 0x03	; 3
     40c:	0e 94 ef 09 	call	0x13de	; 0x13de <__udivmodhi4>
     410:	cb 01       	movw	r24, r22
     412:	70 93 9e 00 	sts	0x009E, r23
     416:	60 93 9d 00 	sts	0x009D, r22
		thousand = temp%10 + 48;
     41a:	6a e0       	ldi	r22, 0x0A	; 10
     41c:	70 e0       	ldi	r23, 0x00	; 0
     41e:	0e 94 ef 09 	call	0x13de	; 0x13de <__udivmodhi4>
     422:	c0 96       	adiw	r24, 0x30	; 48
     424:	90 93 b2 00 	sts	0x00B2, r25
     428:	80 93 b1 00 	sts	0x00B1, r24
		lcd_wr_char(thousand);
     42c:	0e 94 88 01 	call	0x310	; 0x310 <lcd_wr_char>
		flag=1;
     430:	81 e0       	ldi	r24, 0x01	; 1
     432:	01 c0       	rjmp	.+2      	; 0x436 <lcd_print+0x76>
}

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     434:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     436:	c3 30       	cpi	r28, 0x03	; 3
     438:	d1 05       	cpc	r29, r1
     43a:	11 f0       	breq	.+4      	; 0x440 <lcd_print+0x80>
     43c:	81 30       	cpi	r24, 0x01	; 1
     43e:	b1 f4       	brne	.+44     	; 0x46c <__stack+0xd>
	{
		temp = value/100;
     440:	c8 01       	movw	r24, r16
     442:	64 e6       	ldi	r22, 0x64	; 100
     444:	70 e0       	ldi	r23, 0x00	; 0
     446:	0e 94 ef 09 	call	0x13de	; 0x13de <__udivmodhi4>
     44a:	cb 01       	movw	r24, r22
     44c:	70 93 9e 00 	sts	0x009E, r23
     450:	60 93 9d 00 	sts	0x009D, r22
		hundred = temp%10 + 48;
     454:	6a e0       	ldi	r22, 0x0A	; 10
     456:	70 e0       	ldi	r23, 0x00	; 0
     458:	0e 94 ef 09 	call	0x13de	; 0x13de <__udivmodhi4>
     45c:	c0 96       	adiw	r24, 0x30	; 48
     45e:	90 93 ae 00 	sts	0x00AE, r25
     462:	80 93 ad 00 	sts	0x00AD, r24
		lcd_wr_char(hundred);
     466:	0e 94 88 01 	call	0x310	; 0x310 <lcd_wr_char>
		flag=1;
     46a:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     46c:	c2 30       	cpi	r28, 0x02	; 2
     46e:	d1 05       	cpc	r29, r1
     470:	11 f0       	breq	.+4      	; 0x476 <__stack+0x17>
     472:	81 30       	cpi	r24, 0x01	; 1
     474:	b1 f4       	brne	.+44     	; 0x4a2 <__stack+0x43>
	{
		temp = value/10;
     476:	2a e0       	ldi	r18, 0x0A	; 10
     478:	30 e0       	ldi	r19, 0x00	; 0
     47a:	c8 01       	movw	r24, r16
     47c:	b9 01       	movw	r22, r18
     47e:	0e 94 ef 09 	call	0x13de	; 0x13de <__udivmodhi4>
     482:	cb 01       	movw	r24, r22
     484:	70 93 9e 00 	sts	0x009E, r23
     488:	60 93 9d 00 	sts	0x009D, r22
		tens = temp%10 + 48;
     48c:	b9 01       	movw	r22, r18
     48e:	0e 94 ef 09 	call	0x13de	; 0x13de <__udivmodhi4>
     492:	c0 96       	adiw	r24, 0x30	; 48
     494:	90 93 ac 00 	sts	0x00AC, r25
     498:	80 93 ab 00 	sts	0x00AB, r24
		lcd_wr_char(tens);
     49c:	0e 94 88 01 	call	0x310	; 0x310 <lcd_wr_char>
		flag=1;
     4a0:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     4a2:	c1 30       	cpi	r28, 0x01	; 1
     4a4:	d1 05       	cpc	r29, r1
     4a6:	11 f0       	breq	.+4      	; 0x4ac <__stack+0x4d>
     4a8:	81 30       	cpi	r24, 0x01	; 1
     4aa:	61 f4       	brne	.+24     	; 0x4c4 <__stack+0x65>
	{
		unit = value%10 + 48;
     4ac:	c8 01       	movw	r24, r16
     4ae:	6a e0       	ldi	r22, 0x0A	; 10
     4b0:	70 e0       	ldi	r23, 0x00	; 0
     4b2:	0e 94 ef 09 	call	0x13de	; 0x13de <__udivmodhi4>
     4b6:	c0 96       	adiw	r24, 0x30	; 48
     4b8:	90 93 b0 00 	sts	0x00B0, r25
     4bc:	80 93 af 00 	sts	0x00AF, r24
		lcd_wr_char(unit);
     4c0:	0e 94 88 01 	call	0x310	; 0x310 <lcd_wr_char>
	}
	if(digits>5)
     4c4:	c6 30       	cpi	r28, 0x06	; 6
     4c6:	d1 05       	cpc	r29, r1
     4c8:	1c f0       	brlt	.+6      	; 0x4d0 <__stack+0x71>
	{
		lcd_wr_char('E');
     4ca:	85 e4       	ldi	r24, 0x45	; 69
     4cc:	0e 94 88 01 	call	0x310	; 0x310 <lcd_wr_char>
	}
	
}
     4d0:	df 91       	pop	r29
     4d2:	cf 91       	pop	r28
     4d4:	1f 91       	pop	r17
     4d6:	0f 91       	pop	r16
     4d8:	08 95       	ret

000004da <uart0_init>:
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
 
 UCSRB = (1 << RXEN) | (1 << TXEN) | (1<<RXCIE);   // Turn on the transmission and reception circuitry
     4da:	88 e9       	ldi	r24, 0x98	; 152
     4dc:	8a b9       	out	0x0a, r24	; 10
 UCSRC = (1 << URSEL) | (1 << UCSZ0) | (1 << UCSZ1); // Use 8-bit character sizes
     4de:	86 e8       	ldi	r24, 0x86	; 134
     4e0:	80 bd       	out	0x20, r24	; 32
 
 UBRRL = 0x2F;
     4e2:	8f e2       	ldi	r24, 0x2F	; 47
     4e4:	89 b9       	out	0x09, r24	; 9
 UBRRH =0x00;
     4e6:	10 bc       	out	0x20, r1	; 32
 }
     4e8:	08 95       	ret

000004ea <USART_Transmit>:
void USART_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) )
     4ea:	5d 9b       	sbis	0x0b, 5	; 11
     4ec:	fe cf       	rjmp	.-4      	; 0x4ea <USART_Transmit>
	;
	/* Put data into buffer, sends the data */
	UDR = data;
     4ee:	8c b9       	out	0x0c, r24	; 12
}
     4f0:	08 95       	ret

000004f2 <usart_rx>:
 uart0_init();
 sei();         //Enables the global interrupts
}*/
unsigned char usart_rx()
{
	while(!(UCSRA & (1<<RXC)));              //wait until reception is completed
     4f2:	5f 9b       	sbis	0x0b, 7	; 11
     4f4:	fe cf       	rjmp	.-4      	; 0x4f2 <usart_rx>
	
	return UDR;                                     //receive first character by polling
     4f6:	8c b1       	in	r24, 0x0c	; 12
}
     4f8:	08 95       	ret

000004fa <__vector_11>:

ISR(USART_RXC_vect) 
{
     4fa:	1f 92       	push	r1
     4fc:	0f 92       	push	r0
     4fe:	0f b6       	in	r0, 0x3f	; 63
     500:	0f 92       	push	r0
     502:	11 24       	eor	r1, r1
     504:	2f 93       	push	r18
     506:	3f 93       	push	r19
     508:	4f 93       	push	r20
     50a:	5f 93       	push	r21
     50c:	6f 93       	push	r22
     50e:	7f 93       	push	r23
     510:	8f 93       	push	r24
     512:	9f 93       	push	r25
     514:	af 93       	push	r26
     516:	bf 93       	push	r27
     518:	ef 93       	push	r30
     51a:	ff 93       	push	r31
  ReceivedByte = UDR; // Fetch the received byte value into the variable "ByteReceived"
     51c:	8c b1       	in	r24, 0x0c	; 12
     51e:	80 93 98 00 	sts	0x0098, r24
  if (ReceivedByte=='a')
     522:	81 36       	cpi	r24, 0x61	; 97
     524:	19 f4       	brne	.+6      	; 0x52c <__vector_11+0x32>
 {
	 buzzer_on();
     526:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
     52a:	04 c0       	rjmp	.+8      	; 0x534 <__vector_11+0x3a>
	 
 }
 else if (ReceivedByte=='b')
     52c:	82 36       	cpi	r24, 0x62	; 98
     52e:	11 f4       	brne	.+4      	; 0x534 <__vector_11+0x3a>
 {
	 
	 buzzer_off();
     530:	0e 94 4b 00 	call	0x96	; 0x96 <buzzer_off>
 }
}
     534:	ff 91       	pop	r31
     536:	ef 91       	pop	r30
     538:	bf 91       	pop	r27
     53a:	af 91       	pop	r26
     53c:	9f 91       	pop	r25
     53e:	8f 91       	pop	r24
     540:	7f 91       	pop	r23
     542:	6f 91       	pop	r22
     544:	5f 91       	pop	r21
     546:	4f 91       	pop	r20
     548:	3f 91       	pop	r19
     54a:	2f 91       	pop	r18
     54c:	0f 90       	pop	r0
     54e:	0f be       	out	0x3f, r0	; 63
     550:	0f 90       	pop	r0
     552:	1f 90       	pop	r1
     554:	18 95       	reti

00000556 <lcd_port_config>:
unsigned char Right_white_line = 0;

//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     556:	84 b3       	in	r24, 0x14	; 20
     558:	87 6f       	ori	r24, 0xF7	; 247
     55a:	84 bb       	out	0x14, r24	; 20
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     55c:	85 b3       	in	r24, 0x15	; 21
     55e:	80 78       	andi	r24, 0x80	; 128
     560:	85 bb       	out	0x15, r24	; 21
}
     562:	08 95       	ret

00000564 <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
 DDRA = 0x00;   //set PORTF direction as input
     564:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00;  //set PORTF pins floating
     566:	1b ba       	out	0x1b, r1	; 27
}
     568:	08 95       	ret

0000056a <timer1_init>:
// WGM: 5) PWM 8bit fast, TOP=0x00FF
// desired value: 450Hz
// actual value: 450.000Hz (0.0%)
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     56a:	1e bc       	out	0x2e, r1	; 46
 TCNT1H = 0xFF; //setup
     56c:	8f ef       	ldi	r24, 0xFF	; 255
     56e:	8d bd       	out	0x2d, r24	; 45
 TCNT1L = 0x01;
     570:	91 e0       	ldi	r25, 0x01	; 1
     572:	9c bd       	out	0x2c, r25	; 44
 OCR1AH = 0x00;
     574:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = 0xFF;
     576:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     578:	19 bc       	out	0x29, r1	; 41
 OCR1BL = 0xFF;
     57a:	88 bd       	out	0x28, r24	; 40
 ICR1H  = 0x00;
     57c:	17 bc       	out	0x27, r1	; 39
 ICR1L  = 0xFF;
     57e:	86 bd       	out	0x26, r24	; 38
 TCCR1A = 0xA1;
     580:	81 ea       	ldi	r24, 0xA1	; 161
     582:	8f bd       	out	0x2f, r24	; 47
 TCCR1B = 0x0D; //start Timer
     584:	8d e0       	ldi	r24, 0x0D	; 13
     586:	8e bd       	out	0x2e, r24	; 46
}
     588:	08 95       	ret

0000058a <adc_init>:


//Function to Initialize ADC
void adc_init()
{
 ADCSRA = 0x00;
     58a:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     58c:	80 e2       	ldi	r24, 0x20	; 32
     58e:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     590:	80 e8       	ldi	r24, 0x80	; 128
     592:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     594:	86 e8       	ldi	r24, 0x86	; 134
     596:	86 b9       	out	0x06, r24	; 6
}
     598:	08 95       	ret

0000059a <ADC_Conversion>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     59a:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     59c:	80 62       	ori	r24, 0x20	; 32
     59e:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
     5a0:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     5a2:	34 9b       	sbis	0x06, 4	; 6
     5a4:	fe cf       	rjmp	.-4      	; 0x5a2 <ADC_Conversion+0x8>
 a=ADCH;
     5a6:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     5a8:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     5aa:	08 95       	ret

000005ac <sensor>:
	if(th[2] == 1){PORTC |= 0b00000100;}
	else if(th[2] == 1){PORTC &= 0b11111011;}
	
}
void sensor(int n,int sn,int avgn)
{
     5ac:	0f 93       	push	r16
     5ae:	1f 93       	push	r17
     5b0:	cf 93       	push	r28
     5b2:	df 93       	push	r29
     5b4:	8c 01       	movw	r16, r24
     5b6:	ea 01       	movw	r28, r20
	
	sn=ADC_Conversion(n+3);
     5b8:	8d 5f       	subi	r24, 0xFD	; 253
     5ba:	0e 94 cd 02 	call	0x59a	; 0x59a <ADC_Conversion>
     5be:	90 e0       	ldi	r25, 0x00	; 0
	if(sn>=avgn)
     5c0:	8c 17       	cp	r24, r28
     5c2:	9d 07       	cpc	r25, r29
     5c4:	fc f0       	brlt	.+62     	; 0x604 <sensor+0x58>
	{
		th[n]=1;
     5c6:	f8 01       	movw	r30, r16
     5c8:	ee 0f       	add	r30, r30
     5ca:	ff 1f       	adc	r31, r31
     5cc:	ea 58       	subi	r30, 0x8A	; 138
     5ce:	ff 4f       	sbci	r31, 0xFF	; 255
     5d0:	81 e0       	ldi	r24, 0x01	; 1
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	91 83       	std	Z+1, r25	; 0x01
     5d6:	80 83       	st	Z, r24
		highcount++;
     5d8:	80 91 70 00 	lds	r24, 0x0070
     5dc:	90 91 71 00 	lds	r25, 0x0071
     5e0:	01 96       	adiw	r24, 0x01	; 1
     5e2:	90 93 71 00 	sts	0x0071, r25
     5e6:	80 93 70 00 	sts	0x0070, r24
		highcurrent+=(n+1);
     5ea:	c8 01       	movw	r24, r16
     5ec:	01 96       	adiw	r24, 0x01	; 1
     5ee:	00 91 6e 00 	lds	r16, 0x006E
     5f2:	10 91 6f 00 	lds	r17, 0x006F
     5f6:	08 0f       	add	r16, r24
     5f8:	19 1f       	adc	r17, r25
     5fa:	10 93 6f 00 	sts	0x006F, r17
     5fe:	00 93 6e 00 	sts	0x006E, r16
     602:	07 c0       	rjmp	.+14     	; 0x612 <sensor+0x66>
	}
	else if(sn<avgn)
	{
		th[n]=0;
     604:	f8 01       	movw	r30, r16
     606:	ee 0f       	add	r30, r30
     608:	ff 1f       	adc	r31, r31
     60a:	ea 58       	subi	r30, 0x8A	; 138
     60c:	ff 4f       	sbci	r31, 0xFF	; 255
     60e:	11 82       	std	Z+1, r1	; 0x01
     610:	10 82       	st	Z, r1
	}
	//lcd_print(1, 3-n, th[n], 1);
}
     612:	df 91       	pop	r29
     614:	cf 91       	pop	r28
     616:	1f 91       	pop	r17
     618:	0f 91       	pop	r16
     61a:	08 95       	ret

0000061c <print_sensor>:

// This Function prints the Analog Value Of Corresponding Channel No. at required Row
// and Coloumn Location. 
void print_sensor(char row, char coloumn,unsigned char channel)
{
     61c:	cf 93       	push	r28
     61e:	df 93       	push	r29
     620:	d8 2f       	mov	r29, r24
     622:	c6 2f       	mov	r28, r22
     624:	84 2f       	mov	r24, r20
 ADC_Value = ADC_Conversion(channel);
     626:	0e 94 cd 02 	call	0x59a	; 0x59a <ADC_Conversion>
     62a:	48 2f       	mov	r20, r24
     62c:	80 93 a7 00 	sts	0x00A7, r24
 lcd_print(row, coloumn, ADC_Value, 3);
     630:	8d 2f       	mov	r24, r29
     632:	6c 2f       	mov	r22, r28
     634:	50 e0       	ldi	r21, 0x00	; 0
     636:	23 e0       	ldi	r18, 0x03	; 3
     638:	30 e0       	ldi	r19, 0x00	; 0
     63a:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <lcd_print>
}
     63e:	df 91       	pop	r29
     640:	cf 91       	pop	r28
     642:	08 95       	ret

00000644 <velocity>:
}*/

//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
 OCR1AH = 0x00;
     644:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = left_motor; 
     646:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     648:	19 bc       	out	0x29, r1	; 41
 OCR1BL = right_motor;
     64a:	68 bd       	out	0x28, r22	; 40
}
     64c:	08 95       	ret

0000064e <left_encoder_pin_config>:
}
*/
//Function to configure INT1 (PORTD 3) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xF7;  //Set the direction of the PORTD 3 pin as input
     64e:	8b 98       	cbi	0x11, 3	; 17
 PORTD = PORTD | 0x08; //Enable internal pull-up for PORTD 3 pin
     650:	93 9a       	sbi	0x12, 3	; 18
}
     652:	08 95       	ret

00000654 <right_encoder_pin_config>:

//Function to configure INT0 (PORTD 2) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xFB;  //Set the direction of the PORTD 2 pin as input
     654:	8a 98       	cbi	0x11, 2	; 17
 PORTD = PORTD | 0x04; //Enable internal pull-up for PORTD 2 pin
     656:	92 9a       	sbi	0x12, 2	; 18
}
     658:	08 95       	ret

0000065a <left_position_encoder_interrupt_init>:
 right_encoder_pin_config();   //right encoder pin config	
}*/

void left_position_encoder_interrupt_init (void) //Interrupt 1 enable
{
 cli(); //Clears the global interrupt
     65a:	f8 94       	cli
 MCUCR = MCUCR | 0x08; // INT1 is set to trigger with falling edge
     65c:	85 b7       	in	r24, 0x35	; 53
     65e:	88 60       	ori	r24, 0x08	; 8
     660:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x80;   // Enable Interrupt INT1 for left position encoder
     662:	8b b7       	in	r24, 0x3b	; 59
     664:	80 68       	ori	r24, 0x80	; 128
     666:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     668:	78 94       	sei
}
     66a:	08 95       	ret

0000066c <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 0 enable
{
 cli(); //Clears the global interrupt
     66c:	f8 94       	cli
 MCUCR = MCUCR | 0x02; // INT0 is set to trigger with falling edge
     66e:	85 b7       	in	r24, 0x35	; 53
     670:	82 60       	ori	r24, 0x02	; 2
     672:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x40;   // Enable Interrupt INT5 for right position encoder
     674:	8b b7       	in	r24, 0x3b	; 59
     676:	80 64       	ori	r24, 0x40	; 64
     678:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     67a:	78 94       	sei
}
     67c:	08 95       	ret

0000067e <__vector_1>:

//ISR for right position encoder
ISR(INT0_vect)  
{
     67e:	1f 92       	push	r1
     680:	0f 92       	push	r0
     682:	0f b6       	in	r0, 0x3f	; 63
     684:	0f 92       	push	r0
     686:	11 24       	eor	r1, r1
     688:	8f 93       	push	r24
     68a:	9f 93       	push	r25
     68c:	af 93       	push	r26
     68e:	bf 93       	push	r27
 ShaftCountRight++;  //increment right shaft position count
     690:	80 91 88 00 	lds	r24, 0x0088
     694:	90 91 89 00 	lds	r25, 0x0089
     698:	a0 91 8a 00 	lds	r26, 0x008A
     69c:	b0 91 8b 00 	lds	r27, 0x008B
     6a0:	01 96       	adiw	r24, 0x01	; 1
     6a2:	a1 1d       	adc	r26, r1
     6a4:	b1 1d       	adc	r27, r1
     6a6:	80 93 88 00 	sts	0x0088, r24
     6aa:	90 93 89 00 	sts	0x0089, r25
     6ae:	a0 93 8a 00 	sts	0x008A, r26
     6b2:	b0 93 8b 00 	sts	0x008B, r27
}
     6b6:	bf 91       	pop	r27
     6b8:	af 91       	pop	r26
     6ba:	9f 91       	pop	r25
     6bc:	8f 91       	pop	r24
     6be:	0f 90       	pop	r0
     6c0:	0f be       	out	0x3f, r0	; 63
     6c2:	0f 90       	pop	r0
     6c4:	1f 90       	pop	r1
     6c6:	18 95       	reti

000006c8 <__vector_2>:

//ISR for left position encoder
ISR(INT1_vect)
{
     6c8:	1f 92       	push	r1
     6ca:	0f 92       	push	r0
     6cc:	0f b6       	in	r0, 0x3f	; 63
     6ce:	0f 92       	push	r0
     6d0:	11 24       	eor	r1, r1
     6d2:	8f 93       	push	r24
     6d4:	9f 93       	push	r25
     6d6:	af 93       	push	r26
     6d8:	bf 93       	push	r27
 ShaftCountLeft++;  //increment left shaft position count
     6da:	80 91 8c 00 	lds	r24, 0x008C
     6de:	90 91 8d 00 	lds	r25, 0x008D
     6e2:	a0 91 8e 00 	lds	r26, 0x008E
     6e6:	b0 91 8f 00 	lds	r27, 0x008F
     6ea:	01 96       	adiw	r24, 0x01	; 1
     6ec:	a1 1d       	adc	r26, r1
     6ee:	b1 1d       	adc	r27, r1
     6f0:	80 93 8c 00 	sts	0x008C, r24
     6f4:	90 93 8d 00 	sts	0x008D, r25
     6f8:	a0 93 8e 00 	sts	0x008E, r26
     6fc:	b0 93 8f 00 	sts	0x008F, r27
}
     700:	bf 91       	pop	r27
     702:	af 91       	pop	r26
     704:	9f 91       	pop	r25
     706:	8f 91       	pop	r24
     708:	0f 90       	pop	r0
     70a:	0f be       	out	0x3f, r0	; 63
     70c:	0f 90       	pop	r0
     70e:	1f 90       	pop	r1
     710:	18 95       	reti

00000712 <angle_rotate>:
}
*/

//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     712:	0f 93       	push	r16
     714:	1f 93       	push	r17
     716:	cf 93       	push	r28
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 12.85; // division by resolution to get shaft count 
     718:	bc 01       	movw	r22, r24
     71a:	80 e0       	ldi	r24, 0x00	; 0
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	0e 94 fe 08 	call	0x11fc	; 0x11fc <__floatunsisf>
     722:	2a e9       	ldi	r18, 0x9A	; 154
     724:	39 e9       	ldi	r19, 0x99	; 153
     726:	4d e4       	ldi	r20, 0x4D	; 77
     728:	51 e4       	ldi	r21, 0x41	; 65
     72a:	0e 94 65 08 	call	0x10ca	; 0x10ca <__divsf3>
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     72e:	0e 94 d2 08 	call	0x11a4	; 0x11a4 <__fixunssfsi>
     732:	dc 01       	movw	r26, r24
     734:	cb 01       	movw	r24, r22
     736:	a0 e0       	ldi	r26, 0x00	; 0
     738:	b0 e0       	ldi	r27, 0x00	; 0
 ShaftCountRight = 0; 
     73a:	10 92 88 00 	sts	0x0088, r1
     73e:	10 92 89 00 	sts	0x0089, r1
     742:	10 92 8a 00 	sts	0x008A, r1
     746:	10 92 8b 00 	sts	0x008B, r1
 ShaftCountLeft = 0; 
     74a:	10 92 8c 00 	sts	0x008C, r1
     74e:	10 92 8d 00 	sts	0x008D, r1
     752:	10 92 8e 00 	sts	0x008E, r1
     756:	10 92 8f 00 	sts	0x008F, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     75a:	f1 e0       	ldi	r31, 0x01	; 1
     75c:	c0 e0       	ldi	r28, 0x00	; 0
     75e:	40 91 88 00 	lds	r20, 0x0088
     762:	50 91 89 00 	lds	r21, 0x0089
     766:	60 91 8a 00 	lds	r22, 0x008A
     76a:	70 91 8b 00 	lds	r23, 0x008B
     76e:	00 91 8c 00 	lds	r16, 0x008C
     772:	10 91 8d 00 	lds	r17, 0x008D
     776:	20 91 8e 00 	lds	r18, 0x008E
     77a:	30 91 8f 00 	lds	r19, 0x008F
     77e:	ef 2f       	mov	r30, r31
     780:	48 17       	cp	r20, r24
     782:	59 07       	cpc	r21, r25
     784:	6a 07       	cpc	r22, r26
     786:	7b 07       	cpc	r23, r27
     788:	08 f4       	brcc	.+2      	; 0x78c <angle_rotate+0x7a>
     78a:	ec 2f       	mov	r30, r28
     78c:	ee 23       	and	r30, r30
     78e:	49 f4       	brne	.+18     	; 0x7a2 <angle_rotate+0x90>
     790:	4f 2f       	mov	r20, r31
     792:	08 17       	cp	r16, r24
     794:	19 07       	cpc	r17, r25
     796:	2a 07       	cpc	r18, r26
     798:	3b 07       	cpc	r19, r27
     79a:	08 f4       	brcc	.+2      	; 0x79e <angle_rotate+0x8c>
     79c:	4c 2f       	mov	r20, r28
     79e:	44 23       	and	r20, r20
     7a0:	f1 f2       	breq	.-68     	; 0x75e <angle_rotate+0x4c>
  break;
 }
 stop(); //Stop robot
     7a2:	0e 94 70 05 	call	0xae0	; 0xae0 <stop>
}
     7a6:	cf 91       	pop	r28
     7a8:	1f 91       	pop	r17
     7aa:	0f 91       	pop	r16
     7ac:	08 95       	ret

000007ae <color_sensor_pin_config>:
*/

void color_sensor_pin_config(void)
{
	
	DDRD = DDRD |0xBF;
     7ae:	81 b3       	in	r24, 0x11	; 17
     7b0:	8f 6b       	ori	r24, 0xBF	; 191
     7b2:	81 bb       	out	0x11, r24	; 17
	PORTD = PORTD |0x40;            //Enable internal pull-up for PORTD 6 pin
     7b4:	96 9a       	sbi	0x12, 6	; 18
	DDRC =  DDRC|0xF8;            //Initialise pins connected to S0, S1, S2, S3 as output
     7b6:	84 b3       	in	r24, 0x14	; 20
     7b8:	88 6f       	ori	r24, 0xF8	; 248
     7ba:	84 bb       	out	0x14, r24	; 20
	PORTC = PORTC|0x00;            // Set pins as LOW initialially
     7bc:	85 b3       	in	r24, 0x15	; 21
     7be:	85 bb       	out	0x15, r24	; 21
	
}
     7c0:	08 95       	ret

000007c2 <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli();               //Clears the global interrupt
     7c2:	f8 94       	cli
	TIMSK= TIMSK | 0x20; // Enable input capture pin of timer 1 for color sensor
     7c4:	89 b7       	in	r24, 0x39	; 57
     7c6:	80 62       	ori	r24, 0x20	; 32
     7c8:	89 bf       	out	0x39, r24	; 57
	sei();               // Enables the global interrupt
     7ca:	78 94       	sei
}
     7cc:	08 95       	ret

000007ce <__vector_5>:

ISR(TIMER1_CAPT_vect)
{
     7ce:	1f 92       	push	r1
     7d0:	0f 92       	push	r0
     7d2:	0f b6       	in	r0, 0x3f	; 63
     7d4:	0f 92       	push	r0
     7d6:	11 24       	eor	r1, r1
     7d8:	8f 93       	push	r24
     7da:	9f 93       	push	r25
     7dc:	af 93       	push	r26
     7de:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     7e0:	80 91 84 00 	lds	r24, 0x0084
     7e4:	90 91 85 00 	lds	r25, 0x0085
     7e8:	a0 91 86 00 	lds	r26, 0x0086
     7ec:	b0 91 87 00 	lds	r27, 0x0087
     7f0:	01 96       	adiw	r24, 0x01	; 1
     7f2:	a1 1d       	adc	r26, r1
     7f4:	b1 1d       	adc	r27, r1
     7f6:	80 93 84 00 	sts	0x0084, r24
     7fa:	90 93 85 00 	sts	0x0085, r25
     7fe:	a0 93 86 00 	sts	0x0086, r26
     802:	b0 93 87 00 	sts	0x0087, r27
}
     806:	bf 91       	pop	r27
     808:	af 91       	pop	r26
     80a:	9f 91       	pop	r25
     80c:	8f 91       	pop	r24
     80e:	0f 90       	pop	r0
     810:	0f be       	out	0x3f, r0	; 63
     812:	0f 90       	pop	r0
     814:	1f 90       	pop	r1
     816:	18 95       	reti

00000818 <timer1_init2>:

void timer1_init2(void)
{
	TCNT1H = 0x00;
     818:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0x00;
     81a:	1c bc       	out	0x2c, r1	; 44
	OCR1AH = 0x00;
     81c:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0x00;
     81e:	1a bc       	out	0x2a, r1	; 42
	OCR1BH = 0x00;
     820:	19 bc       	out	0x29, r1	; 41
	OCR1BL = 0x00;
     822:	18 bc       	out	0x28, r1	; 40
	TCCR1A = 0x00;
     824:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0x01; //at clock frequency
     826:	81 e0       	ldi	r24, 0x01	; 1
     828:	8e bd       	out	0x2e, r24	; 46
	TIMSK = 0x20;
     82a:	80 e2       	ldi	r24, 0x20	; 32
     82c:	89 bf       	out	0x39, r24	; 57
}
     82e:	08 95       	ret

00000830 <filter_red>:
/////////////////////////////////////////////////////////////////////
//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTC = PORTC & 0xBF; //set S2 low
     830:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 low
     832:	af 98       	cbi	0x15, 7	; 21
}
     834:	08 95       	ret

00000836 <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTC= PORTC | 0x40; //set S2 High
     836:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
     838:	af 9a       	sbi	0x15, 7	; 21
}
     83a:	08 95       	ret

0000083c <filter_blue>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTC = PORTC & 0xBF; //set S2 low
     83c:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
     83e:	af 9a       	sbi	0x15, 7	; 21
}
     840:	08 95       	ret

00000842 <filter_clear>:

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
 	PORTC = PORTC | 0x40; //set S2 High
     842:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 Low
     844:	af 98       	cbi	0x15, 7	; 21
}
     846:	08 95       	ret

00000848 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTC = PORTC | 0x10; //set S0 high
     848:	ac 9a       	sbi	0x15, 4	; 21
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTC = PORTC | 0x20; //set S1 high
     84a:	ad 9a       	sbi	0x15, 5	; 21
}
     84c:	08 95       	ret

0000084e <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
     84e:	0e 94 18 04 	call	0x830	; 0x830 <filter_red>
	pulse=0; //reset the count to 0
     852:	10 92 84 00 	sts	0x0084, r1
     856:	10 92 85 00 	sts	0x0085, r1
     85a:	10 92 86 00 	sts	0x0086, r1
     85e:	10 92 87 00 	sts	0x0087, r1
     862:	8f ef       	ldi	r24, 0xFF	; 255
     864:	9f e3       	ldi	r25, 0x3F	; 63
     866:	a2 e0       	ldi	r26, 0x02	; 2
     868:	81 50       	subi	r24, 0x01	; 1
     86a:	90 40       	sbci	r25, 0x00	; 0
     86c:	a0 40       	sbci	r26, 0x00	; 0
     86e:	e1 f7       	brne	.-8      	; 0x868 <red_read+0x1a>
     870:	00 c0       	rjmp	.+0      	; 0x872 <red_read+0x24>
     872:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     874:	80 91 84 00 	lds	r24, 0x0084
     878:	90 91 85 00 	lds	r25, 0x0085
     87c:	a0 91 86 00 	lds	r26, 0x0086
     880:	b0 91 87 00 	lds	r27, 0x0087
     884:	80 93 a3 00 	sts	0x00A3, r24
     888:	90 93 a4 00 	sts	0x00A4, r25
     88c:	a0 93 a5 00 	sts	0x00A5, r26
     890:	b0 93 a6 00 	sts	0x00A6, r27
}
     894:	08 95       	ret

00000896 <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
     896:	0e 94 1b 04 	call	0x836	; 0x836 <filter_green>
	pulse=0; //reset the count to 0
     89a:	10 92 84 00 	sts	0x0084, r1
     89e:	10 92 85 00 	sts	0x0085, r1
     8a2:	10 92 86 00 	sts	0x0086, r1
     8a6:	10 92 87 00 	sts	0x0087, r1
     8aa:	8f ef       	ldi	r24, 0xFF	; 255
     8ac:	9f e3       	ldi	r25, 0x3F	; 63
     8ae:	a2 e0       	ldi	r26, 0x02	; 2
     8b0:	81 50       	subi	r24, 0x01	; 1
     8b2:	90 40       	sbci	r25, 0x00	; 0
     8b4:	a0 40       	sbci	r26, 0x00	; 0
     8b6:	e1 f7       	brne	.-8      	; 0x8b0 <green_read+0x1a>
     8b8:	00 c0       	rjmp	.+0      	; 0x8ba <green_read+0x24>
     8ba:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
     8bc:	80 91 84 00 	lds	r24, 0x0084
     8c0:	90 91 85 00 	lds	r25, 0x0085
     8c4:	a0 91 86 00 	lds	r26, 0x0086
     8c8:	b0 91 87 00 	lds	r27, 0x0087
     8cc:	80 93 9f 00 	sts	0x009F, r24
     8d0:	90 93 a0 00 	sts	0x00A0, r25
     8d4:	a0 93 a1 00 	sts	0x00A1, r26
     8d8:	b0 93 a2 00 	sts	0x00A2, r27
}
     8dc:	08 95       	ret

000008de <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
     8de:	0e 94 1e 04 	call	0x83c	; 0x83c <filter_blue>
	pulse=0; //reset the count to 0
     8e2:	10 92 84 00 	sts	0x0084, r1
     8e6:	10 92 85 00 	sts	0x0085, r1
     8ea:	10 92 86 00 	sts	0x0086, r1
     8ee:	10 92 87 00 	sts	0x0087, r1
     8f2:	8f ef       	ldi	r24, 0xFF	; 255
     8f4:	9f e3       	ldi	r25, 0x3F	; 63
     8f6:	a2 e0       	ldi	r26, 0x02	; 2
     8f8:	81 50       	subi	r24, 0x01	; 1
     8fa:	90 40       	sbci	r25, 0x00	; 0
     8fc:	a0 40       	sbci	r26, 0x00	; 0
     8fe:	e1 f7       	brne	.-8      	; 0x8f8 <blue_read+0x1a>
     900:	00 c0       	rjmp	.+0      	; 0x902 <blue_read+0x24>
     902:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
     904:	80 91 84 00 	lds	r24, 0x0084
     908:	90 91 85 00 	lds	r25, 0x0085
     90c:	a0 91 86 00 	lds	r26, 0x0086
     910:	b0 91 87 00 	lds	r27, 0x0087
     914:	80 93 94 00 	sts	0x0094, r24
     918:	90 93 95 00 	sts	0x0095, r25
     91c:	a0 93 96 00 	sts	0x0096, r26
     920:	b0 93 97 00 	sts	0x0097, r27
}
     924:	08 95       	ret

00000926 <colourDetect>:
{
	/*Blue-->0
	Red-->1
	Green-->2*/
	int colour;
	color_sensor_pin_interrupt_init();
     926:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <color_sensor_pin_interrupt_init>
	timer1_init2();
     92a:	0e 94 0c 04 	call	0x818	; 0x818 <timer1_init2>
	color_sensor_pin_config();
     92e:	0e 94 d7 03 	call	0x7ae	; 0x7ae <color_sensor_pin_config>
	color_sensor_scaling();
     932:	0e 94 24 04 	call	0x848	; 0x848 <color_sensor_scaling>
	red_read(); //display the pulse count when red filter is selected
     936:	0e 94 27 04 	call	0x84e	; 0x84e <red_read>
	green_read(); //display the pulse count when green filter is selected
     93a:	0e 94 4b 04 	call	0x896	; 0x896 <green_read>
	blue_read(); //display the pulse count when blue filter is selected
     93e:	0e 94 6f 04 	call	0x8de	; 0x8de <blue_read>
	if((blue>green)&&(blue>red))
     942:	80 91 94 00 	lds	r24, 0x0094
     946:	90 91 95 00 	lds	r25, 0x0095
     94a:	a0 91 96 00 	lds	r26, 0x0096
     94e:	b0 91 97 00 	lds	r27, 0x0097
     952:	40 91 9f 00 	lds	r20, 0x009F
     956:	50 91 a0 00 	lds	r21, 0x00A0
     95a:	60 91 a1 00 	lds	r22, 0x00A1
     95e:	70 91 a2 00 	lds	r23, 0x00A2
     962:	48 17       	cp	r20, r24
     964:	59 07       	cpc	r21, r25
     966:	6a 07       	cpc	r22, r26
     968:	7b 07       	cpc	r23, r27
     96a:	78 f4       	brcc	.+30     	; 0x98a <colourDetect+0x64>
     96c:	40 91 a3 00 	lds	r20, 0x00A3
     970:	50 91 a4 00 	lds	r21, 0x00A4
     974:	60 91 a5 00 	lds	r22, 0x00A5
     978:	70 91 a6 00 	lds	r23, 0x00A6
     97c:	48 17       	cp	r20, r24
     97e:	59 07       	cpc	r21, r25
     980:	6a 07       	cpc	r22, r26
     982:	7b 07       	cpc	r23, r27
     984:	10 f4       	brcc	.+4      	; 0x98a <colourDetect+0x64>
	{
		colour=0;
		buzzer_on();
     986:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
	}
	if((red>green)&&(red>blue))
     98a:	80 91 a3 00 	lds	r24, 0x00A3
     98e:	90 91 a4 00 	lds	r25, 0x00A4
     992:	a0 91 a5 00 	lds	r26, 0x00A5
     996:	b0 91 a6 00 	lds	r27, 0x00A6
     99a:	40 91 9f 00 	lds	r20, 0x009F
     99e:	50 91 a0 00 	lds	r21, 0x00A0
     9a2:	60 91 a1 00 	lds	r22, 0x00A1
     9a6:	70 91 a2 00 	lds	r23, 0x00A2
     9aa:	48 17       	cp	r20, r24
     9ac:	59 07       	cpc	r21, r25
     9ae:	6a 07       	cpc	r22, r26
     9b0:	7b 07       	cpc	r23, r27
     9b2:	78 f4       	brcc	.+30     	; 0x9d2 <colourDetect+0xac>
     9b4:	40 91 94 00 	lds	r20, 0x0094
     9b8:	50 91 95 00 	lds	r21, 0x0095
     9bc:	60 91 96 00 	lds	r22, 0x0096
     9c0:	70 91 97 00 	lds	r23, 0x0097
     9c4:	48 17       	cp	r20, r24
     9c6:	59 07       	cpc	r21, r25
     9c8:	6a 07       	cpc	r22, r26
     9ca:	7b 07       	cpc	r23, r27
     9cc:	10 f4       	brcc	.+4      	; 0x9d2 <colourDetect+0xac>
	{
		colour=1;
		buzzer_off();
     9ce:	0e 94 4b 00 	call	0x96	; 0x96 <buzzer_off>
	}
	if((green>red)&&(green>blue))
     9d2:	80 91 9f 00 	lds	r24, 0x009F
     9d6:	90 91 a0 00 	lds	r25, 0x00A0
     9da:	a0 91 a1 00 	lds	r26, 0x00A1
     9de:	b0 91 a2 00 	lds	r27, 0x00A2
     9e2:	40 91 a3 00 	lds	r20, 0x00A3
     9e6:	50 91 a4 00 	lds	r21, 0x00A4
     9ea:	60 91 a5 00 	lds	r22, 0x00A5
     9ee:	70 91 a6 00 	lds	r23, 0x00A6
     9f2:	48 17       	cp	r20, r24
     9f4:	59 07       	cpc	r21, r25
     9f6:	6a 07       	cpc	r22, r26
     9f8:	7b 07       	cpc	r23, r27
     9fa:	18 f5       	brcc	.+70     	; 0xa42 <colourDetect+0x11c>
     9fc:	40 91 94 00 	lds	r20, 0x0094
     a00:	50 91 95 00 	lds	r21, 0x0095
     a04:	60 91 96 00 	lds	r22, 0x0096
     a08:	70 91 97 00 	lds	r23, 0x0097
     a0c:	48 17       	cp	r20, r24
     a0e:	59 07       	cpc	r21, r25
     a10:	6a 07       	cpc	r22, r26
     a12:	7b 07       	cpc	r23, r27
     a14:	b0 f4       	brcc	.+44     	; 0xa42 <colourDetect+0x11c>
	{
		colour=2;
		buzzer_on();
     a16:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
     a1a:	8f ef       	ldi	r24, 0xFF	; 255
     a1c:	9f e7       	ldi	r25, 0x7F	; 127
     a1e:	a6 e1       	ldi	r26, 0x16	; 22
     a20:	81 50       	subi	r24, 0x01	; 1
     a22:	90 40       	sbci	r25, 0x00	; 0
     a24:	a0 40       	sbci	r26, 0x00	; 0
     a26:	e1 f7       	brne	.-8      	; 0xa20 <colourDetect+0xfa>
     a28:	00 c0       	rjmp	.+0      	; 0xa2a <colourDetect+0x104>
     a2a:	00 00       	nop
		_delay_ms(1000);
		buzzer_off();
     a2c:	0e 94 4b 00 	call	0x96	; 0x96 <buzzer_off>
     a30:	8f ef       	ldi	r24, 0xFF	; 255
     a32:	9f e7       	ldi	r25, 0x7F	; 127
     a34:	a6 e1       	ldi	r26, 0x16	; 22
     a36:	81 50       	subi	r24, 0x01	; 1
     a38:	90 40       	sbci	r25, 0x00	; 0
     a3a:	a0 40       	sbci	r26, 0x00	; 0
     a3c:	e1 f7       	brne	.-8      	; 0xa36 <colourDetect+0x110>
     a3e:	00 c0       	rjmp	.+0      	; 0xa40 <colourDetect+0x11a>
     a40:	00 00       	nop
     a42:	08 95       	ret

00000a44 <plantDetect>:
}
int plantDetect()
{
	int val;
	float volts;
	adc_init();
     a44:	0e 94 c5 02 	call	0x58a	; 0x58a <adc_init>
	adc_pin_config();
     a48:	0e 94 b2 02 	call	0x564	; 0x564 <adc_pin_config>
	val=ADC_Conversion(2);
     a4c:	82 e0       	ldi	r24, 0x02	; 2
     a4e:	0e 94 cd 02 	call	0x59a	; 0x59a <ADC_Conversion>
	volts=val*0.0196078431;
     a52:	68 2f       	mov	r22, r24
     a54:	70 e0       	ldi	r23, 0x00	; 0
     a56:	80 e0       	ldi	r24, 0x00	; 0
     a58:	90 e0       	ldi	r25, 0x00	; 0
     a5a:	0e 94 00 09 	call	0x1200	; 0x1200 <__floatsisf>
     a5e:	21 ea       	ldi	r18, 0xA1	; 161
     a60:	30 ea       	ldi	r19, 0xA0	; 160
     a62:	40 ea       	ldi	r20, 0xA0	; 160
     a64:	5c e3       	ldi	r21, 0x3C	; 60
     a66:	0e 94 8c 09 	call	0x1318	; 0x1318 <__mulsf3>
     a6a:	9b 01       	movw	r18, r22
     a6c:	ac 01       	movw	r20, r24
	int distance = 13*pow(volts, -1);
     a6e:	60 e0       	ldi	r22, 0x00	; 0
     a70:	70 e0       	ldi	r23, 0x00	; 0
     a72:	80 e8       	ldi	r24, 0x80	; 128
     a74:	9f e3       	ldi	r25, 0x3F	; 63
     a76:	0e 94 65 08 	call	0x10ca	; 0x10ca <__divsf3>
     a7a:	20 e0       	ldi	r18, 0x00	; 0
     a7c:	30 e0       	ldi	r19, 0x00	; 0
     a7e:	40 e5       	ldi	r20, 0x50	; 80
     a80:	51 e4       	ldi	r21, 0x41	; 65
     a82:	0e 94 8c 09 	call	0x1318	; 0x1318 <__mulsf3>
     a86:	0e 94 cd 08 	call	0x119a	; 0x119a <__fixsfsi>
     a8a:	ab 01       	movw	r20, r22
     a8c:	bc 01       	movw	r22, r24
	if(distance<10)
		{
			return 1;
     a8e:	81 e0       	ldi	r24, 0x01	; 1
     a90:	90 e0       	ldi	r25, 0x00	; 0
     a92:	4a 30       	cpi	r20, 0x0A	; 10
     a94:	51 05       	cpc	r21, r1
     a96:	14 f0       	brlt	.+4      	; 0xa9c <plantDetect+0x58>
     a98:	80 e0       	ldi	r24, 0x00	; 0
     a9a:	90 e0       	ldi	r25, 0x00	; 0
		}
	return 0; 
}
     a9c:	08 95       	ret

00000a9e <buzzer_pin_config>:
int highcount=0,highcurrent=0; //Constants for Proportional in p
int baseLine=140; //Constants for Proportional in p

void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     a9e:	a3 9a       	sbi	0x14, 3	; 20
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     aa0:	ab 98       	cbi	0x15, 3	; 21
}
     aa2:	08 95       	ret

00000aa4 <motion_pin_config>:
}*/

//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
	DDRB = DDRB | 0x0F;    //set direction of the PORTB3 to PORTB0 pins as output
     aa4:	87 b3       	in	r24, 0x17	; 23
     aa6:	8f 60       	ori	r24, 0x0F	; 15
     aa8:	87 bb       	out	0x17, r24	; 23
	PORTB = PORTB & 0xF0;  //set initial value of the PORTB3 to PORTB0 pins to logic 0
     aaa:	88 b3       	in	r24, 0x18	; 24
     aac:	80 7f       	andi	r24, 0xF0	; 240
     aae:	88 bb       	out	0x18, r24	; 24
	DDRD = DDRD | 0x30;    //Setting PD5 and PD4 pins as output for PWM generation
     ab0:	81 b3       	in	r24, 0x11	; 17
     ab2:	80 63       	ori	r24, 0x30	; 48
     ab4:	81 bb       	out	0x11, r24	; 17
	PORTD = PORTD | 0x30;  //PD5 and PD4 pins are for velocity control using PWM
     ab6:	82 b3       	in	r24, 0x12	; 18
     ab8:	80 63       	ori	r24, 0x30	; 48
     aba:	82 bb       	out	0x12, r24	; 18
}
     abc:	08 95       	ret

00000abe <port_init>:

void port_init()
{
	buzzer_pin_config();
     abe:	0e 94 4f 05 	call	0xa9e	; 0xa9e <buzzer_pin_config>
	//lcd_port_config();
	adc_pin_config();
     ac2:	0e 94 b2 02 	call	0x564	; 0x564 <adc_pin_config>
	motion_pin_config();
     ac6:	0e 94 52 05 	call	0xaa4	; 0xaa4 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
     aca:	0e 94 27 03 	call	0x64e	; 0x64e <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
     ace:	0e 94 2a 03 	call	0x654	; 0x654 <right_encoder_pin_config>
}
     ad2:	08 95       	ret

00000ad4 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
	PortBRestore = PORTB; 			// reading the PORTB's original status
     ad4:	98 b3       	in	r25, 0x18	; 24
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
     ad6:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
     ad8:	8f 70       	andi	r24, 0x0F	; 15
	PortBRestore = PORTB; 			// reading the PORTB's original status
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
	PortBRestore |= Direction; 	// adding lower nibbel for direction command and restoring the PORTB status
     ada:	98 2b       	or	r25, r24
	PORTB = PortBRestore; 			// setting the command to the port
     adc:	98 bb       	out	0x18, r25	; 24
}
     ade:	08 95       	ret

00000ae0 <stop>:
	motion_set(0x08);
}

void stop (void)
{
	motion_set(0x00);
     ae0:	80 e0       	ldi	r24, 0x00	; 0
     ae2:	0e 94 6a 05 	call	0xad4	; 0xad4 <motion_set>
}
     ae6:	08 95       	ret

00000ae8 <forward>:
}


void forward (void) //both wheels forward
{
	motion_set(0x06);
     ae8:	86 e0       	ldi	r24, 0x06	; 6
     aea:	0e 94 6a 05 	call	0xad4	; 0xad4 <motion_set>
}
     aee:	08 95       	ret

00000af0 <back>:

void back (void) //both wheels backward
{
	motion_set(0x09);
     af0:	89 e0       	ldi	r24, 0x09	; 9
     af2:	0e 94 6a 05 	call	0xad4	; 0xad4 <motion_set>
}
     af6:	08 95       	ret

00000af8 <left>:

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
     af8:	85 e0       	ldi	r24, 0x05	; 5
     afa:	0e 94 6a 05 	call	0xad4	; 0xad4 <motion_set>
}
     afe:	08 95       	ret

00000b00 <right>:

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
     b00:	8a e0       	ldi	r24, 0x0A	; 10
     b02:	0e 94 6a 05 	call	0xad4	; 0xad4 <motion_set>
}
     b06:	08 95       	ret

00000b08 <soft_left>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
	motion_set(0x04);
     b08:	84 e0       	ldi	r24, 0x04	; 4
     b0a:	0e 94 6a 05 	call	0xad4	; 0xad4 <motion_set>
}
     b0e:	08 95       	ret

00000b10 <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
	motion_set(0x02);
     b10:	82 e0       	ldi	r24, 0x02	; 2
     b12:	0e 94 6a 05 	call	0xad4	; 0xad4 <motion_set>
}
     b16:	08 95       	ret

00000b18 <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set(0x01);
     b18:	81 e0       	ldi	r24, 0x01	; 1
     b1a:	0e 94 6a 05 	call	0xad4	; 0xad4 <motion_set>
}
     b1e:	08 95       	ret

00000b20 <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set(0x08);
     b20:	88 e0       	ldi	r24, 0x08	; 8
     b22:	0e 94 6a 05 	call	0xad4	; 0xad4 <motion_set>
}
     b26:	08 95       	ret

00000b28 <linear_distance_mm>:


//Function used for moving robot forward by specified distance

void linear_distance_mm(unsigned int DistanceInMM, int sign, char purpose)
{
     b28:	af 92       	push	r10
     b2a:	bf 92       	push	r11
     b2c:	cf 92       	push	r12
     b2e:	df 92       	push	r13
     b30:	ef 92       	push	r14
     b32:	ff 92       	push	r15
     b34:	0f 93       	push	r16
     b36:	1f 93       	push	r17
     b38:	cf 93       	push	r28
     b3a:	df 93       	push	r29
     b3c:	eb 01       	movw	r28, r22
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0, pendingShaftCount = 0;
	int plant_trigger=0;
	ReqdShaftCount = DistanceInMM / 12.92; // division by resolution to get shaft count
     b3e:	bc 01       	movw	r22, r24
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	90 e0       	ldi	r25, 0x00	; 0
     b44:	0e 94 fe 08 	call	0x11fc	; 0x11fc <__floatunsisf>
     b48:	22 e5       	ldi	r18, 0x52	; 82
     b4a:	38 eb       	ldi	r19, 0xB8	; 184
     b4c:	4e e4       	ldi	r20, 0x4E	; 78
     b4e:	51 e4       	ldi	r21, 0x41	; 65
     b50:	0e 94 65 08 	call	0x10ca	; 0x10ca <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     b54:	0e 94 d2 08 	call	0x11a4	; 0x11a4 <__fixunssfsi>
     b58:	c6 2e       	mov	r12, r22
     b5a:	d7 2e       	mov	r13, r23
     b5c:	e8 2e       	mov	r14, r24
     b5e:	f9 2e       	mov	r15, r25
	
	ShaftCountRight = 0;
     b60:	10 92 88 00 	sts	0x0088, r1
     b64:	10 92 89 00 	sts	0x0089, r1
     b68:	10 92 8a 00 	sts	0x008A, r1
     b6c:	10 92 8b 00 	sts	0x008B, r1
		proportional();	
		
		if(sign > 0){forward();}
		else if(sign < 0){ back();}	
			
		velocity(baseLine+p,baseLine-p);		
     b70:	00 e6       	ldi	r16, 0x60	; 96
     b72:	10 e0       	ldi	r17, 0x00	; 0
     b74:	0f 2e       	mov	r0, r31
     b76:	f2 e7       	ldi	r31, 0x72	; 114
     b78:	af 2e       	mov	r10, r31
     b7a:	f0 e0       	ldi	r31, 0x00	; 0
     b7c:	bf 2e       	mov	r11, r31
     b7e:	f0 2d       	mov	r31, r0
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
	
	ShaftCountRight = 0;
	while(1)
	{		
		readSensor();
     b80:	0e 94 4d 00 	call	0x9a	; 0x9a <readSensor>
		proportional();	
     b84:	0e 94 a0 00 	call	0x140	; 0x140 <proportional>
		
		if(sign > 0){forward();}
     b88:	1c 16       	cp	r1, r28
     b8a:	1d 06       	cpc	r1, r29
     b8c:	1c f4       	brge	.+6      	; 0xb94 <linear_distance_mm+0x6c>
     b8e:	0e 94 74 05 	call	0xae8	; 0xae8 <forward>
     b92:	04 c0       	rjmp	.+8      	; 0xb9c <linear_distance_mm+0x74>
		else if(sign < 0){ back();}	
     b94:	dd 23       	and	r29, r29
     b96:	14 f4       	brge	.+4      	; 0xb9c <linear_distance_mm+0x74>
     b98:	0e 94 78 05 	call	0xaf0	; 0xaf0 <back>
			
		velocity(baseLine+p,baseLine-p);		
     b9c:	f8 01       	movw	r30, r16
     b9e:	80 81       	ld	r24, Z
     ba0:	f5 01       	movw	r30, r10
     ba2:	90 81       	ld	r25, Z
     ba4:	68 2f       	mov	r22, r24
     ba6:	69 1b       	sub	r22, r25
     ba8:	89 0f       	add	r24, r25
     baa:	0e 94 22 03 	call	0x644	; 0x644 <velocity>
				buzzer_on();
				_delay_ms(3000);
				//servoAction();				
			} 
		}*/
		if(ShaftCountRight > ReqdShaftCountInt)
     bae:	80 91 88 00 	lds	r24, 0x0088
     bb2:	90 91 89 00 	lds	r25, 0x0089
     bb6:	a0 91 8a 00 	lds	r26, 0x008A
     bba:	b0 91 8b 00 	lds	r27, 0x008B
     bbe:	c8 16       	cp	r12, r24
     bc0:	d9 06       	cpc	r13, r25
     bc2:	ea 06       	cpc	r14, r26
     bc4:	fb 06       	cpc	r15, r27
     bc6:	e0 f6       	brcc	.-72     	; 0xb80 <linear_distance_mm+0x58>
		{
			break; 
		}
	}
	stop(); //Stop robot
     bc8:	0e 94 70 05 	call	0xae0	; 0xae0 <stop>
}
     bcc:	df 91       	pop	r29
     bce:	cf 91       	pop	r28
     bd0:	1f 91       	pop	r17
     bd2:	0f 91       	pop	r16
     bd4:	ff 90       	pop	r15
     bd6:	ef 90       	pop	r14
     bd8:	df 90       	pop	r13
     bda:	cf 90       	pop	r12
     bdc:	bf 90       	pop	r11
     bde:	af 90       	pop	r10
     be0:	08 95       	ret

00000be2 <forward_mm>:
		p=0;
	}
}

void forward_mm(unsigned int DistanceInMM, char purpose)
{
     be2:	46 2f       	mov	r20, r22
	
	linear_distance_mm(DistanceInMM, 1, purpose);
     be4:	61 e0       	ldi	r22, 0x01	; 1
     be6:	70 e0       	ldi	r23, 0x00	; 0
     be8:	0e 94 94 05 	call	0xb28	; 0xb28 <linear_distance_mm>
}
     bec:	08 95       	ret

00000bee <back_mm>:

void back_mm(unsigned int DistanceInMM, char purpose)
{
     bee:	46 2f       	mov	r20, r22
	linear_distance_mm(DistanceInMM, -1, purpose);
     bf0:	6f ef       	ldi	r22, 0xFF	; 255
     bf2:	7f ef       	ldi	r23, 0xFF	; 255
     bf4:	0e 94 94 05 	call	0xb28	; 0xb28 <linear_distance_mm>
}
     bf8:	08 95       	ret

00000bfa <left_degrees>:

void left_degrees(unsigned int Degrees)
{
     bfa:	cf 93       	push	r28
     bfc:	df 93       	push	r29
     bfe:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
     c00:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <left>
	angle_rotate(Degrees);
     c04:	ce 01       	movw	r24, r28
     c06:	0e 94 89 03 	call	0x712	; 0x712 <angle_rotate>
}
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	08 95       	ret

00000c10 <right_degrees>:



void right_degrees(unsigned int Degrees)
{
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right(); //Turn right
     c16:	0e 94 80 05 	call	0xb00	; 0xb00 <right>
	angle_rotate(Degrees);
     c1a:	ce 01       	movw	r24, r28
     c1c:	0e 94 89 03 	call	0x712	; 0x712 <angle_rotate>
}
     c20:	df 91       	pop	r29
     c22:	cf 91       	pop	r28
     c24:	08 95       	ret

00000c26 <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
     c2c:	0e 94 84 05 	call	0xb08	; 0xb08 <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     c30:	ce 01       	movw	r24, r28
     c32:	88 0f       	add	r24, r24
     c34:	99 1f       	adc	r25, r25
     c36:	0e 94 89 03 	call	0x712	; 0x712 <angle_rotate>
}
     c3a:	df 91       	pop	r29
     c3c:	cf 91       	pop	r28
     c3e:	08 95       	ret

00000c40 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     c40:	cf 93       	push	r28
     c42:	df 93       	push	r29
     c44:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
     c46:	0e 94 88 05 	call	0xb10	; 0xb10 <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     c4a:	ce 01       	movw	r24, r28
     c4c:	88 0f       	add	r24, r24
     c4e:	99 1f       	adc	r25, r25
     c50:	0e 94 89 03 	call	0x712	; 0x712 <angle_rotate>
}
     c54:	df 91       	pop	r29
     c56:	cf 91       	pop	r28
     c58:	08 95       	ret

00000c5a <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
     c60:	0e 94 8c 05 	call	0xb18	; 0xb18 <soft_left_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     c64:	ce 01       	movw	r24, r28
     c66:	88 0f       	add	r24, r24
     c68:	99 1f       	adc	r25, r25
     c6a:	0e 94 89 03 	call	0x712	; 0x712 <angle_rotate>
}
     c6e:	df 91       	pop	r29
     c70:	cf 91       	pop	r28
     c72:	08 95       	ret

00000c74 <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     c74:	cf 93       	push	r28
     c76:	df 93       	push	r29
     c78:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2();  //Turn reverse soft right
     c7a:	0e 94 90 05 	call	0xb20	; 0xb20 <soft_right_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     c7e:	ce 01       	movw	r24, r28
     c80:	88 0f       	add	r24, r24
     c82:	99 1f       	adc	r25, r25
     c84:	0e 94 89 03 	call	0x712	; 0x712 <angle_rotate>
}
     c88:	df 91       	pop	r29
     c8a:	cf 91       	pop	r28
     c8c:	08 95       	ret

00000c8e <manoeuvre>:
	int y_origin = 'D';
	
	
	
	
	int x_middle = x_F - x_origin;
     c8e:	9c 01       	movw	r18, r24
     c90:	24 50       	subi	r18, 0x04	; 4
     c92:	30 40       	sbci	r19, 0x00	; 0
	int y_middle = y_F - y_origin;
     c94:	64 54       	subi	r22, 0x44	; 68
     c96:	70 40       	sbci	r23, 0x00	; 0
	
	//For determining the final destination x-coordinate
	if( (x_middle) > 0 ){ x_D = 7; }
     c98:	12 16       	cp	r1, r18
     c9a:	13 06       	cpc	r1, r19
     c9c:	3c f4       	brge	.+14     	; 0xcac <manoeuvre+0x1e>
     c9e:	87 e0       	ldi	r24, 0x07	; 7
     ca0:	90 e0       	ldi	r25, 0x00	; 0
     ca2:	90 93 7f 00 	sts	0x007F, r25
     ca6:	80 93 7e 00 	sts	0x007E, r24
     caa:	06 c0       	rjmp	.+12     	; 0xcb8 <manoeuvre+0x2a>
	else { x_D = 1; }
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	90 93 7f 00 	sts	0x007F, r25
     cb4:	80 93 7e 00 	sts	0x007E, r24
	int x_intermediate = x_D - x_origin;
     cb8:	80 91 7e 00 	lds	r24, 0x007E
     cbc:	90 91 7f 00 	lds	r25, 0x007F
     cc0:	fc 01       	movw	r30, r24
     cc2:	34 97       	sbiw	r30, 0x04	; 4
	
	//For determining the final destination y-coordinate	
	if((y_middle) > 0){ y_D = 'F'; }	
     cc4:	16 16       	cp	r1, r22
     cc6:	17 06       	cpc	r1, r23
     cc8:	3c f4       	brge	.+14     	; 0xcd8 <manoeuvre+0x4a>
     cca:	86 e4       	ldi	r24, 0x46	; 70
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	90 93 7d 00 	sts	0x007D, r25
     cd2:	80 93 7c 00 	sts	0x007C, r24
     cd6:	10 c0       	rjmp	.+32     	; 0xcf8 <manoeuvre+0x6a>
	else if((y_middle) == 0){ y_D = 'D'; }
     cd8:	61 15       	cp	r22, r1
     cda:	71 05       	cpc	r23, r1
     cdc:	39 f4       	brne	.+14     	; 0xcec <manoeuvre+0x5e>
     cde:	84 e4       	ldi	r24, 0x44	; 68
     ce0:	90 e0       	ldi	r25, 0x00	; 0
     ce2:	90 93 7d 00 	sts	0x007D, r25
     ce6:	80 93 7c 00 	sts	0x007C, r24
     cea:	06 c0       	rjmp	.+12     	; 0xcf8 <manoeuvre+0x6a>
	else { y_D = 'B'; } 
     cec:	82 e4       	ldi	r24, 0x42	; 66
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	90 93 7d 00 	sts	0x007D, r25
     cf4:	80 93 7c 00 	sts	0x007C, r24
	int y_intermediate = y_D - y_origin;	
     cf8:	80 91 7c 00 	lds	r24, 0x007C
     cfc:	90 91 7d 00 	lds	r25, 0x007D
     d00:	84 54       	subi	r24, 0x44	; 68
     d02:	90 40       	sbci	r25, 0x00	; 0
	
	//How much to manoeuvre
	vertical = 	x_middle - x_intermediate;
     d04:	2e 1b       	sub	r18, r30
     d06:	3f 0b       	sbc	r19, r31
     d08:	30 93 83 00 	sts	0x0083, r19
     d0c:	20 93 82 00 	sts	0x0082, r18
	horizontal = y_middle - y_intermediate;
     d10:	68 1b       	sub	r22, r24
     d12:	79 0b       	sbc	r23, r25
     d14:	70 93 81 00 	sts	0x0081, r23
     d18:	60 93 80 00 	sts	0x0080, r22
	direction = dir_F;	
     d1c:	40 93 a8 00 	sts	0x00A8, r20
}
     d20:	08 95       	ret

00000d22 <rotate>:
	lcd_string("horiz");
	lcd_print(2,8, horizontal, 3);
}*/

void rotate(char face){
	switch(direction){
     d22:	90 91 a8 00 	lds	r25, 0x00A8
     d26:	9e 34       	cpi	r25, 0x4E	; 78
     d28:	61 f0       	breq	.+24     	; 0xd42 <rotate+0x20>
     d2a:	9f 34       	cpi	r25, 0x4F	; 79
     d2c:	20 f4       	brcc	.+8      	; 0xd36 <rotate+0x14>
     d2e:	95 34       	cpi	r25, 0x45	; 69
     d30:	09 f0       	breq	.+2      	; 0xd34 <rotate+0x12>
     d32:	5b c0       	rjmp	.+182    	; 0xdea <rotate+0xc8>
     d34:	46 c0       	rjmp	.+140    	; 0xdc2 <rotate+0xa0>
     d36:	93 35       	cpi	r25, 0x53	; 83
     d38:	79 f1       	breq	.+94     	; 0xd98 <rotate+0x76>
     d3a:	97 35       	cpi	r25, 0x57	; 87
     d3c:	09 f0       	breq	.+2      	; 0xd40 <rotate+0x1e>
     d3e:	55 c0       	rjmp	.+170    	; 0xdea <rotate+0xc8>
     d40:	16 c0       	rjmp	.+44     	; 0xd6e <rotate+0x4c>
		case 'N':{
			if(face == 'S'){right_degrees(180);}
     d42:	83 35       	cpi	r24, 0x53	; 83
     d44:	29 f4       	brne	.+10     	; 0xd50 <rotate+0x2e>
     d46:	84 eb       	ldi	r24, 0xB4	; 180
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	0e 94 08 06 	call	0xc10	; 0xc10 <right_degrees>
     d4e:	08 95       	ret
			else if(face == 'E'){right_degrees(90);}
     d50:	85 34       	cpi	r24, 0x45	; 69
     d52:	29 f4       	brne	.+10     	; 0xd5e <rotate+0x3c>
     d54:	8a e5       	ldi	r24, 0x5A	; 90
     d56:	90 e0       	ldi	r25, 0x00	; 0
     d58:	0e 94 08 06 	call	0xc10	; 0xc10 <right_degrees>
     d5c:	08 95       	ret
			else if(face == 'W'){left_degrees(90);}
     d5e:	87 35       	cpi	r24, 0x57	; 87
     d60:	09 f0       	breq	.+2      	; 0xd64 <rotate+0x42>
     d62:	43 c0       	rjmp	.+134    	; 0xdea <rotate+0xc8>
     d64:	8a e5       	ldi	r24, 0x5A	; 90
     d66:	90 e0       	ldi	r25, 0x00	; 0
     d68:	0e 94 fd 05 	call	0xbfa	; 0xbfa <left_degrees>
     d6c:	08 95       	ret
				break;
		}
		case 'W':{
			if(face == 'S'){left_degrees(90);}
     d6e:	83 35       	cpi	r24, 0x53	; 83
     d70:	29 f4       	brne	.+10     	; 0xd7c <rotate+0x5a>
     d72:	8a e5       	ldi	r24, 0x5A	; 90
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	0e 94 fd 05 	call	0xbfa	; 0xbfa <left_degrees>
     d7a:	08 95       	ret
			else if(face == 'E'){right_degrees(180);}
     d7c:	85 34       	cpi	r24, 0x45	; 69
     d7e:	29 f4       	brne	.+10     	; 0xd8a <rotate+0x68>
     d80:	84 eb       	ldi	r24, 0xB4	; 180
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	0e 94 08 06 	call	0xc10	; 0xc10 <right_degrees>
     d88:	08 95       	ret
			else if(face == 'N'){right_degrees(90);}
     d8a:	8e 34       	cpi	r24, 0x4E	; 78
     d8c:	71 f5       	brne	.+92     	; 0xdea <rotate+0xc8>
     d8e:	8a e5       	ldi	r24, 0x5A	; 90
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	0e 94 08 06 	call	0xc10	; 0xc10 <right_degrees>
     d96:	08 95       	ret
				break;
		}
		case 'S':{
			if(face == 'N'){right_degrees(180);}
     d98:	8e 34       	cpi	r24, 0x4E	; 78
     d9a:	29 f4       	brne	.+10     	; 0xda6 <rotate+0x84>
     d9c:	84 eb       	ldi	r24, 0xB4	; 180
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	0e 94 08 06 	call	0xc10	; 0xc10 <right_degrees>
     da4:	08 95       	ret
			else if(face == 'W'){right_degrees(90);}
     da6:	87 35       	cpi	r24, 0x57	; 87
     da8:	29 f4       	brne	.+10     	; 0xdb4 <rotate+0x92>
     daa:	8a e5       	ldi	r24, 0x5A	; 90
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	0e 94 08 06 	call	0xc10	; 0xc10 <right_degrees>
     db2:	08 95       	ret
			else if(face == 'E'){left_degrees(90);}
     db4:	85 34       	cpi	r24, 0x45	; 69
     db6:	c9 f4       	brne	.+50     	; 0xdea <rotate+0xc8>
     db8:	8a e5       	ldi	r24, 0x5A	; 90
     dba:	90 e0       	ldi	r25, 0x00	; 0
     dbc:	0e 94 fd 05 	call	0xbfa	; 0xbfa <left_degrees>
     dc0:	08 95       	ret
				break;
		}
		case 'E':{
			if(face == 'W'){right_degrees(180);}
     dc2:	87 35       	cpi	r24, 0x57	; 87
     dc4:	29 f4       	brne	.+10     	; 0xdd0 <rotate+0xae>
     dc6:	84 eb       	ldi	r24, 0xB4	; 180
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	0e 94 08 06 	call	0xc10	; 0xc10 <right_degrees>
     dce:	08 95       	ret
			else if(face == 'S'){right_degrees(90);}
     dd0:	83 35       	cpi	r24, 0x53	; 83
     dd2:	29 f4       	brne	.+10     	; 0xdde <rotate+0xbc>
     dd4:	8a e5       	ldi	r24, 0x5A	; 90
     dd6:	90 e0       	ldi	r25, 0x00	; 0
     dd8:	0e 94 08 06 	call	0xc10	; 0xc10 <right_degrees>
     ddc:	08 95       	ret
			else if(face == 'N'){left_degrees(90);}
     dde:	8e 34       	cpi	r24, 0x4E	; 78
     de0:	21 f4       	brne	.+8      	; 0xdea <rotate+0xc8>
     de2:	8a e5       	ldi	r24, 0x5A	; 90
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	0e 94 fd 05 	call	0xbfa	; 0xbfa <left_degrees>
     dea:	08 95       	ret

00000dec <vertical_motion>:
	}
}

void vertical_motion(){
	
	if(vertical < 0){ 
     dec:	80 91 82 00 	lds	r24, 0x0082
     df0:	90 91 83 00 	lds	r25, 0x0083
     df4:	99 23       	and	r25, r25
     df6:	24 f4       	brge	.+8      	; 0xe00 <vertical_motion+0x14>
		face = 'S';
     df8:	83 e5       	ldi	r24, 0x53	; 83
     dfa:	80 93 93 00 	sts	0x0093, r24
     dfe:	03 c0       	rjmp	.+6      	; 0xe06 <vertical_motion+0x1a>
	}
	else{
		face = 'N';
     e00:	8e e4       	ldi	r24, 0x4E	; 78
     e02:	80 93 93 00 	sts	0x0093, r24
	}
	rotate(face);
     e06:	80 91 93 00 	lds	r24, 0x0093
     e0a:	0e 94 91 06 	call	0xd22	; 0xd22 <rotate>
	direction = face;	
     e0e:	80 91 93 00 	lds	r24, 0x0093
     e12:	80 93 a8 00 	sts	0x00A8, r24
	vertical = abs(vertical);
     e16:	20 91 82 00 	lds	r18, 0x0082
     e1a:	30 91 83 00 	lds	r19, 0x0083
     e1e:	33 23       	and	r19, r19
     e20:	1c f4       	brge	.+6      	; 0xe28 <vertical_motion+0x3c>
     e22:	30 95       	com	r19
     e24:	21 95       	neg	r18
     e26:	3f 4f       	sbci	r19, 0xFF	; 255
     e28:	30 93 83 00 	sts	0x0083, r19
     e2c:	20 93 82 00 	sts	0x0082, r18
	//lcd_print(1,3, vertical, 3);
	DDRC|= 0b00000111;
     e30:	84 b3       	in	r24, 0x14	; 20
     e32:	87 60       	ori	r24, 0x07	; 7
     e34:	84 bb       	out	0x14, r24	; 20
	
	
	forward_mm(vertical * 340, 'S');
     e36:	84 e5       	ldi	r24, 0x54	; 84
     e38:	91 e0       	ldi	r25, 0x01	; 1
     e3a:	ac 01       	movw	r20, r24
     e3c:	24 9f       	mul	r18, r20
     e3e:	c0 01       	movw	r24, r0
     e40:	25 9f       	mul	r18, r21
     e42:	90 0d       	add	r25, r0
     e44:	34 9f       	mul	r19, r20
     e46:	90 0d       	add	r25, r0
     e48:	11 24       	eor	r1, r1
     e4a:	63 e5       	ldi	r22, 0x53	; 83
     e4c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <forward_mm>
	
}
     e50:	08 95       	ret

00000e52 <horizontal_motion>:
void horizontal_motion(){
	
	if(horizontal < 0){ 
     e52:	80 91 80 00 	lds	r24, 0x0080
     e56:	90 91 81 00 	lds	r25, 0x0081
     e5a:	99 23       	and	r25, r25
     e5c:	24 f4       	brge	.+8      	; 0xe66 <horizontal_motion+0x14>
		face = 'E';
     e5e:	85 e4       	ldi	r24, 0x45	; 69
     e60:	80 93 93 00 	sts	0x0093, r24
     e64:	03 c0       	rjmp	.+6      	; 0xe6c <horizontal_motion+0x1a>
	}
	else{
		face = 'W';
     e66:	87 e5       	ldi	r24, 0x57	; 87
     e68:	80 93 93 00 	sts	0x0093, r24
	}
	rotate(face);
     e6c:	80 91 93 00 	lds	r24, 0x0093
     e70:	0e 94 91 06 	call	0xd22	; 0xd22 <rotate>
	direction = face;
     e74:	80 91 93 00 	lds	r24, 0x0093
     e78:	80 93 a8 00 	sts	0x00A8, r24
	horizontal = abs(horizontal);
     e7c:	20 91 80 00 	lds	r18, 0x0080
     e80:	30 91 81 00 	lds	r19, 0x0081
     e84:	33 23       	and	r19, r19
     e86:	1c f4       	brge	.+6      	; 0xe8e <horizontal_motion+0x3c>
     e88:	30 95       	com	r19
     e8a:	21 95       	neg	r18
     e8c:	3f 4f       	sbci	r19, 0xFF	; 255
     e8e:	30 93 81 00 	sts	0x0081, r19
     e92:	20 93 80 00 	sts	0x0080, r18
	forward_mm(horizontal * 340, 'S');
     e96:	84 e5       	ldi	r24, 0x54	; 84
     e98:	91 e0       	ldi	r25, 0x01	; 1
     e9a:	ac 01       	movw	r20, r24
     e9c:	24 9f       	mul	r18, r20
     e9e:	c0 01       	movw	r24, r0
     ea0:	25 9f       	mul	r18, r21
     ea2:	90 0d       	add	r25, r0
     ea4:	34 9f       	mul	r19, r20
     ea6:	90 0d       	add	r25, r0
     ea8:	11 24       	eor	r1, r1
     eaa:	63 e5       	ldi	r22, 0x53	; 83
     eac:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <forward_mm>
}
     eb0:	08 95       	ret

00000eb2 <scan>:


void scan(int nodes){
     eb2:	af 92       	push	r10
     eb4:	bf 92       	push	r11
     eb6:	cf 92       	push	r12
     eb8:	df 92       	push	r13
     eba:	ef 92       	push	r14
     ebc:	ff 92       	push	r15
     ebe:	0f 93       	push	r16
     ec0:	1f 93       	push	r17
     ec2:	cf 93       	push	r28
     ec4:	df 93       	push	r29
			x_D = 1;
		}
		rotate(face);
		direction = face;
		_delay_ms(1000);
		forward_mm(((nodes-1) * 340), 'S');
     ec6:	9c 01       	movw	r18, r24
     ec8:	21 50       	subi	r18, 0x01	; 1
     eca:	30 40       	sbci	r19, 0x00	; 0
     ecc:	84 e5       	ldi	r24, 0x54	; 84
     ece:	91 e0       	ldi	r25, 0x01	; 1
     ed0:	28 9f       	mul	r18, r24
     ed2:	70 01       	movw	r14, r0
     ed4:	29 9f       	mul	r18, r25
     ed6:	f0 0c       	add	r15, r0
     ed8:	38 9f       	mul	r19, r24
     eda:	f0 0c       	add	r15, r0
     edc:	11 24       	eor	r1, r1
     ede:	c2 e0       	ldi	r28, 0x02	; 2
     ee0:	d0 e0       	ldi	r29, 0x00	; 0
		if(x_D == 1){
			face = 'S';
			x_D = 7; 
		}
		else if(x_D == 7){
			face = 'N';
     ee2:	0e e4       	ldi	r16, 0x4E	; 78
			x_D = 1;
     ee4:	aa 24       	eor	r10, r10
     ee6:	bb 24       	eor	r11, r11
     ee8:	a3 94       	inc	r10


void scan(int nodes){
	for(int i=0;i<2;i++){	
		if(x_D == 1){
			face = 'S';
     eea:	13 e5       	ldi	r17, 0x53	; 83
			x_D = 7; 
     eec:	0f 2e       	mov	r0, r31
     eee:	f7 e0       	ldi	r31, 0x07	; 7
     ef0:	cf 2e       	mov	r12, r31
     ef2:	dd 24       	eor	r13, r13
     ef4:	f0 2d       	mov	r31, r0
}


void scan(int nodes){
	for(int i=0;i<2;i++){	
		if(x_D == 1){
     ef6:	80 91 7e 00 	lds	r24, 0x007E
     efa:	90 91 7f 00 	lds	r25, 0x007F
     efe:	81 30       	cpi	r24, 0x01	; 1
     f00:	91 05       	cpc	r25, r1
     f02:	39 f4       	brne	.+14     	; 0xf12 <scan+0x60>
			face = 'S';
     f04:	10 93 93 00 	sts	0x0093, r17
			x_D = 7; 
     f08:	d0 92 7f 00 	sts	0x007F, r13
     f0c:	c0 92 7e 00 	sts	0x007E, r12
     f10:	09 c0       	rjmp	.+18     	; 0xf24 <scan+0x72>
		}
		else if(x_D == 7){
     f12:	87 30       	cpi	r24, 0x07	; 7
     f14:	91 05       	cpc	r25, r1
     f16:	31 f4       	brne	.+12     	; 0xf24 <scan+0x72>
			face = 'N';
     f18:	00 93 93 00 	sts	0x0093, r16
			x_D = 1;
     f1c:	b0 92 7f 00 	sts	0x007F, r11
     f20:	a0 92 7e 00 	sts	0x007E, r10
		}
		rotate(face);
     f24:	80 91 93 00 	lds	r24, 0x0093
     f28:	0e 94 91 06 	call	0xd22	; 0xd22 <rotate>
		direction = face;
     f2c:	80 91 93 00 	lds	r24, 0x0093
     f30:	80 93 a8 00 	sts	0x00A8, r24
     f34:	8f ef       	ldi	r24, 0xFF	; 255
     f36:	9f e7       	ldi	r25, 0x7F	; 127
     f38:	a6 e1       	ldi	r26, 0x16	; 22
     f3a:	81 50       	subi	r24, 0x01	; 1
     f3c:	90 40       	sbci	r25, 0x00	; 0
     f3e:	a0 40       	sbci	r26, 0x00	; 0
     f40:	e1 f7       	brne	.-8      	; 0xf3a <scan+0x88>
     f42:	00 c0       	rjmp	.+0      	; 0xf44 <scan+0x92>
     f44:	00 00       	nop
		_delay_ms(1000);
		forward_mm(((nodes-1) * 340), 'S');
     f46:	c7 01       	movw	r24, r14
     f48:	61 2f       	mov	r22, r17
     f4a:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <forward_mm>
     f4e:	8f ef       	ldi	r24, 0xFF	; 255
     f50:	9f e7       	ldi	r25, 0x7F	; 127
     f52:	a6 e1       	ldi	r26, 0x16	; 22
     f54:	81 50       	subi	r24, 0x01	; 1
     f56:	90 40       	sbci	r25, 0x00	; 0
     f58:	a0 40       	sbci	r26, 0x00	; 0
     f5a:	e1 f7       	brne	.-8      	; 0xf54 <scan+0xa2>
     f5c:	00 c0       	rjmp	.+0      	; 0xf5e <scan+0xac>
     f5e:	00 00       	nop
     f60:	21 97       	sbiw	r28, 0x01	; 1
	forward_mm(horizontal * 340, 'S');
}


void scan(int nodes){
	for(int i=0;i<2;i++){	
     f62:	49 f6       	brne	.-110    	; 0xef6 <scan+0x44>
	
	/*buzzer_on();
	_delay_ms(1000);
	buzzer_off();*/
			
}
     f64:	df 91       	pop	r29
     f66:	cf 91       	pop	r28
     f68:	1f 91       	pop	r17
     f6a:	0f 91       	pop	r16
     f6c:	ff 90       	pop	r15
     f6e:	ef 90       	pop	r14
     f70:	df 90       	pop	r13
     f72:	cf 90       	pop	r12
     f74:	bf 90       	pop	r11
     f76:	af 90       	pop	r10
     f78:	08 95       	ret

00000f7a <transmit>:

transmit(int grid_number){
	char v = (device_id*100)+grid_number;
     f7a:	20 91 6c 00 	lds	r18, 0x006C
     f7e:	94 e6       	ldi	r25, 0x64	; 100
     f80:	29 9f       	mul	r18, r25
     f82:	90 2d       	mov	r25, r0
     f84:	11 24       	eor	r1, r1
	USART_Transmit(v);
     f86:	89 0f       	add	r24, r25
     f88:	0e 94 75 02 	call	0x4ea	; 0x4ea <USART_Transmit>
}
     f8c:	08 95       	ret

00000f8e <init_devices>:

void init_devices (void)
{
	cli(); //Clears the global interrupts
     f8e:	f8 94       	cli
	port_init();
     f90:	0e 94 5f 05 	call	0xabe	; 0xabe <port_init>
	adc_init();
     f94:	0e 94 c5 02 	call	0x58a	; 0x58a <adc_init>
	timer1_init();
     f98:	0e 94 b5 02 	call	0x56a	; 0x56a <timer1_init>
	left_position_encoder_interrupt_init();
     f9c:	0e 94 2d 03 	call	0x65a	; 0x65a <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     fa0:	0e 94 36 03 	call	0x66c	; 0x66c <right_position_encoder_interrupt_init>
	
	uart0_init();
     fa4:	0e 94 6d 02 	call	0x4da	; 0x4da <uart0_init>
	sei();   //Enables the global interrupts
     fa8:	78 94       	sei
}
     faa:	08 95       	ret

00000fac <main>:

int main(void)
{	
	
	//lcd_port_config();
	init_devices();
     fac:	0e 94 c7 07 	call	0xf8e	; 0xf8e <init_devices>
		_delay_ms(1000);		//delay
		buzzer_off();*/
		
		
		//This function will set the nodes to travel in the vertical & horizontal direction for the bot to reach its standard spot
		manoeuvre(x_F, y_F, dir_F);	
     fb0:	85 e0       	ldi	r24, 0x05	; 5
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	64 e4       	ldi	r22, 0x44	; 68
     fb6:	70 e0       	ldi	r23, 0x00	; 0
     fb8:	4e e4       	ldi	r20, 0x4E	; 78
     fba:	0e 94 47 06 	call	0xc8e	; 0xc8e <manoeuvre>
			readSensor();			
			proportional();
			velocity(baseLine+p,baseLine-p);
		}*/			
				
		vertical_motion();
     fbe:	0e 94 f6 06 	call	0xdec	; 0xdec <vertical_motion>
		stop();
     fc2:	0e 94 70 05 	call	0xae0	; 0xae0 <stop>
     fc6:	8f ef       	ldi	r24, 0xFF	; 255
     fc8:	9f e7       	ldi	r25, 0x7F	; 127
     fca:	a6 e1       	ldi	r26, 0x16	; 22
     fcc:	81 50       	subi	r24, 0x01	; 1
     fce:	90 40       	sbci	r25, 0x00	; 0
     fd0:	a0 40       	sbci	r26, 0x00	; 0
     fd2:	e1 f7       	brne	.-8      	; 0xfcc <main+0x20>
     fd4:	00 c0       	rjmp	.+0      	; 0xfd6 <main+0x2a>
     fd6:	00 00       	nop
		_delay_ms(1000);
		horizontal_motion();
     fd8:	0e 94 29 07 	call	0xe52	; 0xe52 <horizontal_motion>
     fdc:	8f ef       	ldi	r24, 0xFF	; 255
     fde:	9f e7       	ldi	r25, 0x7F	; 127
     fe0:	a6 e1       	ldi	r26, 0x16	; 22
     fe2:	81 50       	subi	r24, 0x01	; 1
     fe4:	90 40       	sbci	r25, 0x00	; 0
     fe6:	a0 40       	sbci	r26, 0x00	; 0
     fe8:	e1 f7       	brne	.-8      	; 0xfe2 <main+0x36>
     fea:	00 c0       	rjmp	.+0      	; 0xfec <main+0x40>
     fec:	00 00       	nop
		
		//right_degrees(180);
		//_delay_ms(500);
		
		
		scan(STOPS);	
     fee:	87 e0       	ldi	r24, 0x07	; 7
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	0e 94 59 07 	call	0xeb2	; 0xeb2 <scan>
		stop();
     ff6:	0e 94 70 05 	call	0xae0	; 0xae0 <stop>
		
		
     ffa:	80 e0       	ldi	r24, 0x00	; 0
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	08 95       	ret

00001000 <__subsf3>:
    1000:	50 58       	subi	r21, 0x80	; 128

00001002 <__addsf3>:
    1002:	bb 27       	eor	r27, r27
    1004:	aa 27       	eor	r26, r26
    1006:	0e d0       	rcall	.+28     	; 0x1024 <__addsf3x>
    1008:	4d c1       	rjmp	.+666    	; 0x12a4 <__fp_round>
    100a:	3e d1       	rcall	.+636    	; 0x1288 <__fp_pscA>
    100c:	30 f0       	brcs	.+12     	; 0x101a <__addsf3+0x18>
    100e:	43 d1       	rcall	.+646    	; 0x1296 <__fp_pscB>
    1010:	20 f0       	brcs	.+8      	; 0x101a <__addsf3+0x18>
    1012:	31 f4       	brne	.+12     	; 0x1020 <__addsf3+0x1e>
    1014:	9f 3f       	cpi	r25, 0xFF	; 255
    1016:	11 f4       	brne	.+4      	; 0x101c <__addsf3+0x1a>
    1018:	1e f4       	brtc	.+6      	; 0x1020 <__addsf3+0x1e>
    101a:	33 c1       	rjmp	.+614    	; 0x1282 <__fp_nan>
    101c:	0e f4       	brtc	.+2      	; 0x1020 <__addsf3+0x1e>
    101e:	e0 95       	com	r30
    1020:	e7 fb       	bst	r30, 7
    1022:	29 c1       	rjmp	.+594    	; 0x1276 <__fp_inf>

00001024 <__addsf3x>:
    1024:	e9 2f       	mov	r30, r25
    1026:	4f d1       	rcall	.+670    	; 0x12c6 <__fp_split3>
    1028:	80 f3       	brcs	.-32     	; 0x100a <__addsf3+0x8>
    102a:	ba 17       	cp	r27, r26
    102c:	62 07       	cpc	r22, r18
    102e:	73 07       	cpc	r23, r19
    1030:	84 07       	cpc	r24, r20
    1032:	95 07       	cpc	r25, r21
    1034:	18 f0       	brcs	.+6      	; 0x103c <__addsf3x+0x18>
    1036:	71 f4       	brne	.+28     	; 0x1054 <__addsf3x+0x30>
    1038:	9e f5       	brtc	.+102    	; 0x10a0 <__addsf3x+0x7c>
    103a:	67 c1       	rjmp	.+718    	; 0x130a <__fp_zero>
    103c:	0e f4       	brtc	.+2      	; 0x1040 <__addsf3x+0x1c>
    103e:	e0 95       	com	r30
    1040:	0b 2e       	mov	r0, r27
    1042:	ba 2f       	mov	r27, r26
    1044:	a0 2d       	mov	r26, r0
    1046:	0b 01       	movw	r0, r22
    1048:	b9 01       	movw	r22, r18
    104a:	90 01       	movw	r18, r0
    104c:	0c 01       	movw	r0, r24
    104e:	ca 01       	movw	r24, r20
    1050:	a0 01       	movw	r20, r0
    1052:	11 24       	eor	r1, r1
    1054:	ff 27       	eor	r31, r31
    1056:	59 1b       	sub	r21, r25
    1058:	99 f0       	breq	.+38     	; 0x1080 <__addsf3x+0x5c>
    105a:	59 3f       	cpi	r21, 0xF9	; 249
    105c:	50 f4       	brcc	.+20     	; 0x1072 <__addsf3x+0x4e>
    105e:	50 3e       	cpi	r21, 0xE0	; 224
    1060:	68 f1       	brcs	.+90     	; 0x10bc <__addsf3x+0x98>
    1062:	1a 16       	cp	r1, r26
    1064:	f0 40       	sbci	r31, 0x00	; 0
    1066:	a2 2f       	mov	r26, r18
    1068:	23 2f       	mov	r18, r19
    106a:	34 2f       	mov	r19, r20
    106c:	44 27       	eor	r20, r20
    106e:	58 5f       	subi	r21, 0xF8	; 248
    1070:	f3 cf       	rjmp	.-26     	; 0x1058 <__addsf3x+0x34>
    1072:	46 95       	lsr	r20
    1074:	37 95       	ror	r19
    1076:	27 95       	ror	r18
    1078:	a7 95       	ror	r26
    107a:	f0 40       	sbci	r31, 0x00	; 0
    107c:	53 95       	inc	r21
    107e:	c9 f7       	brne	.-14     	; 0x1072 <__addsf3x+0x4e>
    1080:	7e f4       	brtc	.+30     	; 0x10a0 <__addsf3x+0x7c>
    1082:	1f 16       	cp	r1, r31
    1084:	ba 0b       	sbc	r27, r26
    1086:	62 0b       	sbc	r22, r18
    1088:	73 0b       	sbc	r23, r19
    108a:	84 0b       	sbc	r24, r20
    108c:	ba f0       	brmi	.+46     	; 0x10bc <__addsf3x+0x98>
    108e:	91 50       	subi	r25, 0x01	; 1
    1090:	a1 f0       	breq	.+40     	; 0x10ba <__addsf3x+0x96>
    1092:	ff 0f       	add	r31, r31
    1094:	bb 1f       	adc	r27, r27
    1096:	66 1f       	adc	r22, r22
    1098:	77 1f       	adc	r23, r23
    109a:	88 1f       	adc	r24, r24
    109c:	c2 f7       	brpl	.-16     	; 0x108e <__addsf3x+0x6a>
    109e:	0e c0       	rjmp	.+28     	; 0x10bc <__addsf3x+0x98>
    10a0:	ba 0f       	add	r27, r26
    10a2:	62 1f       	adc	r22, r18
    10a4:	73 1f       	adc	r23, r19
    10a6:	84 1f       	adc	r24, r20
    10a8:	48 f4       	brcc	.+18     	; 0x10bc <__addsf3x+0x98>
    10aa:	87 95       	ror	r24
    10ac:	77 95       	ror	r23
    10ae:	67 95       	ror	r22
    10b0:	b7 95       	ror	r27
    10b2:	f7 95       	ror	r31
    10b4:	9e 3f       	cpi	r25, 0xFE	; 254
    10b6:	08 f0       	brcs	.+2      	; 0x10ba <__addsf3x+0x96>
    10b8:	b3 cf       	rjmp	.-154    	; 0x1020 <__addsf3+0x1e>
    10ba:	93 95       	inc	r25
    10bc:	88 0f       	add	r24, r24
    10be:	08 f0       	brcs	.+2      	; 0x10c2 <__addsf3x+0x9e>
    10c0:	99 27       	eor	r25, r25
    10c2:	ee 0f       	add	r30, r30
    10c4:	97 95       	ror	r25
    10c6:	87 95       	ror	r24
    10c8:	08 95       	ret

000010ca <__divsf3>:
    10ca:	0c d0       	rcall	.+24     	; 0x10e4 <__divsf3x>
    10cc:	eb c0       	rjmp	.+470    	; 0x12a4 <__fp_round>
    10ce:	e3 d0       	rcall	.+454    	; 0x1296 <__fp_pscB>
    10d0:	40 f0       	brcs	.+16     	; 0x10e2 <__divsf3+0x18>
    10d2:	da d0       	rcall	.+436    	; 0x1288 <__fp_pscA>
    10d4:	30 f0       	brcs	.+12     	; 0x10e2 <__divsf3+0x18>
    10d6:	21 f4       	brne	.+8      	; 0x10e0 <__divsf3+0x16>
    10d8:	5f 3f       	cpi	r21, 0xFF	; 255
    10da:	19 f0       	breq	.+6      	; 0x10e2 <__divsf3+0x18>
    10dc:	cc c0       	rjmp	.+408    	; 0x1276 <__fp_inf>
    10de:	51 11       	cpse	r21, r1
    10e0:	15 c1       	rjmp	.+554    	; 0x130c <__fp_szero>
    10e2:	cf c0       	rjmp	.+414    	; 0x1282 <__fp_nan>

000010e4 <__divsf3x>:
    10e4:	f0 d0       	rcall	.+480    	; 0x12c6 <__fp_split3>
    10e6:	98 f3       	brcs	.-26     	; 0x10ce <__divsf3+0x4>

000010e8 <__divsf3_pse>:
    10e8:	99 23       	and	r25, r25
    10ea:	c9 f3       	breq	.-14     	; 0x10de <__divsf3+0x14>
    10ec:	55 23       	and	r21, r21
    10ee:	b1 f3       	breq	.-20     	; 0x10dc <__divsf3+0x12>
    10f0:	95 1b       	sub	r25, r21
    10f2:	55 0b       	sbc	r21, r21
    10f4:	bb 27       	eor	r27, r27
    10f6:	aa 27       	eor	r26, r26
    10f8:	62 17       	cp	r22, r18
    10fa:	73 07       	cpc	r23, r19
    10fc:	84 07       	cpc	r24, r20
    10fe:	38 f0       	brcs	.+14     	; 0x110e <__divsf3_pse+0x26>
    1100:	9f 5f       	subi	r25, 0xFF	; 255
    1102:	5f 4f       	sbci	r21, 0xFF	; 255
    1104:	22 0f       	add	r18, r18
    1106:	33 1f       	adc	r19, r19
    1108:	44 1f       	adc	r20, r20
    110a:	aa 1f       	adc	r26, r26
    110c:	a9 f3       	breq	.-22     	; 0x10f8 <__divsf3_pse+0x10>
    110e:	33 d0       	rcall	.+102    	; 0x1176 <__divsf3_pse+0x8e>
    1110:	0e 2e       	mov	r0, r30
    1112:	3a f0       	brmi	.+14     	; 0x1122 <__divsf3_pse+0x3a>
    1114:	e0 e8       	ldi	r30, 0x80	; 128
    1116:	30 d0       	rcall	.+96     	; 0x1178 <__divsf3_pse+0x90>
    1118:	91 50       	subi	r25, 0x01	; 1
    111a:	50 40       	sbci	r21, 0x00	; 0
    111c:	e6 95       	lsr	r30
    111e:	00 1c       	adc	r0, r0
    1120:	ca f7       	brpl	.-14     	; 0x1114 <__divsf3_pse+0x2c>
    1122:	29 d0       	rcall	.+82     	; 0x1176 <__divsf3_pse+0x8e>
    1124:	fe 2f       	mov	r31, r30
    1126:	27 d0       	rcall	.+78     	; 0x1176 <__divsf3_pse+0x8e>
    1128:	66 0f       	add	r22, r22
    112a:	77 1f       	adc	r23, r23
    112c:	88 1f       	adc	r24, r24
    112e:	bb 1f       	adc	r27, r27
    1130:	26 17       	cp	r18, r22
    1132:	37 07       	cpc	r19, r23
    1134:	48 07       	cpc	r20, r24
    1136:	ab 07       	cpc	r26, r27
    1138:	b0 e8       	ldi	r27, 0x80	; 128
    113a:	09 f0       	breq	.+2      	; 0x113e <__divsf3_pse+0x56>
    113c:	bb 0b       	sbc	r27, r27
    113e:	80 2d       	mov	r24, r0
    1140:	bf 01       	movw	r22, r30
    1142:	ff 27       	eor	r31, r31
    1144:	93 58       	subi	r25, 0x83	; 131
    1146:	5f 4f       	sbci	r21, 0xFF	; 255
    1148:	2a f0       	brmi	.+10     	; 0x1154 <__divsf3_pse+0x6c>
    114a:	9e 3f       	cpi	r25, 0xFE	; 254
    114c:	51 05       	cpc	r21, r1
    114e:	68 f0       	brcs	.+26     	; 0x116a <__divsf3_pse+0x82>
    1150:	92 c0       	rjmp	.+292    	; 0x1276 <__fp_inf>
    1152:	dc c0       	rjmp	.+440    	; 0x130c <__fp_szero>
    1154:	5f 3f       	cpi	r21, 0xFF	; 255
    1156:	ec f3       	brlt	.-6      	; 0x1152 <__divsf3_pse+0x6a>
    1158:	98 3e       	cpi	r25, 0xE8	; 232
    115a:	dc f3       	brlt	.-10     	; 0x1152 <__divsf3_pse+0x6a>
    115c:	86 95       	lsr	r24
    115e:	77 95       	ror	r23
    1160:	67 95       	ror	r22
    1162:	b7 95       	ror	r27
    1164:	f7 95       	ror	r31
    1166:	9f 5f       	subi	r25, 0xFF	; 255
    1168:	c9 f7       	brne	.-14     	; 0x115c <__divsf3_pse+0x74>
    116a:	88 0f       	add	r24, r24
    116c:	91 1d       	adc	r25, r1
    116e:	96 95       	lsr	r25
    1170:	87 95       	ror	r24
    1172:	97 f9       	bld	r25, 7
    1174:	08 95       	ret
    1176:	e1 e0       	ldi	r30, 0x01	; 1
    1178:	66 0f       	add	r22, r22
    117a:	77 1f       	adc	r23, r23
    117c:	88 1f       	adc	r24, r24
    117e:	bb 1f       	adc	r27, r27
    1180:	62 17       	cp	r22, r18
    1182:	73 07       	cpc	r23, r19
    1184:	84 07       	cpc	r24, r20
    1186:	ba 07       	cpc	r27, r26
    1188:	20 f0       	brcs	.+8      	; 0x1192 <__divsf3_pse+0xaa>
    118a:	62 1b       	sub	r22, r18
    118c:	73 0b       	sbc	r23, r19
    118e:	84 0b       	sbc	r24, r20
    1190:	ba 0b       	sbc	r27, r26
    1192:	ee 1f       	adc	r30, r30
    1194:	88 f7       	brcc	.-30     	; 0x1178 <__divsf3_pse+0x90>
    1196:	e0 95       	com	r30
    1198:	08 95       	ret

0000119a <__fixsfsi>:
    119a:	04 d0       	rcall	.+8      	; 0x11a4 <__fixunssfsi>
    119c:	68 94       	set
    119e:	b1 11       	cpse	r27, r1
    11a0:	b5 c0       	rjmp	.+362    	; 0x130c <__fp_szero>
    11a2:	08 95       	ret

000011a4 <__fixunssfsi>:
    11a4:	98 d0       	rcall	.+304    	; 0x12d6 <__fp_splitA>
    11a6:	88 f0       	brcs	.+34     	; 0x11ca <__fixunssfsi+0x26>
    11a8:	9f 57       	subi	r25, 0x7F	; 127
    11aa:	90 f0       	brcs	.+36     	; 0x11d0 <__fixunssfsi+0x2c>
    11ac:	b9 2f       	mov	r27, r25
    11ae:	99 27       	eor	r25, r25
    11b0:	b7 51       	subi	r27, 0x17	; 23
    11b2:	a0 f0       	brcs	.+40     	; 0x11dc <__fixunssfsi+0x38>
    11b4:	d1 f0       	breq	.+52     	; 0x11ea <__fixunssfsi+0x46>
    11b6:	66 0f       	add	r22, r22
    11b8:	77 1f       	adc	r23, r23
    11ba:	88 1f       	adc	r24, r24
    11bc:	99 1f       	adc	r25, r25
    11be:	1a f0       	brmi	.+6      	; 0x11c6 <__fixunssfsi+0x22>
    11c0:	ba 95       	dec	r27
    11c2:	c9 f7       	brne	.-14     	; 0x11b6 <__fixunssfsi+0x12>
    11c4:	12 c0       	rjmp	.+36     	; 0x11ea <__fixunssfsi+0x46>
    11c6:	b1 30       	cpi	r27, 0x01	; 1
    11c8:	81 f0       	breq	.+32     	; 0x11ea <__fixunssfsi+0x46>
    11ca:	9f d0       	rcall	.+318    	; 0x130a <__fp_zero>
    11cc:	b1 e0       	ldi	r27, 0x01	; 1
    11ce:	08 95       	ret
    11d0:	9c c0       	rjmp	.+312    	; 0x130a <__fp_zero>
    11d2:	67 2f       	mov	r22, r23
    11d4:	78 2f       	mov	r23, r24
    11d6:	88 27       	eor	r24, r24
    11d8:	b8 5f       	subi	r27, 0xF8	; 248
    11da:	39 f0       	breq	.+14     	; 0x11ea <__fixunssfsi+0x46>
    11dc:	b9 3f       	cpi	r27, 0xF9	; 249
    11de:	cc f3       	brlt	.-14     	; 0x11d2 <__fixunssfsi+0x2e>
    11e0:	86 95       	lsr	r24
    11e2:	77 95       	ror	r23
    11e4:	67 95       	ror	r22
    11e6:	b3 95       	inc	r27
    11e8:	d9 f7       	brne	.-10     	; 0x11e0 <__fixunssfsi+0x3c>
    11ea:	3e f4       	brtc	.+14     	; 0x11fa <__fixunssfsi+0x56>
    11ec:	90 95       	com	r25
    11ee:	80 95       	com	r24
    11f0:	70 95       	com	r23
    11f2:	61 95       	neg	r22
    11f4:	7f 4f       	sbci	r23, 0xFF	; 255
    11f6:	8f 4f       	sbci	r24, 0xFF	; 255
    11f8:	9f 4f       	sbci	r25, 0xFF	; 255
    11fa:	08 95       	ret

000011fc <__floatunsisf>:
    11fc:	e8 94       	clt
    11fe:	09 c0       	rjmp	.+18     	; 0x1212 <__floatsisf+0x12>

00001200 <__floatsisf>:
    1200:	97 fb       	bst	r25, 7
    1202:	3e f4       	brtc	.+14     	; 0x1212 <__floatsisf+0x12>
    1204:	90 95       	com	r25
    1206:	80 95       	com	r24
    1208:	70 95       	com	r23
    120a:	61 95       	neg	r22
    120c:	7f 4f       	sbci	r23, 0xFF	; 255
    120e:	8f 4f       	sbci	r24, 0xFF	; 255
    1210:	9f 4f       	sbci	r25, 0xFF	; 255
    1212:	99 23       	and	r25, r25
    1214:	a9 f0       	breq	.+42     	; 0x1240 <__floatsisf+0x40>
    1216:	f9 2f       	mov	r31, r25
    1218:	96 e9       	ldi	r25, 0x96	; 150
    121a:	bb 27       	eor	r27, r27
    121c:	93 95       	inc	r25
    121e:	f6 95       	lsr	r31
    1220:	87 95       	ror	r24
    1222:	77 95       	ror	r23
    1224:	67 95       	ror	r22
    1226:	b7 95       	ror	r27
    1228:	f1 11       	cpse	r31, r1
    122a:	f8 cf       	rjmp	.-16     	; 0x121c <__floatsisf+0x1c>
    122c:	fa f4       	brpl	.+62     	; 0x126c <__floatsisf+0x6c>
    122e:	bb 0f       	add	r27, r27
    1230:	11 f4       	brne	.+4      	; 0x1236 <__floatsisf+0x36>
    1232:	60 ff       	sbrs	r22, 0
    1234:	1b c0       	rjmp	.+54     	; 0x126c <__floatsisf+0x6c>
    1236:	6f 5f       	subi	r22, 0xFF	; 255
    1238:	7f 4f       	sbci	r23, 0xFF	; 255
    123a:	8f 4f       	sbci	r24, 0xFF	; 255
    123c:	9f 4f       	sbci	r25, 0xFF	; 255
    123e:	16 c0       	rjmp	.+44     	; 0x126c <__floatsisf+0x6c>
    1240:	88 23       	and	r24, r24
    1242:	11 f0       	breq	.+4      	; 0x1248 <__floatsisf+0x48>
    1244:	96 e9       	ldi	r25, 0x96	; 150
    1246:	11 c0       	rjmp	.+34     	; 0x126a <__floatsisf+0x6a>
    1248:	77 23       	and	r23, r23
    124a:	21 f0       	breq	.+8      	; 0x1254 <__floatsisf+0x54>
    124c:	9e e8       	ldi	r25, 0x8E	; 142
    124e:	87 2f       	mov	r24, r23
    1250:	76 2f       	mov	r23, r22
    1252:	05 c0       	rjmp	.+10     	; 0x125e <__floatsisf+0x5e>
    1254:	66 23       	and	r22, r22
    1256:	71 f0       	breq	.+28     	; 0x1274 <__floatsisf+0x74>
    1258:	96 e8       	ldi	r25, 0x86	; 134
    125a:	86 2f       	mov	r24, r22
    125c:	70 e0       	ldi	r23, 0x00	; 0
    125e:	60 e0       	ldi	r22, 0x00	; 0
    1260:	2a f0       	brmi	.+10     	; 0x126c <__floatsisf+0x6c>
    1262:	9a 95       	dec	r25
    1264:	66 0f       	add	r22, r22
    1266:	77 1f       	adc	r23, r23
    1268:	88 1f       	adc	r24, r24
    126a:	da f7       	brpl	.-10     	; 0x1262 <__floatsisf+0x62>
    126c:	88 0f       	add	r24, r24
    126e:	96 95       	lsr	r25
    1270:	87 95       	ror	r24
    1272:	97 f9       	bld	r25, 7
    1274:	08 95       	ret

00001276 <__fp_inf>:
    1276:	97 f9       	bld	r25, 7
    1278:	9f 67       	ori	r25, 0x7F	; 127
    127a:	80 e8       	ldi	r24, 0x80	; 128
    127c:	70 e0       	ldi	r23, 0x00	; 0
    127e:	60 e0       	ldi	r22, 0x00	; 0
    1280:	08 95       	ret

00001282 <__fp_nan>:
    1282:	9f ef       	ldi	r25, 0xFF	; 255
    1284:	80 ec       	ldi	r24, 0xC0	; 192
    1286:	08 95       	ret

00001288 <__fp_pscA>:
    1288:	00 24       	eor	r0, r0
    128a:	0a 94       	dec	r0
    128c:	16 16       	cp	r1, r22
    128e:	17 06       	cpc	r1, r23
    1290:	18 06       	cpc	r1, r24
    1292:	09 06       	cpc	r0, r25
    1294:	08 95       	ret

00001296 <__fp_pscB>:
    1296:	00 24       	eor	r0, r0
    1298:	0a 94       	dec	r0
    129a:	12 16       	cp	r1, r18
    129c:	13 06       	cpc	r1, r19
    129e:	14 06       	cpc	r1, r20
    12a0:	05 06       	cpc	r0, r21
    12a2:	08 95       	ret

000012a4 <__fp_round>:
    12a4:	09 2e       	mov	r0, r25
    12a6:	03 94       	inc	r0
    12a8:	00 0c       	add	r0, r0
    12aa:	11 f4       	brne	.+4      	; 0x12b0 <__fp_round+0xc>
    12ac:	88 23       	and	r24, r24
    12ae:	52 f0       	brmi	.+20     	; 0x12c4 <__fp_round+0x20>
    12b0:	bb 0f       	add	r27, r27
    12b2:	40 f4       	brcc	.+16     	; 0x12c4 <__fp_round+0x20>
    12b4:	bf 2b       	or	r27, r31
    12b6:	11 f4       	brne	.+4      	; 0x12bc <__fp_round+0x18>
    12b8:	60 ff       	sbrs	r22, 0
    12ba:	04 c0       	rjmp	.+8      	; 0x12c4 <__fp_round+0x20>
    12bc:	6f 5f       	subi	r22, 0xFF	; 255
    12be:	7f 4f       	sbci	r23, 0xFF	; 255
    12c0:	8f 4f       	sbci	r24, 0xFF	; 255
    12c2:	9f 4f       	sbci	r25, 0xFF	; 255
    12c4:	08 95       	ret

000012c6 <__fp_split3>:
    12c6:	57 fd       	sbrc	r21, 7
    12c8:	90 58       	subi	r25, 0x80	; 128
    12ca:	44 0f       	add	r20, r20
    12cc:	55 1f       	adc	r21, r21
    12ce:	59 f0       	breq	.+22     	; 0x12e6 <__fp_splitA+0x10>
    12d0:	5f 3f       	cpi	r21, 0xFF	; 255
    12d2:	71 f0       	breq	.+28     	; 0x12f0 <__fp_splitA+0x1a>
    12d4:	47 95       	ror	r20

000012d6 <__fp_splitA>:
    12d6:	88 0f       	add	r24, r24
    12d8:	97 fb       	bst	r25, 7
    12da:	99 1f       	adc	r25, r25
    12dc:	61 f0       	breq	.+24     	; 0x12f6 <__fp_splitA+0x20>
    12de:	9f 3f       	cpi	r25, 0xFF	; 255
    12e0:	79 f0       	breq	.+30     	; 0x1300 <__fp_splitA+0x2a>
    12e2:	87 95       	ror	r24
    12e4:	08 95       	ret
    12e6:	12 16       	cp	r1, r18
    12e8:	13 06       	cpc	r1, r19
    12ea:	14 06       	cpc	r1, r20
    12ec:	55 1f       	adc	r21, r21
    12ee:	f2 cf       	rjmp	.-28     	; 0x12d4 <__fp_split3+0xe>
    12f0:	46 95       	lsr	r20
    12f2:	f1 df       	rcall	.-30     	; 0x12d6 <__fp_splitA>
    12f4:	08 c0       	rjmp	.+16     	; 0x1306 <__fp_splitA+0x30>
    12f6:	16 16       	cp	r1, r22
    12f8:	17 06       	cpc	r1, r23
    12fa:	18 06       	cpc	r1, r24
    12fc:	99 1f       	adc	r25, r25
    12fe:	f1 cf       	rjmp	.-30     	; 0x12e2 <__fp_splitA+0xc>
    1300:	86 95       	lsr	r24
    1302:	71 05       	cpc	r23, r1
    1304:	61 05       	cpc	r22, r1
    1306:	08 94       	sec
    1308:	08 95       	ret

0000130a <__fp_zero>:
    130a:	e8 94       	clt

0000130c <__fp_szero>:
    130c:	bb 27       	eor	r27, r27
    130e:	66 27       	eor	r22, r22
    1310:	77 27       	eor	r23, r23
    1312:	cb 01       	movw	r24, r22
    1314:	97 f9       	bld	r25, 7
    1316:	08 95       	ret

00001318 <__mulsf3>:
    1318:	0b d0       	rcall	.+22     	; 0x1330 <__mulsf3x>
    131a:	c4 cf       	rjmp	.-120    	; 0x12a4 <__fp_round>
    131c:	b5 df       	rcall	.-150    	; 0x1288 <__fp_pscA>
    131e:	28 f0       	brcs	.+10     	; 0x132a <__mulsf3+0x12>
    1320:	ba df       	rcall	.-140    	; 0x1296 <__fp_pscB>
    1322:	18 f0       	brcs	.+6      	; 0x132a <__mulsf3+0x12>
    1324:	95 23       	and	r25, r21
    1326:	09 f0       	breq	.+2      	; 0x132a <__mulsf3+0x12>
    1328:	a6 cf       	rjmp	.-180    	; 0x1276 <__fp_inf>
    132a:	ab cf       	rjmp	.-170    	; 0x1282 <__fp_nan>
    132c:	11 24       	eor	r1, r1
    132e:	ee cf       	rjmp	.-36     	; 0x130c <__fp_szero>

00001330 <__mulsf3x>:
    1330:	ca df       	rcall	.-108    	; 0x12c6 <__fp_split3>
    1332:	a0 f3       	brcs	.-24     	; 0x131c <__mulsf3+0x4>

00001334 <__mulsf3_pse>:
    1334:	95 9f       	mul	r25, r21
    1336:	d1 f3       	breq	.-12     	; 0x132c <__mulsf3+0x14>
    1338:	95 0f       	add	r25, r21
    133a:	50 e0       	ldi	r21, 0x00	; 0
    133c:	55 1f       	adc	r21, r21
    133e:	62 9f       	mul	r22, r18
    1340:	f0 01       	movw	r30, r0
    1342:	72 9f       	mul	r23, r18
    1344:	bb 27       	eor	r27, r27
    1346:	f0 0d       	add	r31, r0
    1348:	b1 1d       	adc	r27, r1
    134a:	63 9f       	mul	r22, r19
    134c:	aa 27       	eor	r26, r26
    134e:	f0 0d       	add	r31, r0
    1350:	b1 1d       	adc	r27, r1
    1352:	aa 1f       	adc	r26, r26
    1354:	64 9f       	mul	r22, r20
    1356:	66 27       	eor	r22, r22
    1358:	b0 0d       	add	r27, r0
    135a:	a1 1d       	adc	r26, r1
    135c:	66 1f       	adc	r22, r22
    135e:	82 9f       	mul	r24, r18
    1360:	22 27       	eor	r18, r18
    1362:	b0 0d       	add	r27, r0
    1364:	a1 1d       	adc	r26, r1
    1366:	62 1f       	adc	r22, r18
    1368:	73 9f       	mul	r23, r19
    136a:	b0 0d       	add	r27, r0
    136c:	a1 1d       	adc	r26, r1
    136e:	62 1f       	adc	r22, r18
    1370:	83 9f       	mul	r24, r19
    1372:	a0 0d       	add	r26, r0
    1374:	61 1d       	adc	r22, r1
    1376:	22 1f       	adc	r18, r18
    1378:	74 9f       	mul	r23, r20
    137a:	33 27       	eor	r19, r19
    137c:	a0 0d       	add	r26, r0
    137e:	61 1d       	adc	r22, r1
    1380:	23 1f       	adc	r18, r19
    1382:	84 9f       	mul	r24, r20
    1384:	60 0d       	add	r22, r0
    1386:	21 1d       	adc	r18, r1
    1388:	82 2f       	mov	r24, r18
    138a:	76 2f       	mov	r23, r22
    138c:	6a 2f       	mov	r22, r26
    138e:	11 24       	eor	r1, r1
    1390:	9f 57       	subi	r25, 0x7F	; 127
    1392:	50 40       	sbci	r21, 0x00	; 0
    1394:	8a f0       	brmi	.+34     	; 0x13b8 <__mulsf3_pse+0x84>
    1396:	e1 f0       	breq	.+56     	; 0x13d0 <__mulsf3_pse+0x9c>
    1398:	88 23       	and	r24, r24
    139a:	4a f0       	brmi	.+18     	; 0x13ae <__mulsf3_pse+0x7a>
    139c:	ee 0f       	add	r30, r30
    139e:	ff 1f       	adc	r31, r31
    13a0:	bb 1f       	adc	r27, r27
    13a2:	66 1f       	adc	r22, r22
    13a4:	77 1f       	adc	r23, r23
    13a6:	88 1f       	adc	r24, r24
    13a8:	91 50       	subi	r25, 0x01	; 1
    13aa:	50 40       	sbci	r21, 0x00	; 0
    13ac:	a9 f7       	brne	.-22     	; 0x1398 <__mulsf3_pse+0x64>
    13ae:	9e 3f       	cpi	r25, 0xFE	; 254
    13b0:	51 05       	cpc	r21, r1
    13b2:	70 f0       	brcs	.+28     	; 0x13d0 <__mulsf3_pse+0x9c>
    13b4:	60 cf       	rjmp	.-320    	; 0x1276 <__fp_inf>
    13b6:	aa cf       	rjmp	.-172    	; 0x130c <__fp_szero>
    13b8:	5f 3f       	cpi	r21, 0xFF	; 255
    13ba:	ec f3       	brlt	.-6      	; 0x13b6 <__mulsf3_pse+0x82>
    13bc:	98 3e       	cpi	r25, 0xE8	; 232
    13be:	dc f3       	brlt	.-10     	; 0x13b6 <__mulsf3_pse+0x82>
    13c0:	86 95       	lsr	r24
    13c2:	77 95       	ror	r23
    13c4:	67 95       	ror	r22
    13c6:	b7 95       	ror	r27
    13c8:	f7 95       	ror	r31
    13ca:	e7 95       	ror	r30
    13cc:	9f 5f       	subi	r25, 0xFF	; 255
    13ce:	c1 f7       	brne	.-16     	; 0x13c0 <__mulsf3_pse+0x8c>
    13d0:	fe 2b       	or	r31, r30
    13d2:	88 0f       	add	r24, r24
    13d4:	91 1d       	adc	r25, r1
    13d6:	96 95       	lsr	r25
    13d8:	87 95       	ror	r24
    13da:	97 f9       	bld	r25, 7
    13dc:	08 95       	ret

000013de <__udivmodhi4>:
    13de:	aa 1b       	sub	r26, r26
    13e0:	bb 1b       	sub	r27, r27
    13e2:	51 e1       	ldi	r21, 0x11	; 17
    13e4:	07 c0       	rjmp	.+14     	; 0x13f4 <__udivmodhi4_ep>

000013e6 <__udivmodhi4_loop>:
    13e6:	aa 1f       	adc	r26, r26
    13e8:	bb 1f       	adc	r27, r27
    13ea:	a6 17       	cp	r26, r22
    13ec:	b7 07       	cpc	r27, r23
    13ee:	10 f0       	brcs	.+4      	; 0x13f4 <__udivmodhi4_ep>
    13f0:	a6 1b       	sub	r26, r22
    13f2:	b7 0b       	sbc	r27, r23

000013f4 <__udivmodhi4_ep>:
    13f4:	88 1f       	adc	r24, r24
    13f6:	99 1f       	adc	r25, r25
    13f8:	5a 95       	dec	r21
    13fa:	a9 f7       	brne	.-22     	; 0x13e6 <__udivmodhi4_loop>
    13fc:	80 95       	com	r24
    13fe:	90 95       	com	r25
    1400:	bc 01       	movw	r22, r24
    1402:	cd 01       	movw	r24, r26
    1404:	08 95       	ret

00001406 <_exit>:
    1406:	f8 94       	cli

00001408 <__stop_program>:
    1408:	ff cf       	rjmp	.-2      	; 0x1408 <__stop_program>
