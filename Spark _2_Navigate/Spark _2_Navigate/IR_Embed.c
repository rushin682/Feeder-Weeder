#define F_CPU 7372800UL
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <math.h> //included to support power function

volatile unsigned long int pulse = 0;   // <---- volatile is important !!!
unsigned long int red;       // variable to store the red pulse count
unsigned long int blue;      // variable to store the blue pulse count
unsigned long int green;     // variable to store the green pulse count
//ADC pin configuration
/*void adc_pin_config (void)
{
	DDRA = 0x00;   //set PORTF direction as input
	PORTA = 0x00;  //set PORTF pins floating
}*/

//Function to Initialize ADC
/*void adc_init()
{
	ADCSRA = 0x00;
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
	ACSR = 0x80;
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
}
*/
//This Function accepts the Channel Number and returns the corresponding Analog Value
/*
unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	Ch = Ch & 0x07;
	ADMUX= 0x20| Ch;
	ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
	a=ADCH;
	ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
	return a;
}
*/

void color_sensor_pin_config(void)
{
	
	DDRD = DDRD |0xBF;
	PORTD = PORTD |0x40;            //Enable internal pull-up for PORTD 6 pin
	DDRC =  DDRC|0xF8;            //Initialise pins connected to S0, S1, S2, S3 as output
	PORTC = PORTC|0x00;            // Set pins as LOW initialially
	
}

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli();               //Clears the global interrupt
	TIMSK= TIMSK | 0x20; // Enable input capture pin of timer 1 for color sensor
	sei();               // Enables the global interrupt
}

ISR(TIMER1_CAPT_vect)
{
	pulse++; //increment on receiving pulse from the color sensor
}

void timer1_init2(void)
{
	TCNT1H = 0x00;
	TCNT1L = 0x00;
	OCR1AH = 0x00;
	OCR1AL = 0x00;
	OCR1BH = 0x00;
	OCR1BL = 0x00;
	TCCR1A = 0x00;
	TCCR1B = 0x01; //at clock frequency
	TIMSK = 0x20;
}
/////////////////////////////////////////////////////////////////////
//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTC = PORTC & 0xBF; //set S2 low
	PORTC = PORTC & 0x7F; //set S3 low
}

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTC= PORTC | 0x40; //set S2 High
	PORTC = PORTC | 0x80; //set S3 High
}

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTC = PORTC & 0xBF; //set S2 low
	PORTC = PORTC | 0x80; //set S3 High
}

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
 	PORTC = PORTC | 0x40; //set S2 High
	PORTC = PORTC & 0x7F; //set S3 Low
}

//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTC = PORTC | 0x10; //set S0 high
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTC = PORTC | 0x20; //set S1 high
}

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
}

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
}

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
}
/*int main(void)
{
    int temp;
	int distance;
	while(1)
    { 
		
		temp=colourDetect();
		distance=plantDetect();
		/*if(distance<10)
		{
			buzzer_on();
		}
		else
		{
			buzzer_off();	
		}
		if(temp == 0){ buzzer_on(); }
		else if(temp == 1){ buzzer_off(); }
		else if(temp == 2){ 
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			_delay_ms(1000);
		}
		
	}
}*/

void colourDetect()
{
	/*Blue-->0
	Red-->1
	Green-->2*/
	int colour;
	color_sensor_pin_interrupt_init();
	timer1_init2();
	color_sensor_pin_config();
	color_sensor_scaling();
	red_read(); //display the pulse count when red filter is selected
	green_read(); //display the pulse count when green filter is selected
	blue_read(); //display the pulse count when blue filter is selected
	if((blue>green)&&(blue>red))
	{
		colour=0;
		buzzer_on();
	}
	if((red>green)&&(red>blue))
	{
		colour=1;
		buzzer_off();
	}
	if((green>red)&&(green>blue))
	{
		colour=2;
		buzzer_on();
		_delay_ms(1000);
		buzzer_off();
		_delay_ms(1000);		
	}/*
	if(temp==0)
	{
		buzzer_on();
	}
	else if(temp==1)
	{
		buzzer_off();
	}
	else if(temp==2)
	{
		buzzer_on();
		_delay_ms(1000);
		buzzer_off();
		_delay_ms(1000);
	}*/
	//return colour;
}
int plantDetect()
{
	int val;
	float volts;
	adc_init();
	adc_pin_config();
	val=ADC_Conversion(2);
	volts=val*0.0196078431;
	int distance = 13*pow(volts, -1);
	if(distance<10)
		{
			return 1;
		}
	return 0; 
}
void buzzer_on (void)
{
	PORTC = PORTC | 0b00001000; 
}
void buzzer_off (void)
{
	PORTC = PORTC & 0b11110111;
}