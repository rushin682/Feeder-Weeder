
Spark_Navigate.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000013e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000018  00800060  000013e2  00001476  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000044  00800078  00800078  0000148e  2**0
                  ALLOC
  3 .stab         0000216c  00000000  00000000  00001490  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000006a8  00000000  00000000  000035fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000a0  00000000  00000000  00003ca8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001855  00000000  00000000  00003d48  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000429  00000000  00000000  0000559d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007cc  00000000  00000000  000059c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000600  00000000  00000000  00006194  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000686  00000000  00000000  00006794  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000dc3  00000000  00000000  00006e1a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 f2 02 	jmp	0x5e4	; 0x5e4 <__vector_1>
       8:	0c 94 17 03 	jmp	0x62e	; 0x62e <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ee       	ldi	r30, 0xE2	; 226
      68:	f3 e1       	ldi	r31, 0x13	; 19
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 37       	cpi	r26, 0x78	; 120
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	a8 e7       	ldi	r26, 0x78	; 120
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 3b       	cpi	r26, 0xBC	; 188
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 b0 07 	call	0xf60	; 0xf60 <main>
      8a:	0c 94 ef 09 	jmp	0x13de	; 0x13de <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <buzzer_on>:
		}
	return 0; 
}
void buzzer_on (void)
{
	PORTC = PORTC | 0b00001000; 
      92:	ab 9a       	sbi	0x15, 3	; 21
}
      94:	08 95       	ret

00000096 <buzzer_off>:
void buzzer_off (void)
{
	PORTC = PORTC & 0b11110111;
      96:	ab 98       	cbi	0x15, 3	; 21
      98:	08 95       	ret

0000009a <readSensor>:
	}
	stop(); //Stop robot
}

void readSensor()
{
      9a:	cf 93       	push	r28
      9c:	df 93       	push	r29
	highcurrent=0;
      9e:	10 92 79 00 	sts	0x0079, r1
      a2:	10 92 78 00 	sts	0x0078, r1
	highcount=0;
      a6:	10 92 7b 00 	sts	0x007B, r1
      aa:	10 92 7a 00 	sts	0x007A, r1
	sensor(0,th[0],avg[0]);
      ae:	c8 e7       	ldi	r28, 0x78	; 120
      b0:	d2 e0       	ldi	r29, 0x02	; 2
      b2:	60 91 80 00 	lds	r22, 0x0080
      b6:	70 91 81 00 	lds	r23, 0x0081
      ba:	40 91 71 00 	lds	r20, 0x0071
      be:	50 91 72 00 	lds	r21, 0x0072
      c2:	80 e0       	ldi	r24, 0x00	; 0
      c4:	90 e0       	ldi	r25, 0x00	; 0
      c6:	fe 01       	movw	r30, r28
      c8:	09 95       	icall
	sensor(1,th[1],avg[1]);
      ca:	60 91 82 00 	lds	r22, 0x0082
      ce:	70 91 83 00 	lds	r23, 0x0083
      d2:	40 91 73 00 	lds	r20, 0x0073
      d6:	50 91 74 00 	lds	r21, 0x0074
      da:	81 e0       	ldi	r24, 0x01	; 1
      dc:	90 e0       	ldi	r25, 0x00	; 0
      de:	fe 01       	movw	r30, r28
      e0:	09 95       	icall
	sensor(2,th[2],avg[2]);
      e2:	60 91 84 00 	lds	r22, 0x0084
      e6:	70 91 85 00 	lds	r23, 0x0085
      ea:	40 91 75 00 	lds	r20, 0x0075
      ee:	50 91 76 00 	lds	r21, 0x0076
      f2:	82 e0       	ldi	r24, 0x02	; 2
      f4:	90 e0       	ldi	r25, 0x00	; 0
      f6:	fe 01       	movw	r30, r28
      f8:	09 95       	icall
}
      fa:	df 91       	pop	r29
      fc:	cf 91       	pop	r28
      fe:	08 95       	ret

00000100 <proportional>:
		th[n]=0;
	}
	lcd_print(1, 3-n, th[n], 1);
}
void proportional()
{
     100:	cf 92       	push	r12
     102:	df 92       	push	r13
     104:	ef 92       	push	r14
     106:	ff 92       	push	r15
	error = ((double)highcurrent/highcount)-target;
     108:	60 91 78 00 	lds	r22, 0x0078
     10c:	70 91 79 00 	lds	r23, 0x0079
     110:	88 27       	eor	r24, r24
     112:	77 fd       	sbrc	r23, 7
     114:	80 95       	com	r24
     116:	98 2f       	mov	r25, r24
     118:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <__floatsisf>
     11c:	6b 01       	movw	r12, r22
     11e:	7c 01       	movw	r14, r24
     120:	60 91 7a 00 	lds	r22, 0x007A
     124:	70 91 7b 00 	lds	r23, 0x007B
     128:	88 27       	eor	r24, r24
     12a:	77 fd       	sbrc	r23, 7
     12c:	80 95       	com	r24
     12e:	98 2f       	mov	r25, r24
     130:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <__floatsisf>
     134:	9b 01       	movw	r18, r22
     136:	ac 01       	movw	r20, r24
     138:	c7 01       	movw	r24, r14
     13a:	b6 01       	movw	r22, r12
     13c:	0e 94 51 08 	call	0x10a2	; 0x10a2 <__divsf3>
     140:	6b 01       	movw	r12, r22
     142:	7c 01       	movw	r14, r24
     144:	60 91 6f 00 	lds	r22, 0x006F
     148:	70 91 70 00 	lds	r23, 0x0070
     14c:	88 27       	eor	r24, r24
     14e:	77 fd       	sbrc	r23, 7
     150:	80 95       	com	r24
     152:	98 2f       	mov	r25, r24
     154:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <__floatsisf>
     158:	9b 01       	movw	r18, r22
     15a:	ac 01       	movw	r20, r24
     15c:	c7 01       	movw	r24, r14
     15e:	b6 01       	movw	r22, r12
     160:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <__subsf3>
     164:	0e 94 b9 08 	call	0x1172	; 0x1172 <__fixsfsi>
     168:	ab 01       	movw	r20, r22
     16a:	bc 01       	movw	r22, r24
     16c:	ca 01       	movw	r24, r20
     16e:	50 93 7f 00 	sts	0x007F, r21
     172:	40 93 7e 00 	sts	0x007E, r20
	p=(kp*error);
     176:	40 91 6d 00 	lds	r20, 0x006D
     17a:	50 91 6e 00 	lds	r21, 0x006E
     17e:	84 9f       	mul	r24, r20
     180:	90 01       	movw	r18, r0
     182:	85 9f       	mul	r24, r21
     184:	30 0d       	add	r19, r0
     186:	94 9f       	mul	r25, r20
     188:	30 0d       	add	r19, r0
     18a:	11 24       	eor	r1, r1
     18c:	30 93 7d 00 	sts	0x007D, r19
     190:	20 93 7c 00 	sts	0x007C, r18
	if(th[0]==0 && th[1]==0 && th[2]==0)
     194:	80 91 80 00 	lds	r24, 0x0080
     198:	90 91 81 00 	lds	r25, 0x0081
     19c:	00 97       	sbiw	r24, 0x00	; 0
     19e:	81 f4       	brne	.+32     	; 0x1c0 <proportional+0xc0>
     1a0:	80 91 82 00 	lds	r24, 0x0082
     1a4:	90 91 83 00 	lds	r25, 0x0083
     1a8:	00 97       	sbiw	r24, 0x00	; 0
     1aa:	51 f4       	brne	.+20     	; 0x1c0 <proportional+0xc0>
     1ac:	80 91 84 00 	lds	r24, 0x0084
     1b0:	90 91 85 00 	lds	r25, 0x0085
     1b4:	00 97       	sbiw	r24, 0x00	; 0
     1b6:	21 f4       	brne	.+8      	; 0x1c0 <proportional+0xc0>
	{
		p=0;
     1b8:	10 92 7d 00 	sts	0x007D, r1
     1bc:	10 92 7c 00 	sts	0x007C, r1
	}
}
     1c0:	ff 90       	pop	r15
     1c2:	ef 90       	pop	r14
     1c4:	df 90       	pop	r13
     1c6:	cf 90       	pop	r12
     1c8:	08 95       	ret

000001ca <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     1ca:	95 b3       	in	r25, 0x15	; 21
     1cc:	9f 70       	andi	r25, 0x0F	; 15
     1ce:	95 bb       	out	0x15, r25	; 21
	lcd_port |= temp;
     1d0:	95 b3       	in	r25, 0x15	; 21
/*****Function to Write Command on LCD*****/
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     1d2:	28 2f       	mov	r18, r24
     1d4:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     1d6:	92 2b       	or	r25, r18
     1d8:	95 bb       	out	0x15, r25	; 21
	cbit(lcd_port,RS);
     1da:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);
     1dc:	a9 98       	cbi	0x15, 1	; 21
	sbit(lcd_port,EN);
     1de:	aa 9a       	sbi	0x15, 2	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1e0:	ef ef       	ldi	r30, 0xFF	; 255
     1e2:	f3 e2       	ldi	r31, 0x23	; 35
     1e4:	31 97       	sbiw	r30, 0x01	; 1
     1e6:	f1 f7       	brne	.-4      	; 0x1e4 <lcd_wr_command+0x1a>
     1e8:	00 c0       	rjmp	.+0      	; 0x1ea <lcd_wr_command+0x20>
     1ea:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     1ec:	aa 98       	cbi	0x15, 2	; 21
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     1ee:	95 b3       	in	r25, 0x15	; 21
     1f0:	9f 70       	andi	r25, 0x0F	; 15
     1f2:	95 bb       	out	0x15, r25	; 21
	lcd_port |= cmd;
     1f4:	95 b3       	in	r25, 0x15	; 21
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     1f6:	82 95       	swap	r24
     1f8:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     1fa:	89 2b       	or	r24, r25
     1fc:	85 bb       	out	0x15, r24	; 21
	cbit(lcd_port,RS);
     1fe:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);
     200:	a9 98       	cbi	0x15, 1	; 21
	sbit(lcd_port,EN);
     202:	aa 9a       	sbi	0x15, 2	; 21
     204:	8f ef       	ldi	r24, 0xFF	; 255
     206:	93 e2       	ldi	r25, 0x23	; 35
     208:	01 97       	sbiw	r24, 0x01	; 1
     20a:	f1 f7       	brne	.-4      	; 0x208 <lcd_wr_command+0x3e>
     20c:	00 c0       	rjmp	.+0      	; 0x20e <lcd_wr_command+0x44>
     20e:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     210:	aa 98       	cbi	0x15, 2	; 21
}
     212:	08 95       	ret

00000214 <lcd_set_4bit>:
     214:	83 e3       	ldi	r24, 0x33	; 51
     216:	97 e0       	ldi	r25, 0x07	; 7
     218:	01 97       	sbiw	r24, 0x01	; 1
     21a:	f1 f7       	brne	.-4      	; 0x218 <lcd_set_4bit+0x4>
/*****Function to Reset LCD*****/
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     21c:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     21e:	a9 98       	cbi	0x15, 1	; 21
	lcd_port = 0x30;				//Sending 3
     220:	80 e3       	ldi	r24, 0x30	; 48
     222:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,EN);				//Set Enable Pin
     224:	aa 9a       	sbi	0x15, 2	; 21
     226:	ef ef       	ldi	r30, 0xFF	; 255
     228:	f3 e2       	ldi	r31, 0x23	; 35
     22a:	31 97       	sbiw	r30, 0x01	; 1
     22c:	f1 f7       	brne	.-4      	; 0x22a <lcd_set_4bit+0x16>
     22e:	00 c0       	rjmp	.+0      	; 0x230 <lcd_set_4bit+0x1c>
     230:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     232:	aa 98       	cbi	0x15, 2	; 21
     234:	e3 e3       	ldi	r30, 0x33	; 51
     236:	f7 e0       	ldi	r31, 0x07	; 7
     238:	31 97       	sbiw	r30, 0x01	; 1
     23a:	f1 f7       	brne	.-4      	; 0x238 <lcd_set_4bit+0x24>

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     23c:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     23e:	a9 98       	cbi	0x15, 1	; 21
	lcd_port = 0x30;				//Sending 3
     240:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,EN);				//Set Enable Pin
     242:	aa 9a       	sbi	0x15, 2	; 21
     244:	ef ef       	ldi	r30, 0xFF	; 255
     246:	f3 e2       	ldi	r31, 0x23	; 35
     248:	31 97       	sbiw	r30, 0x01	; 1
     24a:	f1 f7       	brne	.-4      	; 0x248 <lcd_set_4bit+0x34>
     24c:	00 c0       	rjmp	.+0      	; 0x24e <lcd_set_4bit+0x3a>
     24e:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     250:	aa 98       	cbi	0x15, 2	; 21
     252:	e3 e3       	ldi	r30, 0x33	; 51
     254:	f7 e0       	ldi	r31, 0x07	; 7
     256:	31 97       	sbiw	r30, 0x01	; 1
     258:	f1 f7       	brne	.-4      	; 0x256 <lcd_set_4bit+0x42>

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     25a:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     25c:	a9 98       	cbi	0x15, 1	; 21
	lcd_port = 0x30;				//Sending 3
     25e:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,EN);				//Set Enable Pin
     260:	aa 9a       	sbi	0x15, 2	; 21
     262:	8f ef       	ldi	r24, 0xFF	; 255
     264:	93 e2       	ldi	r25, 0x23	; 35
     266:	01 97       	sbiw	r24, 0x01	; 1
     268:	f1 f7       	brne	.-4      	; 0x266 <lcd_set_4bit+0x52>
     26a:	00 c0       	rjmp	.+0      	; 0x26c <lcd_set_4bit+0x58>
     26c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     26e:	aa 98       	cbi	0x15, 2	; 21
     270:	e3 e3       	ldi	r30, 0x33	; 51
     272:	f7 e0       	ldi	r31, 0x07	; 7
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	f1 f7       	brne	.-4      	; 0x274 <lcd_set_4bit+0x60>

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     278:	a8 98       	cbi	0x15, 0	; 21
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     27a:	a9 98       	cbi	0x15, 1	; 21
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     27c:	80 e2       	ldi	r24, 0x20	; 32
     27e:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,EN);				//Set Enable Pin
     280:	aa 9a       	sbi	0x15, 2	; 21
     282:	8f ef       	ldi	r24, 0xFF	; 255
     284:	93 e2       	ldi	r25, 0x23	; 35
     286:	01 97       	sbiw	r24, 0x01	; 1
     288:	f1 f7       	brne	.-4      	; 0x286 <lcd_set_4bit+0x72>
     28a:	00 c0       	rjmp	.+0      	; 0x28c <lcd_set_4bit+0x78>
     28c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     28e:	aa 98       	cbi	0x15, 2	; 21

	
}
     290:	08 95       	ret

00000292 <lcd_init>:

/*****Function to Initialize LCD*****/
void lcd_init()
{
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	83 e3       	ldi	r24, 0x33	; 51
     298:	97 e0       	ldi	r25, 0x07	; 7
     29a:	01 97       	sbiw	r24, 0x01	; 1
     29c:	f1 f7       	brne	.-4      	; 0x29a <lcd_init+0x8>
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     29e:	c5 ee       	ldi	r28, 0xE5	; 229
     2a0:	d0 e0       	ldi	r29, 0x00	; 0
     2a2:	88 e2       	ldi	r24, 0x28	; 40
     2a4:	90 e0       	ldi	r25, 0x00	; 0
     2a6:	fe 01       	movw	r30, r28
     2a8:	09 95       	icall
	lcd_wr_command(0x01);
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	90 e0       	ldi	r25, 0x00	; 0
     2ae:	fe 01       	movw	r30, r28
     2b0:	09 95       	icall
	lcd_wr_command(0x06);
     2b2:	86 e0       	ldi	r24, 0x06	; 6
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	fe 01       	movw	r30, r28
     2b8:	09 95       	icall
	lcd_wr_command(0x0E);
     2ba:	8e e0       	ldi	r24, 0x0E	; 14
     2bc:	90 e0       	ldi	r25, 0x00	; 0
     2be:	fe 01       	movw	r30, r28
     2c0:	09 95       	icall
	lcd_wr_command(0x80);
     2c2:	80 e8       	ldi	r24, 0x80	; 128
     2c4:	90 e0       	ldi	r25, 0x00	; 0
     2c6:	fe 01       	movw	r30, r28
     2c8:	09 95       	icall
		
}
     2ca:	df 91       	pop	r29
     2cc:	cf 91       	pop	r28
     2ce:	08 95       	ret

000002d0 <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     2d0:	95 b3       	in	r25, 0x15	; 21
     2d2:	9f 70       	andi	r25, 0x0F	; 15
     2d4:	95 bb       	out	0x15, r25	; 21
	lcd_port |= temp;
     2d6:	95 b3       	in	r25, 0x15	; 21
/*****Function to Write Data on LCD*****/
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     2d8:	28 2f       	mov	r18, r24
     2da:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     2dc:	92 2b       	or	r25, r18
     2de:	95 bb       	out	0x15, r25	; 21
	sbit(lcd_port,RS);
     2e0:	a8 9a       	sbi	0x15, 0	; 21
	cbit(lcd_port,RW);
     2e2:	a9 98       	cbi	0x15, 1	; 21
	sbit(lcd_port,EN);
     2e4:	aa 9a       	sbi	0x15, 2	; 21
     2e6:	ef ef       	ldi	r30, 0xFF	; 255
     2e8:	f3 e2       	ldi	r31, 0x23	; 35
     2ea:	31 97       	sbiw	r30, 0x01	; 1
     2ec:	f1 f7       	brne	.-4      	; 0x2ea <lcd_wr_char+0x1a>
     2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <lcd_wr_char+0x20>
     2f0:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2f2:	aa 98       	cbi	0x15, 2	; 21

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     2f4:	95 b3       	in	r25, 0x15	; 21
     2f6:	9f 70       	andi	r25, 0x0F	; 15
     2f8:	95 bb       	out	0x15, r25	; 21
	lcd_port |= letter;
     2fa:	95 b3       	in	r25, 0x15	; 21
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     2fc:	82 95       	swap	r24
     2fe:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     300:	89 2b       	or	r24, r25
     302:	85 bb       	out	0x15, r24	; 21
	sbit(lcd_port,RS);
     304:	a8 9a       	sbi	0x15, 0	; 21
	cbit(lcd_port,RW);
     306:	a9 98       	cbi	0x15, 1	; 21
	sbit(lcd_port,EN);
     308:	aa 9a       	sbi	0x15, 2	; 21
     30a:	8f ef       	ldi	r24, 0xFF	; 255
     30c:	93 e2       	ldi	r25, 0x23	; 35
     30e:	01 97       	sbiw	r24, 0x01	; 1
     310:	f1 f7       	brne	.-4      	; 0x30e <lcd_wr_char+0x3e>
     312:	00 c0       	rjmp	.+0      	; 0x314 <lcd_wr_char+0x44>
     314:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     316:	aa 98       	cbi	0x15, 2	; 21
}
     318:	08 95       	ret

0000031a <lcd_home>:


void lcd_home()
{
	lcd_wr_command(0x80);
     31a:	80 e8       	ldi	r24, 0x80	; 128
     31c:	0e 94 e5 00 	call	0x1ca	; 0x1ca <lcd_wr_command>
}
     320:	08 95       	ret

00000322 <lcd_string>:


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
     322:	cf 93       	push	r28
     324:	df 93       	push	r29
     326:	ec 01       	movw	r28, r24
	while(*str != '\0')
     328:	88 81       	ld	r24, Y
     32a:	88 23       	and	r24, r24
     32c:	31 f0       	breq	.+12     	; 0x33a <lcd_string+0x18>
	lcd_wr_command(0x80);
}


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
     32e:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     330:	0e 94 68 01 	call	0x2d0	; 0x2d0 <lcd_wr_char>


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
	while(*str != '\0')
     334:	89 91       	ld	r24, Y+
     336:	88 23       	and	r24, r24
     338:	d9 f7       	brne	.-10     	; 0x330 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     33a:	df 91       	pop	r29
     33c:	cf 91       	pop	r28
     33e:	08 95       	ret

00000340 <lcd_cursor>:

/*** Position the LCD cursor at "row", "column". ***/

void lcd_cursor (char row, char column)
{
	switch (row) {
     340:	82 30       	cpi	r24, 0x02	; 2
     342:	79 f0       	breq	.+30     	; 0x362 <lcd_cursor+0x22>
     344:	83 30       	cpi	r24, 0x03	; 3
     346:	18 f4       	brcc	.+6      	; 0x34e <lcd_cursor+0xe>
     348:	81 30       	cpi	r24, 0x01	; 1
     34a:	c9 f4       	brne	.+50     	; 0x37e <lcd_cursor+0x3e>
     34c:	05 c0       	rjmp	.+10     	; 0x358 <lcd_cursor+0x18>
     34e:	83 30       	cpi	r24, 0x03	; 3
     350:	69 f0       	breq	.+26     	; 0x36c <lcd_cursor+0x2c>
     352:	84 30       	cpi	r24, 0x04	; 4
     354:	a1 f4       	brne	.+40     	; 0x37e <lcd_cursor+0x3e>
     356:	0f c0       	rjmp	.+30     	; 0x376 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     358:	86 2f       	mov	r24, r22
     35a:	81 58       	subi	r24, 0x81	; 129
     35c:	0e 94 e5 00 	call	0x1ca	; 0x1ca <lcd_wr_command>
     360:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     362:	86 2f       	mov	r24, r22
     364:	81 54       	subi	r24, 0x41	; 65
     366:	0e 94 e5 00 	call	0x1ca	; 0x1ca <lcd_wr_command>
     36a:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     36c:	86 2f       	mov	r24, r22
     36e:	8d 56       	subi	r24, 0x6D	; 109
     370:	0e 94 e5 00 	call	0x1ca	; 0x1ca <lcd_wr_command>
     374:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     376:	86 2f       	mov	r24, r22
     378:	8d 52       	subi	r24, 0x2D	; 45
     37a:	0e 94 e5 00 	call	0x1ca	; 0x1ca <lcd_wr_command>
     37e:	08 95       	ret

00000380 <lcd_print>:
	}
}

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     380:	0f 93       	push	r16
     382:	1f 93       	push	r17
     384:	cf 93       	push	r28
     386:	df 93       	push	r29
     388:	8a 01       	movw	r16, r20
     38a:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     38c:	88 23       	and	r24, r24
     38e:	11 f0       	breq	.+4      	; 0x394 <lcd_print+0x14>
     390:	66 23       	and	r22, r22
     392:	19 f4       	brne	.+6      	; 0x39a <lcd_print+0x1a>
	{
		lcd_home();
     394:	0e 94 8d 01 	call	0x31a	; 0x31a <lcd_home>
     398:	02 c0       	rjmp	.+4      	; 0x39e <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     39a:	0e 94 a0 01 	call	0x340	; 0x340 <lcd_cursor>
	}
	if(digits==5 || flag==1)
     39e:	c5 30       	cpi	r28, 0x05	; 5
     3a0:	d1 05       	cpc	r29, r1
     3a2:	71 f4       	brne	.+28     	; 0x3c0 <lcd_print+0x40>
	{
		million=value/10000+48;
     3a4:	c8 01       	movw	r24, r16
     3a6:	60 e1       	ldi	r22, 0x10	; 16
     3a8:	77 e2       	ldi	r23, 0x27	; 39
     3aa:	0e 94 db 09 	call	0x13b6	; 0x13b6 <__udivmodhi4>
     3ae:	cb 01       	movw	r24, r22
     3b0:	c0 96       	adiw	r24, 0x30	; 48
     3b2:	90 93 a5 00 	sts	0x00A5, r25
     3b6:	80 93 a4 00 	sts	0x00A4, r24
		lcd_wr_char(million);
     3ba:	0e 94 68 01 	call	0x2d0	; 0x2d0 <lcd_wr_char>
     3be:	03 c0       	rjmp	.+6      	; 0x3c6 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     3c0:	c4 30       	cpi	r28, 0x04	; 4
     3c2:	d1 05       	cpc	r29, r1
     3c4:	b9 f4       	brne	.+46     	; 0x3f4 <lcd_print+0x74>
	{
		temp = value/1000;
     3c6:	c8 01       	movw	r24, r16
     3c8:	68 ee       	ldi	r22, 0xE8	; 232
     3ca:	73 e0       	ldi	r23, 0x03	; 3
     3cc:	0e 94 db 09 	call	0x13b6	; 0x13b6 <__udivmodhi4>
     3d0:	cb 01       	movw	r24, r22
     3d2:	70 93 a7 00 	sts	0x00A7, r23
     3d6:	60 93 a6 00 	sts	0x00A6, r22
		thousand = temp%10 + 48;
     3da:	6a e0       	ldi	r22, 0x0A	; 10
     3dc:	70 e0       	ldi	r23, 0x00	; 0
     3de:	0e 94 db 09 	call	0x13b6	; 0x13b6 <__udivmodhi4>
     3e2:	c0 96       	adiw	r24, 0x30	; 48
     3e4:	90 93 bb 00 	sts	0x00BB, r25
     3e8:	80 93 ba 00 	sts	0x00BA, r24
		lcd_wr_char(thousand);
     3ec:	0e 94 68 01 	call	0x2d0	; 0x2d0 <lcd_wr_char>
		flag=1;
     3f0:	81 e0       	ldi	r24, 0x01	; 1
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <lcd_print+0x76>
}

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     3f4:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     3f6:	c3 30       	cpi	r28, 0x03	; 3
     3f8:	d1 05       	cpc	r29, r1
     3fa:	11 f0       	breq	.+4      	; 0x400 <lcd_print+0x80>
     3fc:	81 30       	cpi	r24, 0x01	; 1
     3fe:	b1 f4       	brne	.+44     	; 0x42c <lcd_print+0xac>
	{
		temp = value/100;
     400:	c8 01       	movw	r24, r16
     402:	64 e6       	ldi	r22, 0x64	; 100
     404:	70 e0       	ldi	r23, 0x00	; 0
     406:	0e 94 db 09 	call	0x13b6	; 0x13b6 <__udivmodhi4>
     40a:	cb 01       	movw	r24, r22
     40c:	70 93 a7 00 	sts	0x00A7, r23
     410:	60 93 a6 00 	sts	0x00A6, r22
		hundred = temp%10 + 48;
     414:	6a e0       	ldi	r22, 0x0A	; 10
     416:	70 e0       	ldi	r23, 0x00	; 0
     418:	0e 94 db 09 	call	0x13b6	; 0x13b6 <__udivmodhi4>
     41c:	c0 96       	adiw	r24, 0x30	; 48
     41e:	90 93 b7 00 	sts	0x00B7, r25
     422:	80 93 b6 00 	sts	0x00B6, r24
		lcd_wr_char(hundred);
     426:	0e 94 68 01 	call	0x2d0	; 0x2d0 <lcd_wr_char>
		flag=1;
     42a:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     42c:	c2 30       	cpi	r28, 0x02	; 2
     42e:	d1 05       	cpc	r29, r1
     430:	11 f0       	breq	.+4      	; 0x436 <lcd_print+0xb6>
     432:	81 30       	cpi	r24, 0x01	; 1
     434:	b1 f4       	brne	.+44     	; 0x462 <__stack+0x3>
	{
		temp = value/10;
     436:	2a e0       	ldi	r18, 0x0A	; 10
     438:	30 e0       	ldi	r19, 0x00	; 0
     43a:	c8 01       	movw	r24, r16
     43c:	b9 01       	movw	r22, r18
     43e:	0e 94 db 09 	call	0x13b6	; 0x13b6 <__udivmodhi4>
     442:	cb 01       	movw	r24, r22
     444:	70 93 a7 00 	sts	0x00A7, r23
     448:	60 93 a6 00 	sts	0x00A6, r22
		tens = temp%10 + 48;
     44c:	b9 01       	movw	r22, r18
     44e:	0e 94 db 09 	call	0x13b6	; 0x13b6 <__udivmodhi4>
     452:	c0 96       	adiw	r24, 0x30	; 48
     454:	90 93 b5 00 	sts	0x00B5, r25
     458:	80 93 b4 00 	sts	0x00B4, r24
		lcd_wr_char(tens);
     45c:	0e 94 68 01 	call	0x2d0	; 0x2d0 <lcd_wr_char>
		flag=1;
     460:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     462:	c1 30       	cpi	r28, 0x01	; 1
     464:	d1 05       	cpc	r29, r1
     466:	11 f0       	breq	.+4      	; 0x46c <__stack+0xd>
     468:	81 30       	cpi	r24, 0x01	; 1
     46a:	61 f4       	brne	.+24     	; 0x484 <__stack+0x25>
	{
		unit = value%10 + 48;
     46c:	c8 01       	movw	r24, r16
     46e:	6a e0       	ldi	r22, 0x0A	; 10
     470:	70 e0       	ldi	r23, 0x00	; 0
     472:	0e 94 db 09 	call	0x13b6	; 0x13b6 <__udivmodhi4>
     476:	c0 96       	adiw	r24, 0x30	; 48
     478:	90 93 b9 00 	sts	0x00B9, r25
     47c:	80 93 b8 00 	sts	0x00B8, r24
		lcd_wr_char(unit);
     480:	0e 94 68 01 	call	0x2d0	; 0x2d0 <lcd_wr_char>
	}
	if(digits>5)
     484:	c6 30       	cpi	r28, 0x06	; 6
     486:	d1 05       	cpc	r29, r1
     488:	1c f0       	brlt	.+6      	; 0x490 <__stack+0x31>
	{
		lcd_wr_char('E');
     48a:	85 e4       	ldi	r24, 0x45	; 69
     48c:	0e 94 68 01 	call	0x2d0	; 0x2d0 <lcd_wr_char>
	}
	
}
     490:	df 91       	pop	r29
     492:	cf 91       	pop	r28
     494:	1f 91       	pop	r17
     496:	0f 91       	pop	r16
     498:	08 95       	ret

0000049a <lcd_port_config>:
unsigned char Right_white_line = 0;

//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     49a:	84 b3       	in	r24, 0x14	; 20
     49c:	87 6f       	ori	r24, 0xF7	; 247
     49e:	84 bb       	out	0x14, r24	; 20
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     4a0:	85 b3       	in	r24, 0x15	; 21
     4a2:	80 78       	andi	r24, 0x80	; 128
     4a4:	85 bb       	out	0x15, r24	; 21
}
     4a6:	08 95       	ret

000004a8 <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
 DDRA = 0x00;   //set PORTF direction as input
     4a8:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00;  //set PORTF pins floating
     4aa:	1b ba       	out	0x1b, r1	; 27
}
     4ac:	08 95       	ret

000004ae <timer1_init>:
// WGM: 5) PWM 8bit fast, TOP=0x00FF
// desired value: 450Hz
// actual value: 450.000Hz (0.0%)
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     4ae:	1e bc       	out	0x2e, r1	; 46
 TCNT1H = 0xFF; //setup
     4b0:	8f ef       	ldi	r24, 0xFF	; 255
     4b2:	8d bd       	out	0x2d, r24	; 45
 TCNT1L = 0x01;
     4b4:	91 e0       	ldi	r25, 0x01	; 1
     4b6:	9c bd       	out	0x2c, r25	; 44
 OCR1AH = 0x00;
     4b8:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = 0xFF;
     4ba:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     4bc:	19 bc       	out	0x29, r1	; 41
 OCR1BL = 0xFF;
     4be:	88 bd       	out	0x28, r24	; 40
 ICR1H  = 0x00;
     4c0:	17 bc       	out	0x27, r1	; 39
 ICR1L  = 0xFF;
     4c2:	86 bd       	out	0x26, r24	; 38
 TCCR1A = 0xA1;
     4c4:	81 ea       	ldi	r24, 0xA1	; 161
     4c6:	8f bd       	out	0x2f, r24	; 47
 TCCR1B = 0x0D; //start Timer
     4c8:	8d e0       	ldi	r24, 0x0D	; 13
     4ca:	8e bd       	out	0x2e, r24	; 46
}
     4cc:	08 95       	ret

000004ce <adc_init>:


//Function to Initialize ADC
void adc_init()
{
 ADCSRA = 0x00;
     4ce:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     4d0:	80 e2       	ldi	r24, 0x20	; 32
     4d2:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     4d4:	80 e8       	ldi	r24, 0x80	; 128
     4d6:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     4d8:	86 e8       	ldi	r24, 0x86	; 134
     4da:	86 b9       	out	0x06, r24	; 6
}
     4dc:	08 95       	ret

000004de <ADC_Conversion>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     4de:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     4e0:	80 62       	ori	r24, 0x20	; 32
     4e2:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
     4e4:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     4e6:	34 9b       	sbis	0x06, 4	; 6
     4e8:	fe cf       	rjmp	.-4      	; 0x4e6 <ADC_Conversion+0x8>
 a=ADCH;
     4ea:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     4ec:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     4ee:	08 95       	ret

000004f0 <sensor>:
	sensor(0,th[0],avg[0]);
	sensor(1,th[1],avg[1]);
	sensor(2,th[2],avg[2]);
}
void sensor(int n,int sn,int avgn)
{
     4f0:	ef 92       	push	r14
     4f2:	ff 92       	push	r15
     4f4:	1f 93       	push	r17
     4f6:	cf 93       	push	r28
     4f8:	df 93       	push	r29
     4fa:	7c 01       	movw	r14, r24
     4fc:	ea 01       	movw	r28, r20
	sn=ADC_Conversion(n+3);
     4fe:	18 2f       	mov	r17, r24
     500:	8d 5f       	subi	r24, 0xFD	; 253
     502:	0e 94 6f 02 	call	0x4de	; 0x4de <ADC_Conversion>
     506:	90 e0       	ldi	r25, 0x00	; 0
	if(sn>=avgn)
     508:	8c 17       	cp	r24, r28
     50a:	9d 07       	cpc	r25, r29
     50c:	fc f0       	brlt	.+62     	; 0x54c <sensor+0x5c>
	{
		th[n]=1;
     50e:	f7 01       	movw	r30, r14
     510:	ee 0f       	add	r30, r30
     512:	ff 1f       	adc	r31, r31
     514:	e0 58       	subi	r30, 0x80	; 128
     516:	ff 4f       	sbci	r31, 0xFF	; 255
     518:	81 e0       	ldi	r24, 0x01	; 1
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	91 83       	std	Z+1, r25	; 0x01
     51e:	80 83       	st	Z, r24
		highcount++;
     520:	80 91 7a 00 	lds	r24, 0x007A
     524:	90 91 7b 00 	lds	r25, 0x007B
     528:	01 96       	adiw	r24, 0x01	; 1
     52a:	90 93 7b 00 	sts	0x007B, r25
     52e:	80 93 7a 00 	sts	0x007A, r24
		highcurrent+=(n+1);
     532:	c7 01       	movw	r24, r14
     534:	01 96       	adiw	r24, 0x01	; 1
     536:	20 91 78 00 	lds	r18, 0x0078
     53a:	30 91 79 00 	lds	r19, 0x0079
     53e:	82 0f       	add	r24, r18
     540:	93 1f       	adc	r25, r19
     542:	90 93 79 00 	sts	0x0079, r25
     546:	80 93 78 00 	sts	0x0078, r24
     54a:	07 c0       	rjmp	.+14     	; 0x55a <sensor+0x6a>
	}
	else if(sn<avgn)
	{
		th[n]=0;
     54c:	f7 01       	movw	r30, r14
     54e:	ee 0f       	add	r30, r30
     550:	ff 1f       	adc	r31, r31
     552:	e0 58       	subi	r30, 0x80	; 128
     554:	ff 4f       	sbci	r31, 0xFF	; 255
     556:	11 82       	std	Z+1, r1	; 0x01
     558:	10 82       	st	Z, r1
	}
	lcd_print(1, 3-n, th[n], 1);
     55a:	63 e0       	ldi	r22, 0x03	; 3
     55c:	61 1b       	sub	r22, r17
     55e:	f7 01       	movw	r30, r14
     560:	ee 0f       	add	r30, r30
     562:	ff 1f       	adc	r31, r31
     564:	e0 58       	subi	r30, 0x80	; 128
     566:	ff 4f       	sbci	r31, 0xFF	; 255
     568:	40 81       	ld	r20, Z
     56a:	51 81       	ldd	r21, Z+1	; 0x01
     56c:	81 e0       	ldi	r24, 0x01	; 1
     56e:	21 e0       	ldi	r18, 0x01	; 1
     570:	30 e0       	ldi	r19, 0x00	; 0
     572:	0e 94 c0 01 	call	0x380	; 0x380 <lcd_print>
}
     576:	df 91       	pop	r29
     578:	cf 91       	pop	r28
     57a:	1f 91       	pop	r17
     57c:	ff 90       	pop	r15
     57e:	ef 90       	pop	r14
     580:	08 95       	ret

00000582 <print_sensor>:

// This Function prints the Analog Value Of Corresponding Channel No. at required Row
// and Coloumn Location. 
void print_sensor(char row, char coloumn,unsigned char channel)
{
     582:	cf 93       	push	r28
     584:	df 93       	push	r29
     586:	d8 2f       	mov	r29, r24
     588:	c6 2f       	mov	r28, r22
     58a:	84 2f       	mov	r24, r20
 ADC_Value = ADC_Conversion(channel);
     58c:	0e 94 6f 02 	call	0x4de	; 0x4de <ADC_Conversion>
     590:	48 2f       	mov	r20, r24
     592:	80 93 b0 00 	sts	0x00B0, r24
 lcd_print(row, coloumn, ADC_Value, 3);
     596:	8d 2f       	mov	r24, r29
     598:	6c 2f       	mov	r22, r28
     59a:	50 e0       	ldi	r21, 0x00	; 0
     59c:	23 e0       	ldi	r18, 0x03	; 3
     59e:	30 e0       	ldi	r19, 0x00	; 0
     5a0:	0e 94 c0 01 	call	0x380	; 0x380 <lcd_print>
}
     5a4:	df 91       	pop	r29
     5a6:	cf 91       	pop	r28
     5a8:	08 95       	ret

000005aa <velocity>:
}*/

//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
 OCR1AH = 0x00;
     5aa:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = left_motor; 
     5ac:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     5ae:	19 bc       	out	0x29, r1	; 41
 OCR1BL = right_motor;
     5b0:	68 bd       	out	0x28, r22	; 40
}
     5b2:	08 95       	ret

000005b4 <left_encoder_pin_config>:
}
*/
//Function to configure INT1 (PORTD 3) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xF7;  //Set the direction of the PORTD 3 pin as input
     5b4:	8b 98       	cbi	0x11, 3	; 17
 PORTD = PORTD | 0x08; //Enable internal pull-up for PORTD 3 pin
     5b6:	93 9a       	sbi	0x12, 3	; 18
}
     5b8:	08 95       	ret

000005ba <right_encoder_pin_config>:

//Function to configure INT0 (PORTD 2) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xFB;  //Set the direction of the PORTD 2 pin as input
     5ba:	8a 98       	cbi	0x11, 2	; 17
 PORTD = PORTD | 0x04; //Enable internal pull-up for PORTD 2 pin
     5bc:	92 9a       	sbi	0x12, 2	; 18
}
     5be:	08 95       	ret

000005c0 <left_position_encoder_interrupt_init>:
 right_encoder_pin_config();   //right encoder pin config	
}*/

void left_position_encoder_interrupt_init (void) //Interrupt 1 enable
{
 cli(); //Clears the global interrupt
     5c0:	f8 94       	cli
 MCUCR = MCUCR | 0x08; // INT1 is set to trigger with falling edge
     5c2:	85 b7       	in	r24, 0x35	; 53
     5c4:	88 60       	ori	r24, 0x08	; 8
     5c6:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x80;   // Enable Interrupt INT1 for left position encoder
     5c8:	8b b7       	in	r24, 0x3b	; 59
     5ca:	80 68       	ori	r24, 0x80	; 128
     5cc:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     5ce:	78 94       	sei
}
     5d0:	08 95       	ret

000005d2 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 0 enable
{
 cli(); //Clears the global interrupt
     5d2:	f8 94       	cli
 MCUCR = MCUCR | 0x02; // INT0 is set to trigger with falling edge
     5d4:	85 b7       	in	r24, 0x35	; 53
     5d6:	82 60       	ori	r24, 0x02	; 2
     5d8:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x40;   // Enable Interrupt INT5 for right position encoder
     5da:	8b b7       	in	r24, 0x3b	; 59
     5dc:	80 64       	ori	r24, 0x40	; 64
     5de:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     5e0:	78 94       	sei
}
     5e2:	08 95       	ret

000005e4 <__vector_1>:

//ISR for right position encoder
ISR(INT0_vect)  
{
     5e4:	1f 92       	push	r1
     5e6:	0f 92       	push	r0
     5e8:	0f b6       	in	r0, 0x3f	; 63
     5ea:	0f 92       	push	r0
     5ec:	11 24       	eor	r1, r1
     5ee:	8f 93       	push	r24
     5f0:	9f 93       	push	r25
     5f2:	af 93       	push	r26
     5f4:	bf 93       	push	r27
 ShaftCountRight++;  //increment right shaft position count
     5f6:	80 91 92 00 	lds	r24, 0x0092
     5fa:	90 91 93 00 	lds	r25, 0x0093
     5fe:	a0 91 94 00 	lds	r26, 0x0094
     602:	b0 91 95 00 	lds	r27, 0x0095
     606:	01 96       	adiw	r24, 0x01	; 1
     608:	a1 1d       	adc	r26, r1
     60a:	b1 1d       	adc	r27, r1
     60c:	80 93 92 00 	sts	0x0092, r24
     610:	90 93 93 00 	sts	0x0093, r25
     614:	a0 93 94 00 	sts	0x0094, r26
     618:	b0 93 95 00 	sts	0x0095, r27
}
     61c:	bf 91       	pop	r27
     61e:	af 91       	pop	r26
     620:	9f 91       	pop	r25
     622:	8f 91       	pop	r24
     624:	0f 90       	pop	r0
     626:	0f be       	out	0x3f, r0	; 63
     628:	0f 90       	pop	r0
     62a:	1f 90       	pop	r1
     62c:	18 95       	reti

0000062e <__vector_2>:

//ISR for left position encoder
ISR(INT1_vect)
{
     62e:	1f 92       	push	r1
     630:	0f 92       	push	r0
     632:	0f b6       	in	r0, 0x3f	; 63
     634:	0f 92       	push	r0
     636:	11 24       	eor	r1, r1
     638:	8f 93       	push	r24
     63a:	9f 93       	push	r25
     63c:	af 93       	push	r26
     63e:	bf 93       	push	r27
 ShaftCountLeft++;  //increment left shaft position count
     640:	80 91 96 00 	lds	r24, 0x0096
     644:	90 91 97 00 	lds	r25, 0x0097
     648:	a0 91 98 00 	lds	r26, 0x0098
     64c:	b0 91 99 00 	lds	r27, 0x0099
     650:	01 96       	adiw	r24, 0x01	; 1
     652:	a1 1d       	adc	r26, r1
     654:	b1 1d       	adc	r27, r1
     656:	80 93 96 00 	sts	0x0096, r24
     65a:	90 93 97 00 	sts	0x0097, r25
     65e:	a0 93 98 00 	sts	0x0098, r26
     662:	b0 93 99 00 	sts	0x0099, r27
}
     666:	bf 91       	pop	r27
     668:	af 91       	pop	r26
     66a:	9f 91       	pop	r25
     66c:	8f 91       	pop	r24
     66e:	0f 90       	pop	r0
     670:	0f be       	out	0x3f, r0	; 63
     672:	0f 90       	pop	r0
     674:	1f 90       	pop	r1
     676:	18 95       	reti

00000678 <angle_rotate>:
}
*/

//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     678:	0f 93       	push	r16
     67a:	1f 93       	push	r17
     67c:	cf 93       	push	r28
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 12.85; // division by resolution to get shaft count 
     67e:	bc 01       	movw	r22, r24
     680:	80 e0       	ldi	r24, 0x00	; 0
     682:	90 e0       	ldi	r25, 0x00	; 0
     684:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <__floatunsisf>
     688:	2a e9       	ldi	r18, 0x9A	; 154
     68a:	39 e9       	ldi	r19, 0x99	; 153
     68c:	4d e4       	ldi	r20, 0x4D	; 77
     68e:	51 e4       	ldi	r21, 0x41	; 65
     690:	0e 94 51 08 	call	0x10a2	; 0x10a2 <__divsf3>
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     694:	0e 94 be 08 	call	0x117c	; 0x117c <__fixunssfsi>
     698:	dc 01       	movw	r26, r24
     69a:	cb 01       	movw	r24, r22
     69c:	a0 e0       	ldi	r26, 0x00	; 0
     69e:	b0 e0       	ldi	r27, 0x00	; 0
 ShaftCountRight = 0; 
     6a0:	10 92 92 00 	sts	0x0092, r1
     6a4:	10 92 93 00 	sts	0x0093, r1
     6a8:	10 92 94 00 	sts	0x0094, r1
     6ac:	10 92 95 00 	sts	0x0095, r1
 ShaftCountLeft = 0; 
     6b0:	10 92 96 00 	sts	0x0096, r1
     6b4:	10 92 97 00 	sts	0x0097, r1
     6b8:	10 92 98 00 	sts	0x0098, r1
     6bc:	10 92 99 00 	sts	0x0099, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     6c0:	f1 e0       	ldi	r31, 0x01	; 1
     6c2:	c0 e0       	ldi	r28, 0x00	; 0
     6c4:	40 91 92 00 	lds	r20, 0x0092
     6c8:	50 91 93 00 	lds	r21, 0x0093
     6cc:	60 91 94 00 	lds	r22, 0x0094
     6d0:	70 91 95 00 	lds	r23, 0x0095
     6d4:	00 91 96 00 	lds	r16, 0x0096
     6d8:	10 91 97 00 	lds	r17, 0x0097
     6dc:	20 91 98 00 	lds	r18, 0x0098
     6e0:	30 91 99 00 	lds	r19, 0x0099
     6e4:	ef 2f       	mov	r30, r31
     6e6:	48 17       	cp	r20, r24
     6e8:	59 07       	cpc	r21, r25
     6ea:	6a 07       	cpc	r22, r26
     6ec:	7b 07       	cpc	r23, r27
     6ee:	08 f4       	brcc	.+2      	; 0x6f2 <angle_rotate+0x7a>
     6f0:	ec 2f       	mov	r30, r28
     6f2:	ee 23       	and	r30, r30
     6f4:	49 f4       	brne	.+18     	; 0x708 <angle_rotate+0x90>
     6f6:	4f 2f       	mov	r20, r31
     6f8:	08 17       	cp	r16, r24
     6fa:	19 07       	cpc	r17, r25
     6fc:	2a 07       	cpc	r18, r26
     6fe:	3b 07       	cpc	r19, r27
     700:	08 f4       	brcc	.+2      	; 0x704 <angle_rotate+0x8c>
     702:	4c 2f       	mov	r20, r28
     704:	44 23       	and	r20, r20
     706:	f1 f2       	breq	.-68     	; 0x6c4 <angle_rotate+0x4c>
  break;
 }
 stop(); //Stop robot
     708:	0e 94 20 05 	call	0xa40	; 0xa40 <stop>
}
     70c:	cf 91       	pop	r28
     70e:	1f 91       	pop	r17
     710:	0f 91       	pop	r16
     712:	08 95       	ret

00000714 <color_sensor_pin_config>:
*/

void color_sensor_pin_config(void)
{
	
	DDRD = DDRD |0xBF;
     714:	81 b3       	in	r24, 0x11	; 17
     716:	8f 6b       	ori	r24, 0xBF	; 191
     718:	81 bb       	out	0x11, r24	; 17
	PORTD = PORTD |0x40;            //Enable internal pull-up for PORTD 6 pin
     71a:	96 9a       	sbi	0x12, 6	; 18
	DDRC =  DDRC|0xF8;            //Initialise pins connected to S0, S1, S2, S3 as output
     71c:	84 b3       	in	r24, 0x14	; 20
     71e:	88 6f       	ori	r24, 0xF8	; 248
     720:	84 bb       	out	0x14, r24	; 20
	PORTC = PORTC|0x00;            // Set pins as LOW initialially
     722:	85 b3       	in	r24, 0x15	; 21
     724:	85 bb       	out	0x15, r24	; 21
	
}
     726:	08 95       	ret

00000728 <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli();               //Clears the global interrupt
     728:	f8 94       	cli
	TIMSK= TIMSK | 0x20; // Enable input capture pin of timer 1 for color sensor
     72a:	89 b7       	in	r24, 0x39	; 57
     72c:	80 62       	ori	r24, 0x20	; 32
     72e:	89 bf       	out	0x39, r24	; 57
	sei();               // Enables the global interrupt
     730:	78 94       	sei
}
     732:	08 95       	ret

00000734 <__vector_5>:

ISR(TIMER1_CAPT_vect)
{
     734:	1f 92       	push	r1
     736:	0f 92       	push	r0
     738:	0f b6       	in	r0, 0x3f	; 63
     73a:	0f 92       	push	r0
     73c:	11 24       	eor	r1, r1
     73e:	8f 93       	push	r24
     740:	9f 93       	push	r25
     742:	af 93       	push	r26
     744:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     746:	80 91 8e 00 	lds	r24, 0x008E
     74a:	90 91 8f 00 	lds	r25, 0x008F
     74e:	a0 91 90 00 	lds	r26, 0x0090
     752:	b0 91 91 00 	lds	r27, 0x0091
     756:	01 96       	adiw	r24, 0x01	; 1
     758:	a1 1d       	adc	r26, r1
     75a:	b1 1d       	adc	r27, r1
     75c:	80 93 8e 00 	sts	0x008E, r24
     760:	90 93 8f 00 	sts	0x008F, r25
     764:	a0 93 90 00 	sts	0x0090, r26
     768:	b0 93 91 00 	sts	0x0091, r27
}
     76c:	bf 91       	pop	r27
     76e:	af 91       	pop	r26
     770:	9f 91       	pop	r25
     772:	8f 91       	pop	r24
     774:	0f 90       	pop	r0
     776:	0f be       	out	0x3f, r0	; 63
     778:	0f 90       	pop	r0
     77a:	1f 90       	pop	r1
     77c:	18 95       	reti

0000077e <timer1_init2>:

void timer1_init2(void)
{
	TCNT1H = 0x00;
     77e:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0x00;
     780:	1c bc       	out	0x2c, r1	; 44
	OCR1AH = 0x00;
     782:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0x00;
     784:	1a bc       	out	0x2a, r1	; 42
	OCR1BH = 0x00;
     786:	19 bc       	out	0x29, r1	; 41
	OCR1BL = 0x00;
     788:	18 bc       	out	0x28, r1	; 40
	TCCR1A = 0x00;
     78a:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0x01; //at clock frequency
     78c:	81 e0       	ldi	r24, 0x01	; 1
     78e:	8e bd       	out	0x2e, r24	; 46
	TIMSK = 0x20;
     790:	80 e2       	ldi	r24, 0x20	; 32
     792:	89 bf       	out	0x39, r24	; 57
}
     794:	08 95       	ret

00000796 <filter_red>:
/////////////////////////////////////////////////////////////////////
//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTC = PORTC & 0xBF; //set S2 low
     796:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 low
     798:	af 98       	cbi	0x15, 7	; 21
}
     79a:	08 95       	ret

0000079c <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTC= PORTC | 0x40; //set S2 High
     79c:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
     79e:	af 9a       	sbi	0x15, 7	; 21
}
     7a0:	08 95       	ret

000007a2 <filter_blue>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTC = PORTC & 0xBF; //set S2 low
     7a2:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
     7a4:	af 9a       	sbi	0x15, 7	; 21
}
     7a6:	08 95       	ret

000007a8 <filter_clear>:

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
 	PORTC = PORTC | 0x40; //set S2 High
     7a8:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 Low
     7aa:	af 98       	cbi	0x15, 7	; 21
}
     7ac:	08 95       	ret

000007ae <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTC = PORTC | 0x10; //set S0 high
     7ae:	ac 9a       	sbi	0x15, 4	; 21
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTC = PORTC | 0x20; //set S1 high
     7b0:	ad 9a       	sbi	0x15, 5	; 21
}
     7b2:	08 95       	ret

000007b4 <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
     7b4:	0e 94 cb 03 	call	0x796	; 0x796 <filter_red>
	pulse=0; //reset the count to 0
     7b8:	10 92 8e 00 	sts	0x008E, r1
     7bc:	10 92 8f 00 	sts	0x008F, r1
     7c0:	10 92 90 00 	sts	0x0090, r1
     7c4:	10 92 91 00 	sts	0x0091, r1
     7c8:	8f ef       	ldi	r24, 0xFF	; 255
     7ca:	9f e3       	ldi	r25, 0x3F	; 63
     7cc:	a2 e0       	ldi	r26, 0x02	; 2
     7ce:	81 50       	subi	r24, 0x01	; 1
     7d0:	90 40       	sbci	r25, 0x00	; 0
     7d2:	a0 40       	sbci	r26, 0x00	; 0
     7d4:	e1 f7       	brne	.-8      	; 0x7ce <red_read+0x1a>
     7d6:	00 c0       	rjmp	.+0      	; 0x7d8 <red_read+0x24>
     7d8:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     7da:	80 91 8e 00 	lds	r24, 0x008E
     7de:	90 91 8f 00 	lds	r25, 0x008F
     7e2:	a0 91 90 00 	lds	r26, 0x0090
     7e6:	b0 91 91 00 	lds	r27, 0x0091
     7ea:	80 93 ac 00 	sts	0x00AC, r24
     7ee:	90 93 ad 00 	sts	0x00AD, r25
     7f2:	a0 93 ae 00 	sts	0x00AE, r26
     7f6:	b0 93 af 00 	sts	0x00AF, r27
}
     7fa:	08 95       	ret

000007fc <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
     7fc:	0e 94 ce 03 	call	0x79c	; 0x79c <filter_green>
	pulse=0; //reset the count to 0
     800:	10 92 8e 00 	sts	0x008E, r1
     804:	10 92 8f 00 	sts	0x008F, r1
     808:	10 92 90 00 	sts	0x0090, r1
     80c:	10 92 91 00 	sts	0x0091, r1
     810:	8f ef       	ldi	r24, 0xFF	; 255
     812:	9f e3       	ldi	r25, 0x3F	; 63
     814:	a2 e0       	ldi	r26, 0x02	; 2
     816:	81 50       	subi	r24, 0x01	; 1
     818:	90 40       	sbci	r25, 0x00	; 0
     81a:	a0 40       	sbci	r26, 0x00	; 0
     81c:	e1 f7       	brne	.-8      	; 0x816 <green_read+0x1a>
     81e:	00 c0       	rjmp	.+0      	; 0x820 <green_read+0x24>
     820:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
     822:	80 91 8e 00 	lds	r24, 0x008E
     826:	90 91 8f 00 	lds	r25, 0x008F
     82a:	a0 91 90 00 	lds	r26, 0x0090
     82e:	b0 91 91 00 	lds	r27, 0x0091
     832:	80 93 a8 00 	sts	0x00A8, r24
     836:	90 93 a9 00 	sts	0x00A9, r25
     83a:	a0 93 aa 00 	sts	0x00AA, r26
     83e:	b0 93 ab 00 	sts	0x00AB, r27
}
     842:	08 95       	ret

00000844 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
     844:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <filter_blue>
	pulse=0; //reset the count to 0
     848:	10 92 8e 00 	sts	0x008E, r1
     84c:	10 92 8f 00 	sts	0x008F, r1
     850:	10 92 90 00 	sts	0x0090, r1
     854:	10 92 91 00 	sts	0x0091, r1
     858:	8f ef       	ldi	r24, 0xFF	; 255
     85a:	9f e3       	ldi	r25, 0x3F	; 63
     85c:	a2 e0       	ldi	r26, 0x02	; 2
     85e:	81 50       	subi	r24, 0x01	; 1
     860:	90 40       	sbci	r25, 0x00	; 0
     862:	a0 40       	sbci	r26, 0x00	; 0
     864:	e1 f7       	brne	.-8      	; 0x85e <blue_read+0x1a>
     866:	00 c0       	rjmp	.+0      	; 0x868 <blue_read+0x24>
     868:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
     86a:	80 91 8e 00 	lds	r24, 0x008E
     86e:	90 91 8f 00 	lds	r25, 0x008F
     872:	a0 91 90 00 	lds	r26, 0x0090
     876:	b0 91 91 00 	lds	r27, 0x0091
     87a:	80 93 9e 00 	sts	0x009E, r24
     87e:	90 93 9f 00 	sts	0x009F, r25
     882:	a0 93 a0 00 	sts	0x00A0, r26
     886:	b0 93 a1 00 	sts	0x00A1, r27
}
     88a:	08 95       	ret

0000088c <colourDetect>:
{
	/*Blue-->0
	Red-->1
	Green-->2*/
	int colour;
	color_sensor_pin_interrupt_init();
     88c:	0e 94 94 03 	call	0x728	; 0x728 <color_sensor_pin_interrupt_init>
	timer1_init2();
     890:	0e 94 bf 03 	call	0x77e	; 0x77e <timer1_init2>
	color_sensor_pin_config();
     894:	0e 94 8a 03 	call	0x714	; 0x714 <color_sensor_pin_config>
	color_sensor_scaling();
     898:	0e 94 d7 03 	call	0x7ae	; 0x7ae <color_sensor_scaling>
	red_read(); //display the pulse count when red filter is selected
     89c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <red_read>
	green_read(); //display the pulse count when green filter is selected
     8a0:	0e 94 fe 03 	call	0x7fc	; 0x7fc <green_read>
	blue_read(); //display the pulse count when blue filter is selected
     8a4:	0e 94 22 04 	call	0x844	; 0x844 <blue_read>
	if((blue>green)&&(blue>red))
     8a8:	80 91 9e 00 	lds	r24, 0x009E
     8ac:	90 91 9f 00 	lds	r25, 0x009F
     8b0:	a0 91 a0 00 	lds	r26, 0x00A0
     8b4:	b0 91 a1 00 	lds	r27, 0x00A1
     8b8:	40 91 a8 00 	lds	r20, 0x00A8
     8bc:	50 91 a9 00 	lds	r21, 0x00A9
     8c0:	60 91 aa 00 	lds	r22, 0x00AA
     8c4:	70 91 ab 00 	lds	r23, 0x00AB
     8c8:	48 17       	cp	r20, r24
     8ca:	59 07       	cpc	r21, r25
     8cc:	6a 07       	cpc	r22, r26
     8ce:	7b 07       	cpc	r23, r27
     8d0:	78 f4       	brcc	.+30     	; 0x8f0 <colourDetect+0x64>
     8d2:	40 91 ac 00 	lds	r20, 0x00AC
     8d6:	50 91 ad 00 	lds	r21, 0x00AD
     8da:	60 91 ae 00 	lds	r22, 0x00AE
     8de:	70 91 af 00 	lds	r23, 0x00AF
     8e2:	48 17       	cp	r20, r24
     8e4:	59 07       	cpc	r21, r25
     8e6:	6a 07       	cpc	r22, r26
     8e8:	7b 07       	cpc	r23, r27
     8ea:	10 f4       	brcc	.+4      	; 0x8f0 <colourDetect+0x64>
	{
		colour=0;
		buzzer_on();
     8ec:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
	}
	if((red>green)&&(red>blue))
     8f0:	80 91 ac 00 	lds	r24, 0x00AC
     8f4:	90 91 ad 00 	lds	r25, 0x00AD
     8f8:	a0 91 ae 00 	lds	r26, 0x00AE
     8fc:	b0 91 af 00 	lds	r27, 0x00AF
     900:	40 91 a8 00 	lds	r20, 0x00A8
     904:	50 91 a9 00 	lds	r21, 0x00A9
     908:	60 91 aa 00 	lds	r22, 0x00AA
     90c:	70 91 ab 00 	lds	r23, 0x00AB
     910:	48 17       	cp	r20, r24
     912:	59 07       	cpc	r21, r25
     914:	6a 07       	cpc	r22, r26
     916:	7b 07       	cpc	r23, r27
     918:	78 f4       	brcc	.+30     	; 0x938 <colourDetect+0xac>
     91a:	40 91 9e 00 	lds	r20, 0x009E
     91e:	50 91 9f 00 	lds	r21, 0x009F
     922:	60 91 a0 00 	lds	r22, 0x00A0
     926:	70 91 a1 00 	lds	r23, 0x00A1
     92a:	48 17       	cp	r20, r24
     92c:	59 07       	cpc	r21, r25
     92e:	6a 07       	cpc	r22, r26
     930:	7b 07       	cpc	r23, r27
     932:	10 f4       	brcc	.+4      	; 0x938 <colourDetect+0xac>
	{
		colour=1;
		buzzer_off();
     934:	0e 94 4b 00 	call	0x96	; 0x96 <buzzer_off>
	}
	if((green>red)&&(green>blue))
     938:	80 91 a8 00 	lds	r24, 0x00A8
     93c:	90 91 a9 00 	lds	r25, 0x00A9
     940:	a0 91 aa 00 	lds	r26, 0x00AA
     944:	b0 91 ab 00 	lds	r27, 0x00AB
     948:	40 91 ac 00 	lds	r20, 0x00AC
     94c:	50 91 ad 00 	lds	r21, 0x00AD
     950:	60 91 ae 00 	lds	r22, 0x00AE
     954:	70 91 af 00 	lds	r23, 0x00AF
     958:	48 17       	cp	r20, r24
     95a:	59 07       	cpc	r21, r25
     95c:	6a 07       	cpc	r22, r26
     95e:	7b 07       	cpc	r23, r27
     960:	18 f5       	brcc	.+70     	; 0x9a8 <colourDetect+0x11c>
     962:	40 91 9e 00 	lds	r20, 0x009E
     966:	50 91 9f 00 	lds	r21, 0x009F
     96a:	60 91 a0 00 	lds	r22, 0x00A0
     96e:	70 91 a1 00 	lds	r23, 0x00A1
     972:	48 17       	cp	r20, r24
     974:	59 07       	cpc	r21, r25
     976:	6a 07       	cpc	r22, r26
     978:	7b 07       	cpc	r23, r27
     97a:	b0 f4       	brcc	.+44     	; 0x9a8 <colourDetect+0x11c>
	{
		colour=2;
		buzzer_on();
     97c:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
     980:	8f ef       	ldi	r24, 0xFF	; 255
     982:	9f e7       	ldi	r25, 0x7F	; 127
     984:	a6 e1       	ldi	r26, 0x16	; 22
     986:	81 50       	subi	r24, 0x01	; 1
     988:	90 40       	sbci	r25, 0x00	; 0
     98a:	a0 40       	sbci	r26, 0x00	; 0
     98c:	e1 f7       	brne	.-8      	; 0x986 <colourDetect+0xfa>
     98e:	00 c0       	rjmp	.+0      	; 0x990 <colourDetect+0x104>
     990:	00 00       	nop
		_delay_ms(1000);
		buzzer_off();
     992:	0e 94 4b 00 	call	0x96	; 0x96 <buzzer_off>
     996:	8f ef       	ldi	r24, 0xFF	; 255
     998:	9f e7       	ldi	r25, 0x7F	; 127
     99a:	a6 e1       	ldi	r26, 0x16	; 22
     99c:	81 50       	subi	r24, 0x01	; 1
     99e:	90 40       	sbci	r25, 0x00	; 0
     9a0:	a0 40       	sbci	r26, 0x00	; 0
     9a2:	e1 f7       	brne	.-8      	; 0x99c <colourDetect+0x110>
     9a4:	00 c0       	rjmp	.+0      	; 0x9a6 <colourDetect+0x11a>
     9a6:	00 00       	nop
     9a8:	08 95       	ret

000009aa <plantDetect>:
}
int plantDetect()
{
	int val;
	float volts;
	adc_init();
     9aa:	0e 94 67 02 	call	0x4ce	; 0x4ce <adc_init>
	adc_pin_config();
     9ae:	0e 94 54 02 	call	0x4a8	; 0x4a8 <adc_pin_config>
	val=ADC_Conversion(2);
     9b2:	82 e0       	ldi	r24, 0x02	; 2
     9b4:	0e 94 6f 02 	call	0x4de	; 0x4de <ADC_Conversion>
	volts=val*0.0196078431;
     9b8:	68 2f       	mov	r22, r24
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	80 e0       	ldi	r24, 0x00	; 0
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <__floatsisf>
     9c4:	21 ea       	ldi	r18, 0xA1	; 161
     9c6:	30 ea       	ldi	r19, 0xA0	; 160
     9c8:	40 ea       	ldi	r20, 0xA0	; 160
     9ca:	5c e3       	ldi	r21, 0x3C	; 60
     9cc:	0e 94 78 09 	call	0x12f0	; 0x12f0 <__mulsf3>
     9d0:	9b 01       	movw	r18, r22
     9d2:	ac 01       	movw	r20, r24
	int distance = 13*pow(volts, -1);
     9d4:	60 e0       	ldi	r22, 0x00	; 0
     9d6:	70 e0       	ldi	r23, 0x00	; 0
     9d8:	80 e8       	ldi	r24, 0x80	; 128
     9da:	9f e3       	ldi	r25, 0x3F	; 63
     9dc:	0e 94 51 08 	call	0x10a2	; 0x10a2 <__divsf3>
     9e0:	20 e0       	ldi	r18, 0x00	; 0
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	40 e5       	ldi	r20, 0x50	; 80
     9e6:	51 e4       	ldi	r21, 0x41	; 65
     9e8:	0e 94 78 09 	call	0x12f0	; 0x12f0 <__mulsf3>
     9ec:	0e 94 b9 08 	call	0x1172	; 0x1172 <__fixsfsi>
     9f0:	ab 01       	movw	r20, r22
     9f2:	bc 01       	movw	r22, r24
	if(distance<10)
		{
			return 1;
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	90 e0       	ldi	r25, 0x00	; 0
     9f8:	4a 30       	cpi	r20, 0x0A	; 10
     9fa:	51 05       	cpc	r21, r1
     9fc:	14 f0       	brlt	.+4      	; 0xa02 <plantDetect+0x58>
     9fe:	80 e0       	ldi	r24, 0x00	; 0
     a00:	90 e0       	ldi	r25, 0x00	; 0
		}
	return 0; 
}
     a02:	08 95       	ret

00000a04 <motion_pin_config>:


//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
	DDRB = DDRB | 0x0F;    //set direction of the PORTB3 to PORTB0 pins as output
     a04:	87 b3       	in	r24, 0x17	; 23
     a06:	8f 60       	ori	r24, 0x0F	; 15
     a08:	87 bb       	out	0x17, r24	; 23
	PORTB = PORTB & 0xF0;  //set initial value of the PORTB3 to PORTB0 pins to logic 0
     a0a:	88 b3       	in	r24, 0x18	; 24
     a0c:	80 7f       	andi	r24, 0xF0	; 240
     a0e:	88 bb       	out	0x18, r24	; 24
	DDRD = DDRD | 0x30;    //Setting PD5 and PD4 pins as output for PWM generation
     a10:	81 b3       	in	r24, 0x11	; 17
     a12:	80 63       	ori	r24, 0x30	; 48
     a14:	81 bb       	out	0x11, r24	; 17
	PORTD = PORTD | 0x30;  //PD5 and PD4 pins are for velocity control using PWM
     a16:	82 b3       	in	r24, 0x12	; 18
     a18:	80 63       	ori	r24, 0x30	; 48
     a1a:	82 bb       	out	0x12, r24	; 18
}
     a1c:	08 95       	ret

00000a1e <port_init>:

void port_init()
{
	lcd_port_config();
     a1e:	0e 94 4d 02 	call	0x49a	; 0x49a <lcd_port_config>
	adc_pin_config();
     a22:	0e 94 54 02 	call	0x4a8	; 0x4a8 <adc_pin_config>
	motion_pin_config();
     a26:	0e 94 02 05 	call	0xa04	; 0xa04 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
     a2a:	0e 94 da 02 	call	0x5b4	; 0x5b4 <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
     a2e:	0e 94 dd 02 	call	0x5ba	; 0x5ba <right_encoder_pin_config>
}
     a32:	08 95       	ret

00000a34 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
	PortBRestore = PORTB; 			// reading the PORTB's original status
     a34:	98 b3       	in	r25, 0x18	; 24
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
     a36:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
     a38:	8f 70       	andi	r24, 0x0F	; 15
	PortBRestore = PORTB; 			// reading the PORTB's original status
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
	PortBRestore |= Direction; 	// adding lower nibbel for direction command and restoring the PORTB status
     a3a:	98 2b       	or	r25, r24
	PORTB = PortBRestore; 			// setting the command to the port
     a3c:	98 bb       	out	0x18, r25	; 24
}
     a3e:	08 95       	ret

00000a40 <stop>:
	motion_set(0x08);
}

void stop (void)
{
	motion_set(0x00);
     a40:	80 e0       	ldi	r24, 0x00	; 0
     a42:	0e 94 1a 05 	call	0xa34	; 0xa34 <motion_set>
}
     a46:	08 95       	ret

00000a48 <forward>:
}


void forward (void) //both wheels forward
{
	motion_set(0x06);
     a48:	86 e0       	ldi	r24, 0x06	; 6
     a4a:	0e 94 1a 05 	call	0xa34	; 0xa34 <motion_set>
}
     a4e:	08 95       	ret

00000a50 <back>:

void back (void) //both wheels backward
{
	motion_set(0x09);
     a50:	89 e0       	ldi	r24, 0x09	; 9
     a52:	0e 94 1a 05 	call	0xa34	; 0xa34 <motion_set>
}
     a56:	08 95       	ret

00000a58 <left>:

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
     a58:	85 e0       	ldi	r24, 0x05	; 5
     a5a:	0e 94 1a 05 	call	0xa34	; 0xa34 <motion_set>
}
     a5e:	08 95       	ret

00000a60 <right>:

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
     a60:	8a e0       	ldi	r24, 0x0A	; 10
     a62:	0e 94 1a 05 	call	0xa34	; 0xa34 <motion_set>
}
     a66:	08 95       	ret

00000a68 <soft_left>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
	motion_set(0x04);
     a68:	84 e0       	ldi	r24, 0x04	; 4
     a6a:	0e 94 1a 05 	call	0xa34	; 0xa34 <motion_set>
}
     a6e:	08 95       	ret

00000a70 <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
	motion_set(0x02);
     a70:	82 e0       	ldi	r24, 0x02	; 2
     a72:	0e 94 1a 05 	call	0xa34	; 0xa34 <motion_set>
}
     a76:	08 95       	ret

00000a78 <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set(0x01);
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	0e 94 1a 05 	call	0xa34	; 0xa34 <motion_set>
}
     a7e:	08 95       	ret

00000a80 <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set(0x08);
     a80:	88 e0       	ldi	r24, 0x08	; 8
     a82:	0e 94 1a 05 	call	0xa34	; 0xa34 <motion_set>
}
     a86:	08 95       	ret

00000a88 <linear_distance_mm>:


//Function used for moving robot forward by specified distance

void linear_distance_mm(unsigned int DistanceInMM, int sign, char purpose)
{
     a88:	9f 92       	push	r9
     a8a:	af 92       	push	r10
     a8c:	bf 92       	push	r11
     a8e:	cf 92       	push	r12
     a90:	df 92       	push	r13
     a92:	ef 92       	push	r14
     a94:	ff 92       	push	r15
     a96:	0f 93       	push	r16
     a98:	1f 93       	push	r17
     a9a:	cf 93       	push	r28
     a9c:	df 93       	push	r29
     a9e:	eb 01       	movw	r28, r22
     aa0:	94 2e       	mov	r9, r20
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0, pendingShaftCount = 0;
	int plant_trigger;
	ReqdShaftCount = DistanceInMM / 12.92; // division by resolution to get shaft count
     aa2:	bc 01       	movw	r22, r24
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	90 e0       	ldi	r25, 0x00	; 0
     aa8:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <__floatunsisf>
     aac:	22 e5       	ldi	r18, 0x52	; 82
     aae:	38 eb       	ldi	r19, 0xB8	; 184
     ab0:	4e e4       	ldi	r20, 0x4E	; 78
     ab2:	51 e4       	ldi	r21, 0x41	; 65
     ab4:	0e 94 51 08 	call	0x10a2	; 0x10a2 <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     ab8:	0e 94 be 08 	call	0x117c	; 0x117c <__fixunssfsi>
     abc:	c6 2e       	mov	r12, r22
     abe:	d7 2e       	mov	r13, r23
     ac0:	e8 2e       	mov	r14, r24
     ac2:	f9 2e       	mov	r15, r25
	
	ShaftCountRight = 0;
     ac4:	10 92 92 00 	sts	0x0092, r1
     ac8:	10 92 93 00 	sts	0x0093, r1
     acc:	10 92 94 00 	sts	0x0094, r1
     ad0:	10 92 95 00 	sts	0x0095, r1
	{		
		readSensor();
		proportional();		
		if(sign > 0){forward();}
		else if(sign < 0){ back();}		
		velocity(baseLine-p,baseLine+p);
     ad4:	0b e6       	ldi	r16, 0x6B	; 107
     ad6:	10 e0       	ldi	r17, 0x00	; 0
     ad8:	0f 2e       	mov	r0, r31
     ada:	fc e7       	ldi	r31, 0x7C	; 124
     adc:	af 2e       	mov	r10, r31
     ade:	f0 e0       	ldi	r31, 0x00	; 0
     ae0:	bf 2e       	mov	r11, r31
     ae2:	f0 2d       	mov	r31, r0
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
	
	ShaftCountRight = 0;
	while(1)
	{		
		readSensor();
     ae4:	0e 94 4d 00 	call	0x9a	; 0x9a <readSensor>
		proportional();		
     ae8:	0e 94 80 00 	call	0x100	; 0x100 <proportional>
		if(sign > 0){forward();}
     aec:	1c 16       	cp	r1, r28
     aee:	1d 06       	cpc	r1, r29
     af0:	1c f4       	brge	.+6      	; 0xaf8 <linear_distance_mm+0x70>
     af2:	0e 94 24 05 	call	0xa48	; 0xa48 <forward>
     af6:	04 c0       	rjmp	.+8      	; 0xb00 <linear_distance_mm+0x78>
		else if(sign < 0){ back();}		
     af8:	dd 23       	and	r29, r29
     afa:	14 f4       	brge	.+4      	; 0xb00 <linear_distance_mm+0x78>
     afc:	0e 94 28 05 	call	0xa50	; 0xa50 <back>
		velocity(baseLine-p,baseLine+p);
     b00:	d8 01       	movw	r26, r16
     b02:	8c 91       	ld	r24, X
     b04:	f5 01       	movw	r30, r10
     b06:	90 81       	ld	r25, Z
     b08:	69 2f       	mov	r22, r25
     b0a:	68 0f       	add	r22, r24
     b0c:	89 1b       	sub	r24, r25
     b0e:	0e 94 d5 02 	call	0x5aa	; 0x5aa <velocity>
		plant_trigger = plantDetect();
     b12:	0e 94 d5 04 	call	0x9aa	; 0x9aa <plantDetect>
		if(plant_trigger == 1){
     b16:	81 30       	cpi	r24, 0x01	; 1
     b18:	91 05       	cpc	r25, r1
     b1a:	11 f5       	brne	.+68     	; 0xb60 <linear_distance_mm+0xd8>
			stop();
     b1c:	0e 94 20 05 	call	0xa40	; 0xa40 <stop>
			pendingShaftCount = ReqdShaftCountInt - ShaftCountRight;
     b20:	80 91 92 00 	lds	r24, 0x0092
     b24:	90 91 93 00 	lds	r25, 0x0093
     b28:	a0 91 94 00 	lds	r26, 0x0094
     b2c:	b0 91 95 00 	lds	r27, 0x0095
			if(purpose == 'S'){ 				
     b30:	f3 e5       	ldi	r31, 0x53	; 83
     b32:	9f 16       	cp	r9, r31
     b34:	29 f4       	brne	.+10     	; 0xb40 <linear_distance_mm+0xb8>
				colourDetect();
     b36:	0e 94 46 04 	call	0x88c	; 0x88c <colourDetect>
				timer1_init();
     b3a:	0e 94 57 02 	call	0x4ae	; 0x4ae <timer1_init>
     b3e:	10 c0       	rjmp	.+32     	; 0xb60 <linear_distance_mm+0xd8>
			}
			else if(purpose == 'W'){
     b40:	87 e5       	ldi	r24, 0x57	; 87
     b42:	98 16       	cp	r9, r24
     b44:	69 f4       	brne	.+26     	; 0xb60 <linear_distance_mm+0xd8>
				stop();
     b46:	0e 94 20 05 	call	0xa40	; 0xa40 <stop>
				buzzer_on();
     b4a:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
     b4e:	8f ef       	ldi	r24, 0xFF	; 255
     b50:	9f e7       	ldi	r25, 0x7F	; 127
     b52:	a3 e4       	ldi	r26, 0x43	; 67
     b54:	81 50       	subi	r24, 0x01	; 1
     b56:	90 40       	sbci	r25, 0x00	; 0
     b58:	a0 40       	sbci	r26, 0x00	; 0
     b5a:	e1 f7       	brne	.-8      	; 0xb54 <linear_distance_mm+0xcc>
     b5c:	00 c0       	rjmp	.+0      	; 0xb5e <linear_distance_mm+0xd6>
     b5e:	00 00       	nop
				_delay_ms(3000);
				//servoAction();				
			} 
		}
		if(ShaftCountRight > ReqdShaftCountInt)
     b60:	80 91 92 00 	lds	r24, 0x0092
     b64:	90 91 93 00 	lds	r25, 0x0093
     b68:	a0 91 94 00 	lds	r26, 0x0094
     b6c:	b0 91 95 00 	lds	r27, 0x0095
     b70:	c8 16       	cp	r12, r24
     b72:	d9 06       	cpc	r13, r25
     b74:	ea 06       	cpc	r14, r26
     b76:	fb 06       	cpc	r15, r27
     b78:	08 f0       	brcs	.+2      	; 0xb7c <linear_distance_mm+0xf4>
     b7a:	b4 cf       	rjmp	.-152    	; 0xae4 <linear_distance_mm+0x5c>
		{
			break; 
		}
	}
	stop(); //Stop robot
     b7c:	0e 94 20 05 	call	0xa40	; 0xa40 <stop>
}
     b80:	df 91       	pop	r29
     b82:	cf 91       	pop	r28
     b84:	1f 91       	pop	r17
     b86:	0f 91       	pop	r16
     b88:	ff 90       	pop	r15
     b8a:	ef 90       	pop	r14
     b8c:	df 90       	pop	r13
     b8e:	cf 90       	pop	r12
     b90:	bf 90       	pop	r11
     b92:	af 90       	pop	r10
     b94:	9f 90       	pop	r9
     b96:	08 95       	ret

00000b98 <forward_mm>:
		p=0;
	}
}

void forward_mm(unsigned int DistanceInMM, char purpose)
{
     b98:	46 2f       	mov	r20, r22
	
	linear_distance_mm(DistanceInMM, 1, purpose);
     b9a:	61 e0       	ldi	r22, 0x01	; 1
     b9c:	70 e0       	ldi	r23, 0x00	; 0
     b9e:	0e 94 44 05 	call	0xa88	; 0xa88 <linear_distance_mm>
}
     ba2:	08 95       	ret

00000ba4 <back_mm>:

void back_mm(unsigned int DistanceInMM, char purpose)
{
     ba4:	46 2f       	mov	r20, r22
	linear_distance_mm(DistanceInMM, -1, purpose);
     ba6:	6f ef       	ldi	r22, 0xFF	; 255
     ba8:	7f ef       	ldi	r23, 0xFF	; 255
     baa:	0e 94 44 05 	call	0xa88	; 0xa88 <linear_distance_mm>
}
     bae:	08 95       	ret

00000bb0 <left_degrees>:

void left_degrees(unsigned int Degrees)
{
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
     bb6:	0e 94 2c 05 	call	0xa58	; 0xa58 <left>
	angle_rotate(Degrees);
     bba:	ce 01       	movw	r24, r28
     bbc:	0e 94 3c 03 	call	0x678	; 0x678 <angle_rotate>
}
     bc0:	df 91       	pop	r29
     bc2:	cf 91       	pop	r28
     bc4:	08 95       	ret

00000bc6 <right_degrees>:



void right_degrees(unsigned int Degrees)
{
     bc6:	cf 93       	push	r28
     bc8:	df 93       	push	r29
     bca:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right(); //Turn right
     bcc:	0e 94 30 05 	call	0xa60	; 0xa60 <right>
	angle_rotate(Degrees);
     bd0:	ce 01       	movw	r24, r28
     bd2:	0e 94 3c 03 	call	0x678	; 0x678 <angle_rotate>
}
     bd6:	df 91       	pop	r29
     bd8:	cf 91       	pop	r28
     bda:	08 95       	ret

00000bdc <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
     bdc:	cf 93       	push	r28
     bde:	df 93       	push	r29
     be0:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
     be2:	0e 94 34 05 	call	0xa68	; 0xa68 <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     be6:	ce 01       	movw	r24, r28
     be8:	88 0f       	add	r24, r24
     bea:	99 1f       	adc	r25, r25
     bec:	0e 94 3c 03 	call	0x678	; 0x678 <angle_rotate>
}
     bf0:	df 91       	pop	r29
     bf2:	cf 91       	pop	r28
     bf4:	08 95       	ret

00000bf6 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     bf6:	cf 93       	push	r28
     bf8:	df 93       	push	r29
     bfa:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
     bfc:	0e 94 38 05 	call	0xa70	; 0xa70 <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     c00:	ce 01       	movw	r24, r28
     c02:	88 0f       	add	r24, r24
     c04:	99 1f       	adc	r25, r25
     c06:	0e 94 3c 03 	call	0x678	; 0x678 <angle_rotate>
}
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	08 95       	ret

00000c10 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
     c16:	0e 94 3c 05 	call	0xa78	; 0xa78 <soft_left_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     c1a:	ce 01       	movw	r24, r28
     c1c:	88 0f       	add	r24, r24
     c1e:	99 1f       	adc	r25, r25
     c20:	0e 94 3c 03 	call	0x678	; 0x678 <angle_rotate>
}
     c24:	df 91       	pop	r29
     c26:	cf 91       	pop	r28
     c28:	08 95       	ret

00000c2a <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     c2a:	cf 93       	push	r28
     c2c:	df 93       	push	r29
     c2e:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2();  //Turn reverse soft right
     c30:	0e 94 40 05 	call	0xa80	; 0xa80 <soft_right_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     c34:	ce 01       	movw	r24, r28
     c36:	88 0f       	add	r24, r24
     c38:	99 1f       	adc	r25, r25
     c3a:	0e 94 3c 03 	call	0x678	; 0x678 <angle_rotate>
}
     c3e:	df 91       	pop	r29
     c40:	cf 91       	pop	r28
     c42:	08 95       	ret

00000c44 <manoeuvre>:
	int y_origin = 'D';
	
	
	
	
	int x_middle = x_F - x_origin;
     c44:	9c 01       	movw	r18, r24
     c46:	24 50       	subi	r18, 0x04	; 4
     c48:	30 40       	sbci	r19, 0x00	; 0
	int y_middle = y_F - y_origin;
     c4a:	64 54       	subi	r22, 0x44	; 68
     c4c:	70 40       	sbci	r23, 0x00	; 0
	
	//For determining the final destination x-coordinate
	if( (x_middle) > 0 ){ x_D = 7; }
     c4e:	12 16       	cp	r1, r18
     c50:	13 06       	cpc	r1, r19
     c52:	3c f4       	brge	.+14     	; 0xc62 <manoeuvre+0x1e>
     c54:	87 e0       	ldi	r24, 0x07	; 7
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	90 93 89 00 	sts	0x0089, r25
     c5c:	80 93 88 00 	sts	0x0088, r24
     c60:	06 c0       	rjmp	.+12     	; 0xc6e <manoeuvre+0x2a>
	else { x_D = 1; }
     c62:	81 e0       	ldi	r24, 0x01	; 1
     c64:	90 e0       	ldi	r25, 0x00	; 0
     c66:	90 93 89 00 	sts	0x0089, r25
     c6a:	80 93 88 00 	sts	0x0088, r24
	int x_intermediate = x_D - x_origin;
     c6e:	80 91 88 00 	lds	r24, 0x0088
     c72:	90 91 89 00 	lds	r25, 0x0089
     c76:	fc 01       	movw	r30, r24
     c78:	34 97       	sbiw	r30, 0x04	; 4
	
	//For determining the final destination y-coordinate	
	if((y_middle) > 0){ y_D = 'F'; }	
     c7a:	16 16       	cp	r1, r22
     c7c:	17 06       	cpc	r1, r23
     c7e:	3c f4       	brge	.+14     	; 0xc8e <manoeuvre+0x4a>
     c80:	86 e4       	ldi	r24, 0x46	; 70
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	90 93 87 00 	sts	0x0087, r25
     c88:	80 93 86 00 	sts	0x0086, r24
     c8c:	10 c0       	rjmp	.+32     	; 0xcae <manoeuvre+0x6a>
	else if((y_middle) == 0){ y_D = 'D'; }
     c8e:	61 15       	cp	r22, r1
     c90:	71 05       	cpc	r23, r1
     c92:	39 f4       	brne	.+14     	; 0xca2 <manoeuvre+0x5e>
     c94:	84 e4       	ldi	r24, 0x44	; 68
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	90 93 87 00 	sts	0x0087, r25
     c9c:	80 93 86 00 	sts	0x0086, r24
     ca0:	06 c0       	rjmp	.+12     	; 0xcae <manoeuvre+0x6a>
	else { y_D = 'B'; } 
     ca2:	82 e4       	ldi	r24, 0x42	; 66
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	90 93 87 00 	sts	0x0087, r25
     caa:	80 93 86 00 	sts	0x0086, r24
	int y_intermediate = y_D - y_origin;	
     cae:	80 91 86 00 	lds	r24, 0x0086
     cb2:	90 91 87 00 	lds	r25, 0x0087
     cb6:	84 54       	subi	r24, 0x44	; 68
     cb8:	90 40       	sbci	r25, 0x00	; 0
	
	//How much to manoeuvre
	vertical = 	x_middle - x_intermediate;
     cba:	2e 1b       	sub	r18, r30
     cbc:	3f 0b       	sbc	r19, r31
     cbe:	30 93 8d 00 	sts	0x008D, r19
     cc2:	20 93 8c 00 	sts	0x008C, r18
	horizontal = y_middle - y_intermediate;
     cc6:	68 1b       	sub	r22, r24
     cc8:	79 0b       	sbc	r23, r25
     cca:	70 93 8b 00 	sts	0x008B, r23
     cce:	60 93 8a 00 	sts	0x008A, r22
	direction = dir_F;	
     cd2:	40 93 b1 00 	sts	0x00B1, r20
}
     cd6:	08 95       	ret

00000cd8 <print_value>:

void print_value()
{
	lcd_set_4bit();
     cd8:	0e 94 0a 01 	call	0x214	; 0x214 <lcd_set_4bit>
	lcd_cursor(1, 3);
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	63 e0       	ldi	r22, 0x03	; 3
     ce0:	0e 94 a0 01 	call	0x340	; 0x340 <lcd_cursor>
	lcd_string("Vert");	
     ce4:	80 e6       	ldi	r24, 0x60	; 96
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	0e 94 91 01 	call	0x322	; 0x322 <lcd_string>
	lcd_print(1,8, vertical, 3);
     cec:	40 91 8c 00 	lds	r20, 0x008C
     cf0:	50 91 8d 00 	lds	r21, 0x008D
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	68 e0       	ldi	r22, 0x08	; 8
     cf8:	23 e0       	ldi	r18, 0x03	; 3
     cfa:	30 e0       	ldi	r19, 0x00	; 0
     cfc:	0e 94 c0 01 	call	0x380	; 0x380 <lcd_print>
	lcd_cursor(2, 1);
     d00:	82 e0       	ldi	r24, 0x02	; 2
     d02:	61 e0       	ldi	r22, 0x01	; 1
     d04:	0e 94 a0 01 	call	0x340	; 0x340 <lcd_cursor>
	lcd_string("horiz");
     d08:	85 e6       	ldi	r24, 0x65	; 101
     d0a:	90 e0       	ldi	r25, 0x00	; 0
     d0c:	0e 94 91 01 	call	0x322	; 0x322 <lcd_string>
	lcd_print(2,8, horizontal, 3);
     d10:	40 91 8a 00 	lds	r20, 0x008A
     d14:	50 91 8b 00 	lds	r21, 0x008B
     d18:	82 e0       	ldi	r24, 0x02	; 2
     d1a:	68 e0       	ldi	r22, 0x08	; 8
     d1c:	23 e0       	ldi	r18, 0x03	; 3
     d1e:	30 e0       	ldi	r19, 0x00	; 0
     d20:	0e 94 c0 01 	call	0x380	; 0x380 <lcd_print>
}
     d24:	08 95       	ret

00000d26 <rotate>:

void rotate(char face){
	switch(direction){
     d26:	90 91 b1 00 	lds	r25, 0x00B1
     d2a:	9e 34       	cpi	r25, 0x4E	; 78
     d2c:	61 f0       	breq	.+24     	; 0xd46 <rotate+0x20>
     d2e:	9f 34       	cpi	r25, 0x4F	; 79
     d30:	20 f4       	brcc	.+8      	; 0xd3a <rotate+0x14>
     d32:	95 34       	cpi	r25, 0x45	; 69
     d34:	09 f0       	breq	.+2      	; 0xd38 <rotate+0x12>
     d36:	5b c0       	rjmp	.+182    	; 0xdee <rotate+0xc8>
     d38:	46 c0       	rjmp	.+140    	; 0xdc6 <rotate+0xa0>
     d3a:	93 35       	cpi	r25, 0x53	; 83
     d3c:	79 f1       	breq	.+94     	; 0xd9c <rotate+0x76>
     d3e:	97 35       	cpi	r25, 0x57	; 87
     d40:	09 f0       	breq	.+2      	; 0xd44 <rotate+0x1e>
     d42:	55 c0       	rjmp	.+170    	; 0xdee <rotate+0xc8>
     d44:	16 c0       	rjmp	.+44     	; 0xd72 <rotate+0x4c>
		case 'N':{
			if(face == 'S'){right_degrees(180);}
     d46:	83 35       	cpi	r24, 0x53	; 83
     d48:	29 f4       	brne	.+10     	; 0xd54 <rotate+0x2e>
     d4a:	84 eb       	ldi	r24, 0xB4	; 180
     d4c:	90 e0       	ldi	r25, 0x00	; 0
     d4e:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <right_degrees>
     d52:	08 95       	ret
			else if(face == 'E'){right_degrees(90);}
     d54:	85 34       	cpi	r24, 0x45	; 69
     d56:	29 f4       	brne	.+10     	; 0xd62 <rotate+0x3c>
     d58:	8a e5       	ldi	r24, 0x5A	; 90
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <right_degrees>
     d60:	08 95       	ret
			else if(face == 'W'){left_degrees(90);}
     d62:	87 35       	cpi	r24, 0x57	; 87
     d64:	09 f0       	breq	.+2      	; 0xd68 <rotate+0x42>
     d66:	43 c0       	rjmp	.+134    	; 0xdee <rotate+0xc8>
     d68:	8a e5       	ldi	r24, 0x5A	; 90
     d6a:	90 e0       	ldi	r25, 0x00	; 0
     d6c:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <left_degrees>
     d70:	08 95       	ret
				break;
		}
		case 'W':{
			if(face == 'S'){left_degrees(90);}
     d72:	83 35       	cpi	r24, 0x53	; 83
     d74:	29 f4       	brne	.+10     	; 0xd80 <rotate+0x5a>
     d76:	8a e5       	ldi	r24, 0x5A	; 90
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <left_degrees>
     d7e:	08 95       	ret
			else if(face == 'E'){right_degrees(180);}
     d80:	85 34       	cpi	r24, 0x45	; 69
     d82:	29 f4       	brne	.+10     	; 0xd8e <rotate+0x68>
     d84:	84 eb       	ldi	r24, 0xB4	; 180
     d86:	90 e0       	ldi	r25, 0x00	; 0
     d88:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <right_degrees>
     d8c:	08 95       	ret
			else if(face == 'N'){right_degrees(90);}
     d8e:	8e 34       	cpi	r24, 0x4E	; 78
     d90:	71 f5       	brne	.+92     	; 0xdee <rotate+0xc8>
     d92:	8a e5       	ldi	r24, 0x5A	; 90
     d94:	90 e0       	ldi	r25, 0x00	; 0
     d96:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <right_degrees>
     d9a:	08 95       	ret
				break;
		}
		case 'S':{
			if(face == 'N'){right_degrees(180);}
     d9c:	8e 34       	cpi	r24, 0x4E	; 78
     d9e:	29 f4       	brne	.+10     	; 0xdaa <rotate+0x84>
     da0:	84 eb       	ldi	r24, 0xB4	; 180
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <right_degrees>
     da8:	08 95       	ret
			else if(face == 'W'){right_degrees(90);}
     daa:	87 35       	cpi	r24, 0x57	; 87
     dac:	29 f4       	brne	.+10     	; 0xdb8 <rotate+0x92>
     dae:	8a e5       	ldi	r24, 0x5A	; 90
     db0:	90 e0       	ldi	r25, 0x00	; 0
     db2:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <right_degrees>
     db6:	08 95       	ret
			else if(face == 'E'){left_degrees(90);}
     db8:	85 34       	cpi	r24, 0x45	; 69
     dba:	c9 f4       	brne	.+50     	; 0xdee <rotate+0xc8>
     dbc:	8a e5       	ldi	r24, 0x5A	; 90
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <left_degrees>
     dc4:	08 95       	ret
				break;
		}
		case 'E':{
			if(face == 'W'){right_degrees(180);}
     dc6:	87 35       	cpi	r24, 0x57	; 87
     dc8:	29 f4       	brne	.+10     	; 0xdd4 <rotate+0xae>
     dca:	84 eb       	ldi	r24, 0xB4	; 180
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <right_degrees>
     dd2:	08 95       	ret
			else if(face == 'S'){right_degrees(90);}
     dd4:	83 35       	cpi	r24, 0x53	; 83
     dd6:	29 f4       	brne	.+10     	; 0xde2 <rotate+0xbc>
     dd8:	8a e5       	ldi	r24, 0x5A	; 90
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <right_degrees>
     de0:	08 95       	ret
			else if(face == 'N'){left_degrees(90);}
     de2:	8e 34       	cpi	r24, 0x4E	; 78
     de4:	21 f4       	brne	.+8      	; 0xdee <rotate+0xc8>
     de6:	8a e5       	ldi	r24, 0x5A	; 90
     de8:	90 e0       	ldi	r25, 0x00	; 0
     dea:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <left_degrees>
     dee:	08 95       	ret

00000df0 <vertical_motion>:
	}
}

void vertical_motion(){
	
	if(vertical < 0){ 
     df0:	80 91 8c 00 	lds	r24, 0x008C
     df4:	90 91 8d 00 	lds	r25, 0x008D
     df8:	99 23       	and	r25, r25
     dfa:	24 f4       	brge	.+8      	; 0xe04 <vertical_motion+0x14>
		face = 'S';
     dfc:	83 e5       	ldi	r24, 0x53	; 83
     dfe:	80 93 9d 00 	sts	0x009D, r24
     e02:	03 c0       	rjmp	.+6      	; 0xe0a <vertical_motion+0x1a>
	}
	else{
		face = 'N';
     e04:	8e e4       	ldi	r24, 0x4E	; 78
     e06:	80 93 9d 00 	sts	0x009D, r24
	}
	rotate(face);
     e0a:	80 91 9d 00 	lds	r24, 0x009D
     e0e:	0e 94 93 06 	call	0xd26	; 0xd26 <rotate>
	direction = face;	
     e12:	80 91 9d 00 	lds	r24, 0x009D
     e16:	80 93 b1 00 	sts	0x00B1, r24
	vertical = abs(vertical);
     e1a:	20 91 8c 00 	lds	r18, 0x008C
     e1e:	30 91 8d 00 	lds	r19, 0x008D
     e22:	33 23       	and	r19, r19
     e24:	1c f4       	brge	.+6      	; 0xe2c <vertical_motion+0x3c>
     e26:	30 95       	com	r19
     e28:	21 95       	neg	r18
     e2a:	3f 4f       	sbci	r19, 0xFF	; 255
     e2c:	30 93 8d 00 	sts	0x008D, r19
     e30:	20 93 8c 00 	sts	0x008C, r18
	//lcd_print(1,3, vertical, 3);
	forward_mm(vertical * 340, 'S');
     e34:	84 e5       	ldi	r24, 0x54	; 84
     e36:	91 e0       	ldi	r25, 0x01	; 1
     e38:	ac 01       	movw	r20, r24
     e3a:	24 9f       	mul	r18, r20
     e3c:	c0 01       	movw	r24, r0
     e3e:	25 9f       	mul	r18, r21
     e40:	90 0d       	add	r25, r0
     e42:	34 9f       	mul	r19, r20
     e44:	90 0d       	add	r25, r0
     e46:	11 24       	eor	r1, r1
     e48:	63 e5       	ldi	r22, 0x53	; 83
     e4a:	0e 94 cc 05 	call	0xb98	; 0xb98 <forward_mm>
}
     e4e:	08 95       	ret

00000e50 <horizontal_motion>:
void horizontal_motion(){
	
	if(horizontal < 0){ 
     e50:	80 91 8a 00 	lds	r24, 0x008A
     e54:	90 91 8b 00 	lds	r25, 0x008B
     e58:	99 23       	and	r25, r25
     e5a:	24 f4       	brge	.+8      	; 0xe64 <horizontal_motion+0x14>
		face = 'E';
     e5c:	85 e4       	ldi	r24, 0x45	; 69
     e5e:	80 93 9d 00 	sts	0x009D, r24
     e62:	03 c0       	rjmp	.+6      	; 0xe6a <horizontal_motion+0x1a>
	}
	else{
		face = 'W';
     e64:	87 e5       	ldi	r24, 0x57	; 87
     e66:	80 93 9d 00 	sts	0x009D, r24
	}
	rotate(face);
     e6a:	80 91 9d 00 	lds	r24, 0x009D
     e6e:	0e 94 93 06 	call	0xd26	; 0xd26 <rotate>
	direction = face;
     e72:	80 91 9d 00 	lds	r24, 0x009D
     e76:	80 93 b1 00 	sts	0x00B1, r24
	horizontal = abs(horizontal);
     e7a:	20 91 8a 00 	lds	r18, 0x008A
     e7e:	30 91 8b 00 	lds	r19, 0x008B
     e82:	33 23       	and	r19, r19
     e84:	1c f4       	brge	.+6      	; 0xe8c <horizontal_motion+0x3c>
     e86:	30 95       	com	r19
     e88:	21 95       	neg	r18
     e8a:	3f 4f       	sbci	r19, 0xFF	; 255
     e8c:	30 93 8b 00 	sts	0x008B, r19
     e90:	20 93 8a 00 	sts	0x008A, r18
	forward_mm(horizontal * 340, 'S');
     e94:	84 e5       	ldi	r24, 0x54	; 84
     e96:	91 e0       	ldi	r25, 0x01	; 1
     e98:	ac 01       	movw	r20, r24
     e9a:	24 9f       	mul	r18, r20
     e9c:	c0 01       	movw	r24, r0
     e9e:	25 9f       	mul	r18, r21
     ea0:	90 0d       	add	r25, r0
     ea2:	34 9f       	mul	r19, r20
     ea4:	90 0d       	add	r25, r0
     ea6:	11 24       	eor	r1, r1
     ea8:	63 e5       	ldi	r22, 0x53	; 83
     eaa:	0e 94 cc 05 	call	0xb98	; 0xb98 <forward_mm>
}
     eae:	08 95       	ret

00000eb0 <scan>:


void scan(int nodes){
     eb0:	cf 92       	push	r12
     eb2:	df 92       	push	r13
     eb4:	ef 92       	push	r14
     eb6:	ff 92       	push	r15
     eb8:	0f 93       	push	r16
     eba:	1f 93       	push	r17
     ebc:	cf 93       	push	r28
     ebe:	df 93       	push	r29
			face = 'N';
			x_D = 7;
		}
		rotate(face);
		direction = face;
		forward_mm(((nodes-1) * 340), 'S');
     ec0:	9c 01       	movw	r18, r24
     ec2:	21 50       	subi	r18, 0x01	; 1
     ec4:	30 40       	sbci	r19, 0x00	; 0
     ec6:	84 e5       	ldi	r24, 0x54	; 84
     ec8:	91 e0       	ldi	r25, 0x01	; 1
     eca:	28 9f       	mul	r18, r24
     ecc:	70 01       	movw	r14, r0
     ece:	29 9f       	mul	r18, r25
     ed0:	f0 0c       	add	r15, r0
     ed2:	38 9f       	mul	r19, r24
     ed4:	f0 0c       	add	r15, r0
     ed6:	11 24       	eor	r1, r1
     ed8:	c2 e0       	ldi	r28, 0x02	; 2
     eda:	d0 e0       	ldi	r29, 0x00	; 0
		if(x_D == 1){
			face = 'S';
			x_D = 7; 
		}
		else if(x_D == 7){
			face = 'N';
     edc:	0e e4       	ldi	r16, 0x4E	; 78
			x_D = 7;
     ede:	0f 2e       	mov	r0, r31
     ee0:	f7 e0       	ldi	r31, 0x07	; 7
     ee2:	cf 2e       	mov	r12, r31
     ee4:	dd 24       	eor	r13, r13
     ee6:	f0 2d       	mov	r31, r0


void scan(int nodes){
	for(int i=0;i<2;i++){	
		if(x_D == 1){
			face = 'S';
     ee8:	13 e5       	ldi	r17, 0x53	; 83
}


void scan(int nodes){
	for(int i=0;i<2;i++){	
		if(x_D == 1){
     eea:	80 91 88 00 	lds	r24, 0x0088
     eee:	90 91 89 00 	lds	r25, 0x0089
     ef2:	81 30       	cpi	r24, 0x01	; 1
     ef4:	91 05       	cpc	r25, r1
     ef6:	39 f4       	brne	.+14     	; 0xf06 <scan+0x56>
			face = 'S';
     ef8:	10 93 9d 00 	sts	0x009D, r17
			x_D = 7; 
     efc:	d0 92 89 00 	sts	0x0089, r13
     f00:	c0 92 88 00 	sts	0x0088, r12
     f04:	09 c0       	rjmp	.+18     	; 0xf18 <scan+0x68>
		}
		else if(x_D == 7){
     f06:	87 30       	cpi	r24, 0x07	; 7
     f08:	91 05       	cpc	r25, r1
     f0a:	31 f4       	brne	.+12     	; 0xf18 <scan+0x68>
			face = 'N';
     f0c:	00 93 9d 00 	sts	0x009D, r16
			x_D = 7;
     f10:	d0 92 89 00 	sts	0x0089, r13
     f14:	c0 92 88 00 	sts	0x0088, r12
		}
		rotate(face);
     f18:	80 91 9d 00 	lds	r24, 0x009D
     f1c:	0e 94 93 06 	call	0xd26	; 0xd26 <rotate>
		direction = face;
     f20:	80 91 9d 00 	lds	r24, 0x009D
     f24:	80 93 b1 00 	sts	0x00B1, r24
		forward_mm(((nodes-1) * 340), 'S');
     f28:	c7 01       	movw	r24, r14
     f2a:	61 2f       	mov	r22, r17
     f2c:	0e 94 cc 05 	call	0xb98	; 0xb98 <forward_mm>
     f30:	21 97       	sbiw	r28, 0x01	; 1
	forward_mm(horizontal * 340, 'S');
}


void scan(int nodes){
	for(int i=0;i<2;i++){	
     f32:	d9 f6       	brne	.-74     	; 0xeea <scan+0x3a>
	
	/*buzzer_on();
	_delay_ms(1000);
	buzzer_off();*/
			
}
     f34:	df 91       	pop	r29
     f36:	cf 91       	pop	r28
     f38:	1f 91       	pop	r17
     f3a:	0f 91       	pop	r16
     f3c:	ff 90       	pop	r15
     f3e:	ef 90       	pop	r14
     f40:	df 90       	pop	r13
     f42:	cf 90       	pop	r12
     f44:	08 95       	ret

00000f46 <init_devices>:

void init_devices (void)
{
	cli(); //Clears the global interrupts
     f46:	f8 94       	cli
	port_init();
     f48:	0e 94 0f 05 	call	0xa1e	; 0xa1e <port_init>
	adc_init();
     f4c:	0e 94 67 02 	call	0x4ce	; 0x4ce <adc_init>
	timer1_init();
     f50:	0e 94 57 02 	call	0x4ae	; 0x4ae <timer1_init>
	left_position_encoder_interrupt_init();
     f54:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     f58:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <right_position_encoder_interrupt_init>
	sei();   //Enables the global interrupts
     f5c:	78 94       	sei
}
     f5e:	08 95       	ret

00000f60 <main>:


int main(void)
{
	//lcd_port_config();
	init_devices();
     f60:	0e 94 a3 07 	call	0xf46	; 0xf46 <init_devices>
	lcd_set_4bit();	
     f64:	0e 94 0a 01 	call	0x214	; 0x214 <lcd_set_4bit>
	lcd_init();	
     f68:	0e 94 49 01 	call	0x292	; 0x292 <lcd_init>
		_delay_ms(1000);		//delay
		buzzer_off();*/
		
		
		//This function will set the nodes to travel in the vertical & horizontal direction for the bot to reach its standard spot
		manoeuvre(x_F, y_F, dir_F);	
     f6c:	83 e0       	ldi	r24, 0x03	; 3
     f6e:	90 e0       	ldi	r25, 0x00	; 0
     f70:	63 e4       	ldi	r22, 0x43	; 67
     f72:	70 e0       	ldi	r23, 0x00	; 0
     f74:	45 e4       	ldi	r20, 0x45	; 69
     f76:	0e 94 22 06 	call	0xc44	; 0xc44 <manoeuvre>
		
		print_value();
     f7a:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <print_value>
     f7e:	8f ef       	ldi	r24, 0xFF	; 255
     f80:	9f e7       	ldi	r25, 0x7F	; 127
     f82:	a0 e7       	ldi	r26, 0x70	; 112
     f84:	81 50       	subi	r24, 0x01	; 1
     f86:	90 40       	sbci	r25, 0x00	; 0
     f88:	a0 40       	sbci	r26, 0x00	; 0
     f8a:	e1 f7       	brne	.-8      	; 0xf84 <main+0x24>
     f8c:	00 c0       	rjmp	.+0      	; 0xf8e <main+0x2e>
     f8e:	00 00       	nop
		_delay_ms(5000);
		
		
		lcd_wr_command(0x01);
     f90:	81 e0       	ldi	r24, 0x01	; 1
     f92:	0e 94 e5 00 	call	0x1ca	; 0x1ca <lcd_wr_command>
		//_delay_ms(1000);
		
				
		vertical_motion();
     f96:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vertical_motion>
		stop();
     f9a:	0e 94 20 05 	call	0xa40	; 0xa40 <stop>
     f9e:	8f ef       	ldi	r24, 0xFF	; 255
     fa0:	9f e3       	ldi	r25, 0x3F	; 63
     fa2:	ab e0       	ldi	r26, 0x0B	; 11
     fa4:	81 50       	subi	r24, 0x01	; 1
     fa6:	90 40       	sbci	r25, 0x00	; 0
     fa8:	a0 40       	sbci	r26, 0x00	; 0
     faa:	e1 f7       	brne	.-8      	; 0xfa4 <main+0x44>
     fac:	00 c0       	rjmp	.+0      	; 0xfae <main+0x4e>
     fae:	00 00       	nop
		_delay_ms(500);
		horizontal_motion();
     fb0:	0e 94 28 07 	call	0xe50	; 0xe50 <horizontal_motion>
     fb4:	8f ef       	ldi	r24, 0xFF	; 255
     fb6:	9f e3       	ldi	r25, 0x3F	; 63
     fb8:	ab e0       	ldi	r26, 0x0B	; 11
     fba:	81 50       	subi	r24, 0x01	; 1
     fbc:	90 40       	sbci	r25, 0x00	; 0
     fbe:	a0 40       	sbci	r26, 0x00	; 0
     fc0:	e1 f7       	brne	.-8      	; 0xfba <main+0x5a>
     fc2:	00 c0       	rjmp	.+0      	; 0xfc4 <main+0x64>
     fc4:	00 00       	nop
		_delay_ms(500);
		//right_degrees(180);
		//_delay_ms(500);
		
		
		scan(STOPS);	
     fc6:	87 e0       	ldi	r24, 0x07	; 7
     fc8:	90 e0       	ldi	r25, 0x00	; 0
     fca:	0e 94 58 07 	call	0xeb0	; 0xeb0 <scan>
		stop();
     fce:	0e 94 20 05 	call	0xa40	; 0xa40 <stop>
		
		
     fd2:	80 e0       	ldi	r24, 0x00	; 0
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	08 95       	ret

00000fd8 <__subsf3>:
     fd8:	50 58       	subi	r21, 0x80	; 128

00000fda <__addsf3>:
     fda:	bb 27       	eor	r27, r27
     fdc:	aa 27       	eor	r26, r26
     fde:	0e d0       	rcall	.+28     	; 0xffc <__addsf3x>
     fe0:	4d c1       	rjmp	.+666    	; 0x127c <__fp_round>
     fe2:	3e d1       	rcall	.+636    	; 0x1260 <__fp_pscA>
     fe4:	30 f0       	brcs	.+12     	; 0xff2 <__addsf3+0x18>
     fe6:	43 d1       	rcall	.+646    	; 0x126e <__fp_pscB>
     fe8:	20 f0       	brcs	.+8      	; 0xff2 <__addsf3+0x18>
     fea:	31 f4       	brne	.+12     	; 0xff8 <__addsf3+0x1e>
     fec:	9f 3f       	cpi	r25, 0xFF	; 255
     fee:	11 f4       	brne	.+4      	; 0xff4 <__addsf3+0x1a>
     ff0:	1e f4       	brtc	.+6      	; 0xff8 <__addsf3+0x1e>
     ff2:	33 c1       	rjmp	.+614    	; 0x125a <__fp_nan>
     ff4:	0e f4       	brtc	.+2      	; 0xff8 <__addsf3+0x1e>
     ff6:	e0 95       	com	r30
     ff8:	e7 fb       	bst	r30, 7
     ffa:	29 c1       	rjmp	.+594    	; 0x124e <__fp_inf>

00000ffc <__addsf3x>:
     ffc:	e9 2f       	mov	r30, r25
     ffe:	4f d1       	rcall	.+670    	; 0x129e <__fp_split3>
    1000:	80 f3       	brcs	.-32     	; 0xfe2 <__addsf3+0x8>
    1002:	ba 17       	cp	r27, r26
    1004:	62 07       	cpc	r22, r18
    1006:	73 07       	cpc	r23, r19
    1008:	84 07       	cpc	r24, r20
    100a:	95 07       	cpc	r25, r21
    100c:	18 f0       	brcs	.+6      	; 0x1014 <__addsf3x+0x18>
    100e:	71 f4       	brne	.+28     	; 0x102c <__addsf3x+0x30>
    1010:	9e f5       	brtc	.+102    	; 0x1078 <__addsf3x+0x7c>
    1012:	67 c1       	rjmp	.+718    	; 0x12e2 <__fp_zero>
    1014:	0e f4       	brtc	.+2      	; 0x1018 <__addsf3x+0x1c>
    1016:	e0 95       	com	r30
    1018:	0b 2e       	mov	r0, r27
    101a:	ba 2f       	mov	r27, r26
    101c:	a0 2d       	mov	r26, r0
    101e:	0b 01       	movw	r0, r22
    1020:	b9 01       	movw	r22, r18
    1022:	90 01       	movw	r18, r0
    1024:	0c 01       	movw	r0, r24
    1026:	ca 01       	movw	r24, r20
    1028:	a0 01       	movw	r20, r0
    102a:	11 24       	eor	r1, r1
    102c:	ff 27       	eor	r31, r31
    102e:	59 1b       	sub	r21, r25
    1030:	99 f0       	breq	.+38     	; 0x1058 <__addsf3x+0x5c>
    1032:	59 3f       	cpi	r21, 0xF9	; 249
    1034:	50 f4       	brcc	.+20     	; 0x104a <__addsf3x+0x4e>
    1036:	50 3e       	cpi	r21, 0xE0	; 224
    1038:	68 f1       	brcs	.+90     	; 0x1094 <__addsf3x+0x98>
    103a:	1a 16       	cp	r1, r26
    103c:	f0 40       	sbci	r31, 0x00	; 0
    103e:	a2 2f       	mov	r26, r18
    1040:	23 2f       	mov	r18, r19
    1042:	34 2f       	mov	r19, r20
    1044:	44 27       	eor	r20, r20
    1046:	58 5f       	subi	r21, 0xF8	; 248
    1048:	f3 cf       	rjmp	.-26     	; 0x1030 <__addsf3x+0x34>
    104a:	46 95       	lsr	r20
    104c:	37 95       	ror	r19
    104e:	27 95       	ror	r18
    1050:	a7 95       	ror	r26
    1052:	f0 40       	sbci	r31, 0x00	; 0
    1054:	53 95       	inc	r21
    1056:	c9 f7       	brne	.-14     	; 0x104a <__addsf3x+0x4e>
    1058:	7e f4       	brtc	.+30     	; 0x1078 <__addsf3x+0x7c>
    105a:	1f 16       	cp	r1, r31
    105c:	ba 0b       	sbc	r27, r26
    105e:	62 0b       	sbc	r22, r18
    1060:	73 0b       	sbc	r23, r19
    1062:	84 0b       	sbc	r24, r20
    1064:	ba f0       	brmi	.+46     	; 0x1094 <__addsf3x+0x98>
    1066:	91 50       	subi	r25, 0x01	; 1
    1068:	a1 f0       	breq	.+40     	; 0x1092 <__addsf3x+0x96>
    106a:	ff 0f       	add	r31, r31
    106c:	bb 1f       	adc	r27, r27
    106e:	66 1f       	adc	r22, r22
    1070:	77 1f       	adc	r23, r23
    1072:	88 1f       	adc	r24, r24
    1074:	c2 f7       	brpl	.-16     	; 0x1066 <__addsf3x+0x6a>
    1076:	0e c0       	rjmp	.+28     	; 0x1094 <__addsf3x+0x98>
    1078:	ba 0f       	add	r27, r26
    107a:	62 1f       	adc	r22, r18
    107c:	73 1f       	adc	r23, r19
    107e:	84 1f       	adc	r24, r20
    1080:	48 f4       	brcc	.+18     	; 0x1094 <__addsf3x+0x98>
    1082:	87 95       	ror	r24
    1084:	77 95       	ror	r23
    1086:	67 95       	ror	r22
    1088:	b7 95       	ror	r27
    108a:	f7 95       	ror	r31
    108c:	9e 3f       	cpi	r25, 0xFE	; 254
    108e:	08 f0       	brcs	.+2      	; 0x1092 <__addsf3x+0x96>
    1090:	b3 cf       	rjmp	.-154    	; 0xff8 <__addsf3+0x1e>
    1092:	93 95       	inc	r25
    1094:	88 0f       	add	r24, r24
    1096:	08 f0       	brcs	.+2      	; 0x109a <__addsf3x+0x9e>
    1098:	99 27       	eor	r25, r25
    109a:	ee 0f       	add	r30, r30
    109c:	97 95       	ror	r25
    109e:	87 95       	ror	r24
    10a0:	08 95       	ret

000010a2 <__divsf3>:
    10a2:	0c d0       	rcall	.+24     	; 0x10bc <__divsf3x>
    10a4:	eb c0       	rjmp	.+470    	; 0x127c <__fp_round>
    10a6:	e3 d0       	rcall	.+454    	; 0x126e <__fp_pscB>
    10a8:	40 f0       	brcs	.+16     	; 0x10ba <__divsf3+0x18>
    10aa:	da d0       	rcall	.+436    	; 0x1260 <__fp_pscA>
    10ac:	30 f0       	brcs	.+12     	; 0x10ba <__divsf3+0x18>
    10ae:	21 f4       	brne	.+8      	; 0x10b8 <__divsf3+0x16>
    10b0:	5f 3f       	cpi	r21, 0xFF	; 255
    10b2:	19 f0       	breq	.+6      	; 0x10ba <__divsf3+0x18>
    10b4:	cc c0       	rjmp	.+408    	; 0x124e <__fp_inf>
    10b6:	51 11       	cpse	r21, r1
    10b8:	15 c1       	rjmp	.+554    	; 0x12e4 <__fp_szero>
    10ba:	cf c0       	rjmp	.+414    	; 0x125a <__fp_nan>

000010bc <__divsf3x>:
    10bc:	f0 d0       	rcall	.+480    	; 0x129e <__fp_split3>
    10be:	98 f3       	brcs	.-26     	; 0x10a6 <__divsf3+0x4>

000010c0 <__divsf3_pse>:
    10c0:	99 23       	and	r25, r25
    10c2:	c9 f3       	breq	.-14     	; 0x10b6 <__divsf3+0x14>
    10c4:	55 23       	and	r21, r21
    10c6:	b1 f3       	breq	.-20     	; 0x10b4 <__divsf3+0x12>
    10c8:	95 1b       	sub	r25, r21
    10ca:	55 0b       	sbc	r21, r21
    10cc:	bb 27       	eor	r27, r27
    10ce:	aa 27       	eor	r26, r26
    10d0:	62 17       	cp	r22, r18
    10d2:	73 07       	cpc	r23, r19
    10d4:	84 07       	cpc	r24, r20
    10d6:	38 f0       	brcs	.+14     	; 0x10e6 <__divsf3_pse+0x26>
    10d8:	9f 5f       	subi	r25, 0xFF	; 255
    10da:	5f 4f       	sbci	r21, 0xFF	; 255
    10dc:	22 0f       	add	r18, r18
    10de:	33 1f       	adc	r19, r19
    10e0:	44 1f       	adc	r20, r20
    10e2:	aa 1f       	adc	r26, r26
    10e4:	a9 f3       	breq	.-22     	; 0x10d0 <__divsf3_pse+0x10>
    10e6:	33 d0       	rcall	.+102    	; 0x114e <__divsf3_pse+0x8e>
    10e8:	0e 2e       	mov	r0, r30
    10ea:	3a f0       	brmi	.+14     	; 0x10fa <__divsf3_pse+0x3a>
    10ec:	e0 e8       	ldi	r30, 0x80	; 128
    10ee:	30 d0       	rcall	.+96     	; 0x1150 <__divsf3_pse+0x90>
    10f0:	91 50       	subi	r25, 0x01	; 1
    10f2:	50 40       	sbci	r21, 0x00	; 0
    10f4:	e6 95       	lsr	r30
    10f6:	00 1c       	adc	r0, r0
    10f8:	ca f7       	brpl	.-14     	; 0x10ec <__divsf3_pse+0x2c>
    10fa:	29 d0       	rcall	.+82     	; 0x114e <__divsf3_pse+0x8e>
    10fc:	fe 2f       	mov	r31, r30
    10fe:	27 d0       	rcall	.+78     	; 0x114e <__divsf3_pse+0x8e>
    1100:	66 0f       	add	r22, r22
    1102:	77 1f       	adc	r23, r23
    1104:	88 1f       	adc	r24, r24
    1106:	bb 1f       	adc	r27, r27
    1108:	26 17       	cp	r18, r22
    110a:	37 07       	cpc	r19, r23
    110c:	48 07       	cpc	r20, r24
    110e:	ab 07       	cpc	r26, r27
    1110:	b0 e8       	ldi	r27, 0x80	; 128
    1112:	09 f0       	breq	.+2      	; 0x1116 <__divsf3_pse+0x56>
    1114:	bb 0b       	sbc	r27, r27
    1116:	80 2d       	mov	r24, r0
    1118:	bf 01       	movw	r22, r30
    111a:	ff 27       	eor	r31, r31
    111c:	93 58       	subi	r25, 0x83	; 131
    111e:	5f 4f       	sbci	r21, 0xFF	; 255
    1120:	2a f0       	brmi	.+10     	; 0x112c <__divsf3_pse+0x6c>
    1122:	9e 3f       	cpi	r25, 0xFE	; 254
    1124:	51 05       	cpc	r21, r1
    1126:	68 f0       	brcs	.+26     	; 0x1142 <__divsf3_pse+0x82>
    1128:	92 c0       	rjmp	.+292    	; 0x124e <__fp_inf>
    112a:	dc c0       	rjmp	.+440    	; 0x12e4 <__fp_szero>
    112c:	5f 3f       	cpi	r21, 0xFF	; 255
    112e:	ec f3       	brlt	.-6      	; 0x112a <__divsf3_pse+0x6a>
    1130:	98 3e       	cpi	r25, 0xE8	; 232
    1132:	dc f3       	brlt	.-10     	; 0x112a <__divsf3_pse+0x6a>
    1134:	86 95       	lsr	r24
    1136:	77 95       	ror	r23
    1138:	67 95       	ror	r22
    113a:	b7 95       	ror	r27
    113c:	f7 95       	ror	r31
    113e:	9f 5f       	subi	r25, 0xFF	; 255
    1140:	c9 f7       	brne	.-14     	; 0x1134 <__divsf3_pse+0x74>
    1142:	88 0f       	add	r24, r24
    1144:	91 1d       	adc	r25, r1
    1146:	96 95       	lsr	r25
    1148:	87 95       	ror	r24
    114a:	97 f9       	bld	r25, 7
    114c:	08 95       	ret
    114e:	e1 e0       	ldi	r30, 0x01	; 1
    1150:	66 0f       	add	r22, r22
    1152:	77 1f       	adc	r23, r23
    1154:	88 1f       	adc	r24, r24
    1156:	bb 1f       	adc	r27, r27
    1158:	62 17       	cp	r22, r18
    115a:	73 07       	cpc	r23, r19
    115c:	84 07       	cpc	r24, r20
    115e:	ba 07       	cpc	r27, r26
    1160:	20 f0       	brcs	.+8      	; 0x116a <__divsf3_pse+0xaa>
    1162:	62 1b       	sub	r22, r18
    1164:	73 0b       	sbc	r23, r19
    1166:	84 0b       	sbc	r24, r20
    1168:	ba 0b       	sbc	r27, r26
    116a:	ee 1f       	adc	r30, r30
    116c:	88 f7       	brcc	.-30     	; 0x1150 <__divsf3_pse+0x90>
    116e:	e0 95       	com	r30
    1170:	08 95       	ret

00001172 <__fixsfsi>:
    1172:	04 d0       	rcall	.+8      	; 0x117c <__fixunssfsi>
    1174:	68 94       	set
    1176:	b1 11       	cpse	r27, r1
    1178:	b5 c0       	rjmp	.+362    	; 0x12e4 <__fp_szero>
    117a:	08 95       	ret

0000117c <__fixunssfsi>:
    117c:	98 d0       	rcall	.+304    	; 0x12ae <__fp_splitA>
    117e:	88 f0       	brcs	.+34     	; 0x11a2 <__fixunssfsi+0x26>
    1180:	9f 57       	subi	r25, 0x7F	; 127
    1182:	90 f0       	brcs	.+36     	; 0x11a8 <__fixunssfsi+0x2c>
    1184:	b9 2f       	mov	r27, r25
    1186:	99 27       	eor	r25, r25
    1188:	b7 51       	subi	r27, 0x17	; 23
    118a:	a0 f0       	brcs	.+40     	; 0x11b4 <__fixunssfsi+0x38>
    118c:	d1 f0       	breq	.+52     	; 0x11c2 <__fixunssfsi+0x46>
    118e:	66 0f       	add	r22, r22
    1190:	77 1f       	adc	r23, r23
    1192:	88 1f       	adc	r24, r24
    1194:	99 1f       	adc	r25, r25
    1196:	1a f0       	brmi	.+6      	; 0x119e <__fixunssfsi+0x22>
    1198:	ba 95       	dec	r27
    119a:	c9 f7       	brne	.-14     	; 0x118e <__fixunssfsi+0x12>
    119c:	12 c0       	rjmp	.+36     	; 0x11c2 <__fixunssfsi+0x46>
    119e:	b1 30       	cpi	r27, 0x01	; 1
    11a0:	81 f0       	breq	.+32     	; 0x11c2 <__fixunssfsi+0x46>
    11a2:	9f d0       	rcall	.+318    	; 0x12e2 <__fp_zero>
    11a4:	b1 e0       	ldi	r27, 0x01	; 1
    11a6:	08 95       	ret
    11a8:	9c c0       	rjmp	.+312    	; 0x12e2 <__fp_zero>
    11aa:	67 2f       	mov	r22, r23
    11ac:	78 2f       	mov	r23, r24
    11ae:	88 27       	eor	r24, r24
    11b0:	b8 5f       	subi	r27, 0xF8	; 248
    11b2:	39 f0       	breq	.+14     	; 0x11c2 <__fixunssfsi+0x46>
    11b4:	b9 3f       	cpi	r27, 0xF9	; 249
    11b6:	cc f3       	brlt	.-14     	; 0x11aa <__fixunssfsi+0x2e>
    11b8:	86 95       	lsr	r24
    11ba:	77 95       	ror	r23
    11bc:	67 95       	ror	r22
    11be:	b3 95       	inc	r27
    11c0:	d9 f7       	brne	.-10     	; 0x11b8 <__fixunssfsi+0x3c>
    11c2:	3e f4       	brtc	.+14     	; 0x11d2 <__fixunssfsi+0x56>
    11c4:	90 95       	com	r25
    11c6:	80 95       	com	r24
    11c8:	70 95       	com	r23
    11ca:	61 95       	neg	r22
    11cc:	7f 4f       	sbci	r23, 0xFF	; 255
    11ce:	8f 4f       	sbci	r24, 0xFF	; 255
    11d0:	9f 4f       	sbci	r25, 0xFF	; 255
    11d2:	08 95       	ret

000011d4 <__floatunsisf>:
    11d4:	e8 94       	clt
    11d6:	09 c0       	rjmp	.+18     	; 0x11ea <__floatsisf+0x12>

000011d8 <__floatsisf>:
    11d8:	97 fb       	bst	r25, 7
    11da:	3e f4       	brtc	.+14     	; 0x11ea <__floatsisf+0x12>
    11dc:	90 95       	com	r25
    11de:	80 95       	com	r24
    11e0:	70 95       	com	r23
    11e2:	61 95       	neg	r22
    11e4:	7f 4f       	sbci	r23, 0xFF	; 255
    11e6:	8f 4f       	sbci	r24, 0xFF	; 255
    11e8:	9f 4f       	sbci	r25, 0xFF	; 255
    11ea:	99 23       	and	r25, r25
    11ec:	a9 f0       	breq	.+42     	; 0x1218 <__floatsisf+0x40>
    11ee:	f9 2f       	mov	r31, r25
    11f0:	96 e9       	ldi	r25, 0x96	; 150
    11f2:	bb 27       	eor	r27, r27
    11f4:	93 95       	inc	r25
    11f6:	f6 95       	lsr	r31
    11f8:	87 95       	ror	r24
    11fa:	77 95       	ror	r23
    11fc:	67 95       	ror	r22
    11fe:	b7 95       	ror	r27
    1200:	f1 11       	cpse	r31, r1
    1202:	f8 cf       	rjmp	.-16     	; 0x11f4 <__floatsisf+0x1c>
    1204:	fa f4       	brpl	.+62     	; 0x1244 <__floatsisf+0x6c>
    1206:	bb 0f       	add	r27, r27
    1208:	11 f4       	brne	.+4      	; 0x120e <__floatsisf+0x36>
    120a:	60 ff       	sbrs	r22, 0
    120c:	1b c0       	rjmp	.+54     	; 0x1244 <__floatsisf+0x6c>
    120e:	6f 5f       	subi	r22, 0xFF	; 255
    1210:	7f 4f       	sbci	r23, 0xFF	; 255
    1212:	8f 4f       	sbci	r24, 0xFF	; 255
    1214:	9f 4f       	sbci	r25, 0xFF	; 255
    1216:	16 c0       	rjmp	.+44     	; 0x1244 <__floatsisf+0x6c>
    1218:	88 23       	and	r24, r24
    121a:	11 f0       	breq	.+4      	; 0x1220 <__floatsisf+0x48>
    121c:	96 e9       	ldi	r25, 0x96	; 150
    121e:	11 c0       	rjmp	.+34     	; 0x1242 <__floatsisf+0x6a>
    1220:	77 23       	and	r23, r23
    1222:	21 f0       	breq	.+8      	; 0x122c <__floatsisf+0x54>
    1224:	9e e8       	ldi	r25, 0x8E	; 142
    1226:	87 2f       	mov	r24, r23
    1228:	76 2f       	mov	r23, r22
    122a:	05 c0       	rjmp	.+10     	; 0x1236 <__floatsisf+0x5e>
    122c:	66 23       	and	r22, r22
    122e:	71 f0       	breq	.+28     	; 0x124c <__floatsisf+0x74>
    1230:	96 e8       	ldi	r25, 0x86	; 134
    1232:	86 2f       	mov	r24, r22
    1234:	70 e0       	ldi	r23, 0x00	; 0
    1236:	60 e0       	ldi	r22, 0x00	; 0
    1238:	2a f0       	brmi	.+10     	; 0x1244 <__floatsisf+0x6c>
    123a:	9a 95       	dec	r25
    123c:	66 0f       	add	r22, r22
    123e:	77 1f       	adc	r23, r23
    1240:	88 1f       	adc	r24, r24
    1242:	da f7       	brpl	.-10     	; 0x123a <__floatsisf+0x62>
    1244:	88 0f       	add	r24, r24
    1246:	96 95       	lsr	r25
    1248:	87 95       	ror	r24
    124a:	97 f9       	bld	r25, 7
    124c:	08 95       	ret

0000124e <__fp_inf>:
    124e:	97 f9       	bld	r25, 7
    1250:	9f 67       	ori	r25, 0x7F	; 127
    1252:	80 e8       	ldi	r24, 0x80	; 128
    1254:	70 e0       	ldi	r23, 0x00	; 0
    1256:	60 e0       	ldi	r22, 0x00	; 0
    1258:	08 95       	ret

0000125a <__fp_nan>:
    125a:	9f ef       	ldi	r25, 0xFF	; 255
    125c:	80 ec       	ldi	r24, 0xC0	; 192
    125e:	08 95       	ret

00001260 <__fp_pscA>:
    1260:	00 24       	eor	r0, r0
    1262:	0a 94       	dec	r0
    1264:	16 16       	cp	r1, r22
    1266:	17 06       	cpc	r1, r23
    1268:	18 06       	cpc	r1, r24
    126a:	09 06       	cpc	r0, r25
    126c:	08 95       	ret

0000126e <__fp_pscB>:
    126e:	00 24       	eor	r0, r0
    1270:	0a 94       	dec	r0
    1272:	12 16       	cp	r1, r18
    1274:	13 06       	cpc	r1, r19
    1276:	14 06       	cpc	r1, r20
    1278:	05 06       	cpc	r0, r21
    127a:	08 95       	ret

0000127c <__fp_round>:
    127c:	09 2e       	mov	r0, r25
    127e:	03 94       	inc	r0
    1280:	00 0c       	add	r0, r0
    1282:	11 f4       	brne	.+4      	; 0x1288 <__fp_round+0xc>
    1284:	88 23       	and	r24, r24
    1286:	52 f0       	brmi	.+20     	; 0x129c <__fp_round+0x20>
    1288:	bb 0f       	add	r27, r27
    128a:	40 f4       	brcc	.+16     	; 0x129c <__fp_round+0x20>
    128c:	bf 2b       	or	r27, r31
    128e:	11 f4       	brne	.+4      	; 0x1294 <__fp_round+0x18>
    1290:	60 ff       	sbrs	r22, 0
    1292:	04 c0       	rjmp	.+8      	; 0x129c <__fp_round+0x20>
    1294:	6f 5f       	subi	r22, 0xFF	; 255
    1296:	7f 4f       	sbci	r23, 0xFF	; 255
    1298:	8f 4f       	sbci	r24, 0xFF	; 255
    129a:	9f 4f       	sbci	r25, 0xFF	; 255
    129c:	08 95       	ret

0000129e <__fp_split3>:
    129e:	57 fd       	sbrc	r21, 7
    12a0:	90 58       	subi	r25, 0x80	; 128
    12a2:	44 0f       	add	r20, r20
    12a4:	55 1f       	adc	r21, r21
    12a6:	59 f0       	breq	.+22     	; 0x12be <__fp_splitA+0x10>
    12a8:	5f 3f       	cpi	r21, 0xFF	; 255
    12aa:	71 f0       	breq	.+28     	; 0x12c8 <__fp_splitA+0x1a>
    12ac:	47 95       	ror	r20

000012ae <__fp_splitA>:
    12ae:	88 0f       	add	r24, r24
    12b0:	97 fb       	bst	r25, 7
    12b2:	99 1f       	adc	r25, r25
    12b4:	61 f0       	breq	.+24     	; 0x12ce <__fp_splitA+0x20>
    12b6:	9f 3f       	cpi	r25, 0xFF	; 255
    12b8:	79 f0       	breq	.+30     	; 0x12d8 <__fp_splitA+0x2a>
    12ba:	87 95       	ror	r24
    12bc:	08 95       	ret
    12be:	12 16       	cp	r1, r18
    12c0:	13 06       	cpc	r1, r19
    12c2:	14 06       	cpc	r1, r20
    12c4:	55 1f       	adc	r21, r21
    12c6:	f2 cf       	rjmp	.-28     	; 0x12ac <__fp_split3+0xe>
    12c8:	46 95       	lsr	r20
    12ca:	f1 df       	rcall	.-30     	; 0x12ae <__fp_splitA>
    12cc:	08 c0       	rjmp	.+16     	; 0x12de <__fp_splitA+0x30>
    12ce:	16 16       	cp	r1, r22
    12d0:	17 06       	cpc	r1, r23
    12d2:	18 06       	cpc	r1, r24
    12d4:	99 1f       	adc	r25, r25
    12d6:	f1 cf       	rjmp	.-30     	; 0x12ba <__fp_splitA+0xc>
    12d8:	86 95       	lsr	r24
    12da:	71 05       	cpc	r23, r1
    12dc:	61 05       	cpc	r22, r1
    12de:	08 94       	sec
    12e0:	08 95       	ret

000012e2 <__fp_zero>:
    12e2:	e8 94       	clt

000012e4 <__fp_szero>:
    12e4:	bb 27       	eor	r27, r27
    12e6:	66 27       	eor	r22, r22
    12e8:	77 27       	eor	r23, r23
    12ea:	cb 01       	movw	r24, r22
    12ec:	97 f9       	bld	r25, 7
    12ee:	08 95       	ret

000012f0 <__mulsf3>:
    12f0:	0b d0       	rcall	.+22     	; 0x1308 <__mulsf3x>
    12f2:	c4 cf       	rjmp	.-120    	; 0x127c <__fp_round>
    12f4:	b5 df       	rcall	.-150    	; 0x1260 <__fp_pscA>
    12f6:	28 f0       	brcs	.+10     	; 0x1302 <__mulsf3+0x12>
    12f8:	ba df       	rcall	.-140    	; 0x126e <__fp_pscB>
    12fa:	18 f0       	brcs	.+6      	; 0x1302 <__mulsf3+0x12>
    12fc:	95 23       	and	r25, r21
    12fe:	09 f0       	breq	.+2      	; 0x1302 <__mulsf3+0x12>
    1300:	a6 cf       	rjmp	.-180    	; 0x124e <__fp_inf>
    1302:	ab cf       	rjmp	.-170    	; 0x125a <__fp_nan>
    1304:	11 24       	eor	r1, r1
    1306:	ee cf       	rjmp	.-36     	; 0x12e4 <__fp_szero>

00001308 <__mulsf3x>:
    1308:	ca df       	rcall	.-108    	; 0x129e <__fp_split3>
    130a:	a0 f3       	brcs	.-24     	; 0x12f4 <__mulsf3+0x4>

0000130c <__mulsf3_pse>:
    130c:	95 9f       	mul	r25, r21
    130e:	d1 f3       	breq	.-12     	; 0x1304 <__mulsf3+0x14>
    1310:	95 0f       	add	r25, r21
    1312:	50 e0       	ldi	r21, 0x00	; 0
    1314:	55 1f       	adc	r21, r21
    1316:	62 9f       	mul	r22, r18
    1318:	f0 01       	movw	r30, r0
    131a:	72 9f       	mul	r23, r18
    131c:	bb 27       	eor	r27, r27
    131e:	f0 0d       	add	r31, r0
    1320:	b1 1d       	adc	r27, r1
    1322:	63 9f       	mul	r22, r19
    1324:	aa 27       	eor	r26, r26
    1326:	f0 0d       	add	r31, r0
    1328:	b1 1d       	adc	r27, r1
    132a:	aa 1f       	adc	r26, r26
    132c:	64 9f       	mul	r22, r20
    132e:	66 27       	eor	r22, r22
    1330:	b0 0d       	add	r27, r0
    1332:	a1 1d       	adc	r26, r1
    1334:	66 1f       	adc	r22, r22
    1336:	82 9f       	mul	r24, r18
    1338:	22 27       	eor	r18, r18
    133a:	b0 0d       	add	r27, r0
    133c:	a1 1d       	adc	r26, r1
    133e:	62 1f       	adc	r22, r18
    1340:	73 9f       	mul	r23, r19
    1342:	b0 0d       	add	r27, r0
    1344:	a1 1d       	adc	r26, r1
    1346:	62 1f       	adc	r22, r18
    1348:	83 9f       	mul	r24, r19
    134a:	a0 0d       	add	r26, r0
    134c:	61 1d       	adc	r22, r1
    134e:	22 1f       	adc	r18, r18
    1350:	74 9f       	mul	r23, r20
    1352:	33 27       	eor	r19, r19
    1354:	a0 0d       	add	r26, r0
    1356:	61 1d       	adc	r22, r1
    1358:	23 1f       	adc	r18, r19
    135a:	84 9f       	mul	r24, r20
    135c:	60 0d       	add	r22, r0
    135e:	21 1d       	adc	r18, r1
    1360:	82 2f       	mov	r24, r18
    1362:	76 2f       	mov	r23, r22
    1364:	6a 2f       	mov	r22, r26
    1366:	11 24       	eor	r1, r1
    1368:	9f 57       	subi	r25, 0x7F	; 127
    136a:	50 40       	sbci	r21, 0x00	; 0
    136c:	8a f0       	brmi	.+34     	; 0x1390 <__mulsf3_pse+0x84>
    136e:	e1 f0       	breq	.+56     	; 0x13a8 <__mulsf3_pse+0x9c>
    1370:	88 23       	and	r24, r24
    1372:	4a f0       	brmi	.+18     	; 0x1386 <__mulsf3_pse+0x7a>
    1374:	ee 0f       	add	r30, r30
    1376:	ff 1f       	adc	r31, r31
    1378:	bb 1f       	adc	r27, r27
    137a:	66 1f       	adc	r22, r22
    137c:	77 1f       	adc	r23, r23
    137e:	88 1f       	adc	r24, r24
    1380:	91 50       	subi	r25, 0x01	; 1
    1382:	50 40       	sbci	r21, 0x00	; 0
    1384:	a9 f7       	brne	.-22     	; 0x1370 <__mulsf3_pse+0x64>
    1386:	9e 3f       	cpi	r25, 0xFE	; 254
    1388:	51 05       	cpc	r21, r1
    138a:	70 f0       	brcs	.+28     	; 0x13a8 <__mulsf3_pse+0x9c>
    138c:	60 cf       	rjmp	.-320    	; 0x124e <__fp_inf>
    138e:	aa cf       	rjmp	.-172    	; 0x12e4 <__fp_szero>
    1390:	5f 3f       	cpi	r21, 0xFF	; 255
    1392:	ec f3       	brlt	.-6      	; 0x138e <__mulsf3_pse+0x82>
    1394:	98 3e       	cpi	r25, 0xE8	; 232
    1396:	dc f3       	brlt	.-10     	; 0x138e <__mulsf3_pse+0x82>
    1398:	86 95       	lsr	r24
    139a:	77 95       	ror	r23
    139c:	67 95       	ror	r22
    139e:	b7 95       	ror	r27
    13a0:	f7 95       	ror	r31
    13a2:	e7 95       	ror	r30
    13a4:	9f 5f       	subi	r25, 0xFF	; 255
    13a6:	c1 f7       	brne	.-16     	; 0x1398 <__mulsf3_pse+0x8c>
    13a8:	fe 2b       	or	r31, r30
    13aa:	88 0f       	add	r24, r24
    13ac:	91 1d       	adc	r25, r1
    13ae:	96 95       	lsr	r25
    13b0:	87 95       	ror	r24
    13b2:	97 f9       	bld	r25, 7
    13b4:	08 95       	ret

000013b6 <__udivmodhi4>:
    13b6:	aa 1b       	sub	r26, r26
    13b8:	bb 1b       	sub	r27, r27
    13ba:	51 e1       	ldi	r21, 0x11	; 17
    13bc:	07 c0       	rjmp	.+14     	; 0x13cc <__udivmodhi4_ep>

000013be <__udivmodhi4_loop>:
    13be:	aa 1f       	adc	r26, r26
    13c0:	bb 1f       	adc	r27, r27
    13c2:	a6 17       	cp	r26, r22
    13c4:	b7 07       	cpc	r27, r23
    13c6:	10 f0       	brcs	.+4      	; 0x13cc <__udivmodhi4_ep>
    13c8:	a6 1b       	sub	r26, r22
    13ca:	b7 0b       	sbc	r27, r23

000013cc <__udivmodhi4_ep>:
    13cc:	88 1f       	adc	r24, r24
    13ce:	99 1f       	adc	r25, r25
    13d0:	5a 95       	dec	r21
    13d2:	a9 f7       	brne	.-22     	; 0x13be <__udivmodhi4_loop>
    13d4:	80 95       	com	r24
    13d6:	90 95       	com	r25
    13d8:	bc 01       	movw	r22, r24
    13da:	cd 01       	movw	r24, r26
    13dc:	08 95       	ret

000013de <_exit>:
    13de:	f8 94       	cli

000013e0 <__stop_program>:
    13e0:	ff cf       	rjmp	.-2      	; 0x13e0 <__stop_program>
