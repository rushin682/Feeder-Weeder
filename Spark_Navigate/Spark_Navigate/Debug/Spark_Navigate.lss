
Spark_Navigate.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000127c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000010  00800060  0000127c  00001310  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000089  00800070  00800070  00001320  2**0
                  ALLOC
  3 .stab         0000216c  00000000  00000000  00001320  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000006a8  00000000  00000000  0000348c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00003b38  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000170d  00000000  00000000  00003bf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000043d  00000000  00000000  00005305  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007bd  00000000  00000000  00005742  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000610  00000000  00000000  00005f00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006c1  00000000  00000000  00006510  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000df0  00000000  00000000  00006bd1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  000079c1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 2d 01 	jmp	0x25a	; 0x25a <__vector_1>
       8:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 d5 01 	jmp	0x3aa	; 0x3aa <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 6a 00 	jmp	0xd4	; 0xd4 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e7       	ldi	r30, 0x7C	; 124
      68:	f2 e1       	ldi	r31, 0x12	; 18
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 37       	cpi	r26, 0x70	; 112
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	a0 e7       	ldi	r26, 0x70	; 112
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 3f       	cpi	r26, 0xF9	; 249
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <main>
      8a:	0c 94 3c 09 	jmp	0x1278	; 0x1278 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <buzzer_on>:
		}
	return 0; 
}
void buzzer_on (void)
{
	PORTC = PORTC | 0b00001000; 
      92:	ab 9a       	sbi	0x15, 3	; 21
}
      94:	08 95       	ret

00000096 <buzzer_off>:
void buzzer_off (void)
{
	PORTC = PORTC & 0b11110111;
      96:	ab 98       	cbi	0x15, 3	; 21
      98:	08 95       	ret

0000009a <motion_pin_config>:


//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
	DDRB = DDRB | 0x0F;    //set direction of the PORTB3 to PORTB0 pins as output
      9a:	87 b3       	in	r24, 0x17	; 23
      9c:	8f 60       	ori	r24, 0x0F	; 15
      9e:	87 bb       	out	0x17, r24	; 23
	PORTB = PORTB & 0xF0;  //set initial value of the PORTB3 to PORTB0 pins to logic 0
      a0:	88 b3       	in	r24, 0x18	; 24
      a2:	80 7f       	andi	r24, 0xF0	; 240
      a4:	88 bb       	out	0x18, r24	; 24
	DDRD = DDRD | 0x30;    //Setting PD5 and PD4 pins as output for PWM generation
      a6:	81 b3       	in	r24, 0x11	; 17
      a8:	80 63       	ori	r24, 0x30	; 48
      aa:	81 bb       	out	0x11, r24	; 17
	PORTD = PORTD | 0x30;  //PD5 and PD4 pins are for velocity control using PWM
      ac:	82 b3       	in	r24, 0x12	; 18
      ae:	80 63       	ori	r24, 0x30	; 48
      b0:	82 bb       	out	0x12, r24	; 18
}
      b2:	08 95       	ret

000000b4 <uart0_init>:
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
	
	UCSRB = (1 << RXEN) | (1 << TXEN);//|(1 << TXCIE);   // Turn on the transmission and reception circuitry
      b4:	88 e1       	ldi	r24, 0x18	; 24
      b6:	8a b9       	out	0x0a, r24	; 10
	UCSRC = (1 << URSEL) | (1 << UCSZ0) | (1 << UCSZ1); // Use 8-bit character sizes
      b8:	86 e8       	ldi	r24, 0x86	; 134
      ba:	80 bd       	out	0x20, r24	; 32
	UBRRL = 0x2F;
      bc:	8f e2       	ldi	r24, 0x2F	; 47
      be:	89 b9       	out	0x09, r24	; 9
	UBRRH =0x00;
      c0:	10 bc       	out	0x20, r1	; 32
}
      c2:	08 95       	ret

000000c4 <USART_Transmit>:

void USART_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) );
      c4:	5d 9b       	sbis	0x0b, 5	; 11
      c6:	fe cf       	rjmp	.-4      	; 0xc4 <USART_Transmit>
	/* Put data into buffer, sends the data */
	UDR = data;
      c8:	8c b9       	out	0x0c, r24	; 12
}
      ca:	08 95       	ret

000000cc <usart_rx>:

unsigned char usart_rx()
{
	while(!(UCSRA & (1<<RXC)));              //wait until reception is completed
      cc:	5f 9b       	sbis	0x0b, 7	; 11
      ce:	fe cf       	rjmp	.-4      	; 0xcc <usart_rx>
	
	return UDR;                                     //receive first character by polling
      d0:	8c b1       	in	r24, 0x0c	; 12
}
      d2:	08 95       	ret

000000d4 <__vector_11>:

ISR(USART_RXC_vect)
{
      d4:	1f 92       	push	r1
      d6:	0f 92       	push	r0
      d8:	0f b6       	in	r0, 0x3f	; 63
      da:	0f 92       	push	r0
      dc:	11 24       	eor	r1, r1
      de:	2f 93       	push	r18
      e0:	3f 93       	push	r19
      e2:	5f 93       	push	r21
      e4:	6f 93       	push	r22
      e6:	7f 93       	push	r23
      e8:	8f 93       	push	r24
      ea:	9f 93       	push	r25
      ec:	af 93       	push	r26
      ee:	bf 93       	push	r27
      f0:	ef 93       	push	r30
      f2:	ff 93       	push	r31
	ReceivedByte = UDR; // Fetch the received byte value into the variable "ByteReceived"
      f4:	8c b1       	in	r24, 0x0c	; 12
      f6:	80 93 9e 00 	sts	0x009E, r24
	if ((ReceivedByte=='A')||(ReceivedByte=='C')){
      fa:	81 34       	cpi	r24, 0x41	; 65
      fc:	11 f0       	breq	.+4      	; 0x102 <__vector_11+0x2e>
      fe:	83 34       	cpi	r24, 0x43	; 67
     100:	39 f4       	brne	.+14     	; 0x110 <__vector_11+0x3c>
		triggered = 1;			
     102:	21 e0       	ldi	r18, 0x01	; 1
     104:	30 e0       	ldi	r19, 0x00	; 0
     106:	30 93 98 00 	sts	0x0098, r19
     10a:	20 93 97 00 	sts	0x0097, r18
     10e:	07 c0       	rjmp	.+14     	; 0x11e <__vector_11+0x4a>
	}
	if (triggered == 1 && ReceivedByte != 'E'){
     110:	20 91 97 00 	lds	r18, 0x0097
     114:	30 91 98 00 	lds	r19, 0x0098
     118:	21 30       	cpi	r18, 0x01	; 1
     11a:	31 05       	cpc	r19, r1
     11c:	71 f4       	brne	.+28     	; 0x13a <__vector_11+0x66>
     11e:	85 34       	cpi	r24, 0x45	; 69
     120:	61 f0       	breq	.+24     	; 0x13a <__vector_11+0x66>
		int ascii = ReceivedByte;
		global_array[(ascii % 100)] = (ascii / 100);
     122:	90 e0       	ldi	r25, 0x00	; 0
     124:	64 e6       	ldi	r22, 0x64	; 100
     126:	70 e0       	ldi	r23, 0x00	; 0
     128:	0e 94 15 09 	call	0x122a	; 0x122a <__divmodhi4>
     12c:	fc 01       	movw	r30, r24
     12e:	ee 0f       	add	r30, r30
     130:	ff 1f       	adc	r31, r31
     132:	ef 54       	subi	r30, 0x4F	; 79
     134:	ff 4f       	sbci	r31, 0xFF	; 255
     136:	71 83       	std	Z+1, r23	; 0x01
     138:	60 83       	st	Z, r22
	}
	
     13a:	ff 91       	pop	r31
     13c:	ef 91       	pop	r30
     13e:	bf 91       	pop	r27
     140:	af 91       	pop	r26
     142:	9f 91       	pop	r25
     144:	8f 91       	pop	r24
     146:	7f 91       	pop	r23
     148:	6f 91       	pop	r22
     14a:	5f 91       	pop	r21
     14c:	3f 91       	pop	r19
     14e:	2f 91       	pop	r18
     150:	0f 90       	pop	r0
     152:	0f be       	out	0x3f, r0	; 63
     154:	0f 90       	pop	r0
     156:	1f 90       	pop	r1
     158:	18 95       	reti

0000015a <lcd_port_config>:


//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     15a:	84 b3       	in	r24, 0x14	; 20
     15c:	87 6f       	ori	r24, 0xF7	; 247
     15e:	84 bb       	out	0x14, r24	; 20
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     160:	85 b3       	in	r24, 0x15	; 21
     162:	80 78       	andi	r24, 0x80	; 128
     164:	85 bb       	out	0x15, r24	; 21
}
     166:	08 95       	ret

00000168 <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
 DDRA = 0x00;   //set PORTF direction as input
     168:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00;  //set PORTF pins floating
     16a:	1b ba       	out	0x1b, r1	; 27
}
     16c:	08 95       	ret

0000016e <timer1_init>:
// WGM: 5) PWM 8bit fast, TOP=0x00FF
// desired value: 450Hz
// actual value: 450.000Hz (0.0%)
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     16e:	1e bc       	out	0x2e, r1	; 46
 TCNT1H = 0xFF; //setup
     170:	8f ef       	ldi	r24, 0xFF	; 255
     172:	8d bd       	out	0x2d, r24	; 45
 TCNT1L = 0x01;
     174:	91 e0       	ldi	r25, 0x01	; 1
     176:	9c bd       	out	0x2c, r25	; 44
 OCR1AH = 0x00;
     178:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = 0xFF;
     17a:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     17c:	19 bc       	out	0x29, r1	; 41
 OCR1BL = 0xFF;
     17e:	88 bd       	out	0x28, r24	; 40
 ICR1H  = 0x00;
     180:	17 bc       	out	0x27, r1	; 39
 ICR1L  = 0xFF;
     182:	86 bd       	out	0x26, r24	; 38
 TCCR1A = 0xA1;
     184:	81 ea       	ldi	r24, 0xA1	; 161
     186:	8f bd       	out	0x2f, r24	; 47
 TCCR1B = 0x0D; //start Timer
     188:	8d e0       	ldi	r24, 0x0D	; 13
     18a:	8e bd       	out	0x2e, r24	; 46
}
     18c:	08 95       	ret

0000018e <adc_init>:


//Function to Initialize ADC
void adc_init()
{
 ADCSRA = 0x00;
     18e:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     190:	80 e2       	ldi	r24, 0x20	; 32
     192:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     194:	80 e8       	ldi	r24, 0x80	; 128
     196:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     198:	86 e8       	ldi	r24, 0x86	; 134
     19a:	86 b9       	out	0x06, r24	; 6
}
     19c:	08 95       	ret

0000019e <ADC_Conversion>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     19e:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     1a0:	80 62       	ori	r24, 0x20	; 32
     1a2:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
     1a4:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     1a6:	34 9b       	sbis	0x06, 4	; 6
     1a8:	fe cf       	rjmp	.-4      	; 0x1a6 <ADC_Conversion+0x8>
 a=ADCH;
     1aa:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     1ac:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     1ae:	08 95       	ret

000001b0 <sensor>:
	if(th[2] == 1){PORTC |= 0b00000100;}
	else if(th[2] == 1){PORTC &= 0b11111011;}*/
	
}
void sensor(int n,int sn,int avgn)
{
     1b0:	0f 93       	push	r16
     1b2:	1f 93       	push	r17
     1b4:	cf 93       	push	r28
     1b6:	df 93       	push	r29
     1b8:	8c 01       	movw	r16, r24
     1ba:	ea 01       	movw	r28, r20
	
	sn=ADC_Conversion(n+3);
     1bc:	8d 5f       	subi	r24, 0xFD	; 253
     1be:	0e 94 cf 00 	call	0x19e	; 0x19e <ADC_Conversion>
     1c2:	90 e0       	ldi	r25, 0x00	; 0
	if(sn>=avgn)
     1c4:	8c 17       	cp	r24, r28
     1c6:	9d 07       	cpc	r25, r29
     1c8:	fc f0       	brlt	.+62     	; 0x208 <sensor+0x58>
	{
		th[n]=1;
     1ca:	f8 01       	movw	r30, r16
     1cc:	ee 0f       	add	r30, r30
     1ce:	ff 1f       	adc	r31, r31
     1d0:	e8 58       	subi	r30, 0x88	; 136
     1d2:	ff 4f       	sbci	r31, 0xFF	; 255
     1d4:	81 e0       	ldi	r24, 0x01	; 1
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	91 83       	std	Z+1, r25	; 0x01
     1da:	80 83       	st	Z, r24
		highcount++;
     1dc:	80 91 72 00 	lds	r24, 0x0072
     1e0:	90 91 73 00 	lds	r25, 0x0073
     1e4:	01 96       	adiw	r24, 0x01	; 1
     1e6:	90 93 73 00 	sts	0x0073, r25
     1ea:	80 93 72 00 	sts	0x0072, r24
		highcurrent+=(n+1);
     1ee:	c8 01       	movw	r24, r16
     1f0:	01 96       	adiw	r24, 0x01	; 1
     1f2:	00 91 70 00 	lds	r16, 0x0070
     1f6:	10 91 71 00 	lds	r17, 0x0071
     1fa:	08 0f       	add	r16, r24
     1fc:	19 1f       	adc	r17, r25
     1fe:	10 93 71 00 	sts	0x0071, r17
     202:	00 93 70 00 	sts	0x0070, r16
     206:	07 c0       	rjmp	.+14     	; 0x216 <sensor+0x66>
	}
	else if(sn<avgn)
	{
		th[n]=0;
     208:	f8 01       	movw	r30, r16
     20a:	ee 0f       	add	r30, r30
     20c:	ff 1f       	adc	r31, r31
     20e:	e8 58       	subi	r30, 0x88	; 136
     210:	ff 4f       	sbci	r31, 0xFF	; 255
     212:	11 82       	std	Z+1, r1	; 0x01
     214:	10 82       	st	Z, r1
	}
	//lcd_print(1, 3-n, th[n], 1);
}
     216:	df 91       	pop	r29
     218:	cf 91       	pop	r28
     21a:	1f 91       	pop	r17
     21c:	0f 91       	pop	r16
     21e:	08 95       	ret

00000220 <velocity>:

//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
 OCR1AH = 0x00;
     220:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = left_motor; 
     222:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     224:	19 bc       	out	0x29, r1	; 41
 OCR1BL = right_motor;
     226:	68 bd       	out	0x28, r22	; 40
}
     228:	08 95       	ret

0000022a <left_encoder_pin_config>:
unsigned int Degrees; //to accept angle in degrees for turning

//Function to configure INT1 (PORTD 3) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xF7;  //Set the direction of the PORTD 3 pin as input
     22a:	8b 98       	cbi	0x11, 3	; 17
 PORTD = PORTD | 0x08; //Enable internal pull-up for PORTD 3 pin
     22c:	93 9a       	sbi	0x12, 3	; 18
}
     22e:	08 95       	ret

00000230 <right_encoder_pin_config>:

//Function to configure INT0 (PORTD 2) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xFB;  //Set the direction of the PORTD 2 pin as input
     230:	8a 98       	cbi	0x11, 2	; 17
 PORTD = PORTD | 0x04; //Enable internal pull-up for PORTD 2 pin
     232:	92 9a       	sbi	0x12, 2	; 18
}
     234:	08 95       	ret

00000236 <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 1 enable
{
 cli(); //Clears the global interrupt
     236:	f8 94       	cli
 MCUCR = MCUCR | 0x08; // INT1 is set to trigger with falling edge
     238:	85 b7       	in	r24, 0x35	; 53
     23a:	88 60       	ori	r24, 0x08	; 8
     23c:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x80;   // Enable Interrupt INT1 for left position encoder
     23e:	8b b7       	in	r24, 0x3b	; 59
     240:	80 68       	ori	r24, 0x80	; 128
     242:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     244:	78 94       	sei
}
     246:	08 95       	ret

00000248 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 0 enable
{
 cli(); //Clears the global interrupt
     248:	f8 94       	cli
 MCUCR = MCUCR | 0x02; // INT0 is set to trigger with falling edge
     24a:	85 b7       	in	r24, 0x35	; 53
     24c:	82 60       	ori	r24, 0x02	; 2
     24e:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x40;   // Enable Interrupt INT5 for right position encoder
     250:	8b b7       	in	r24, 0x3b	; 59
     252:	80 64       	ori	r24, 0x40	; 64
     254:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     256:	78 94       	sei
}
     258:	08 95       	ret

0000025a <__vector_1>:

//ISR for right position encoder
ISR(INT0_vect)  
{
     25a:	1f 92       	push	r1
     25c:	0f 92       	push	r0
     25e:	0f b6       	in	r0, 0x3f	; 63
     260:	0f 92       	push	r0
     262:	11 24       	eor	r1, r1
     264:	8f 93       	push	r24
     266:	9f 93       	push	r25
     268:	af 93       	push	r26
     26a:	bf 93       	push	r27
 ShaftCountRight++;  //increment right shaft position count
     26c:	80 91 8a 00 	lds	r24, 0x008A
     270:	90 91 8b 00 	lds	r25, 0x008B
     274:	a0 91 8c 00 	lds	r26, 0x008C
     278:	b0 91 8d 00 	lds	r27, 0x008D
     27c:	01 96       	adiw	r24, 0x01	; 1
     27e:	a1 1d       	adc	r26, r1
     280:	b1 1d       	adc	r27, r1
     282:	80 93 8a 00 	sts	0x008A, r24
     286:	90 93 8b 00 	sts	0x008B, r25
     28a:	a0 93 8c 00 	sts	0x008C, r26
     28e:	b0 93 8d 00 	sts	0x008D, r27
}
     292:	bf 91       	pop	r27
     294:	af 91       	pop	r26
     296:	9f 91       	pop	r25
     298:	8f 91       	pop	r24
     29a:	0f 90       	pop	r0
     29c:	0f be       	out	0x3f, r0	; 63
     29e:	0f 90       	pop	r0
     2a0:	1f 90       	pop	r1
     2a2:	18 95       	reti

000002a4 <__vector_2>:

//ISR for left position encoder
ISR(INT1_vect)
{
     2a4:	1f 92       	push	r1
     2a6:	0f 92       	push	r0
     2a8:	0f b6       	in	r0, 0x3f	; 63
     2aa:	0f 92       	push	r0
     2ac:	11 24       	eor	r1, r1
     2ae:	8f 93       	push	r24
     2b0:	9f 93       	push	r25
     2b2:	af 93       	push	r26
     2b4:	bf 93       	push	r27
 ShaftCountLeft++;  //increment left shaft position count
     2b6:	80 91 8e 00 	lds	r24, 0x008E
     2ba:	90 91 8f 00 	lds	r25, 0x008F
     2be:	a0 91 90 00 	lds	r26, 0x0090
     2c2:	b0 91 91 00 	lds	r27, 0x0091
     2c6:	01 96       	adiw	r24, 0x01	; 1
     2c8:	a1 1d       	adc	r26, r1
     2ca:	b1 1d       	adc	r27, r1
     2cc:	80 93 8e 00 	sts	0x008E, r24
     2d0:	90 93 8f 00 	sts	0x008F, r25
     2d4:	a0 93 90 00 	sts	0x0090, r26
     2d8:	b0 93 91 00 	sts	0x0091, r27
}
     2dc:	bf 91       	pop	r27
     2de:	af 91       	pop	r26
     2e0:	9f 91       	pop	r25
     2e2:	8f 91       	pop	r24
     2e4:	0f 90       	pop	r0
     2e6:	0f be       	out	0x3f, r0	; 63
     2e8:	0f 90       	pop	r0
     2ea:	1f 90       	pop	r1
     2ec:	18 95       	reti

000002ee <angle_rotate>:


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     2ee:	0f 93       	push	r16
     2f0:	1f 93       	push	r17
     2f2:	cf 93       	push	r28
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 12.85; // division by resolution to get shaft count 
     2f4:	bc 01       	movw	r22, r24
     2f6:	80 e0       	ldi	r24, 0x00	; 0
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	0e 94 24 08 	call	0x1048	; 0x1048 <__floatunsisf>
     2fe:	2a e9       	ldi	r18, 0x9A	; 154
     300:	39 e9       	ldi	r19, 0x99	; 153
     302:	4d e4       	ldi	r20, 0x4D	; 77
     304:	51 e4       	ldi	r21, 0x41	; 65
     306:	0e 94 8b 07 	call	0xf16	; 0xf16 <__divsf3>
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     30a:	0e 94 f8 07 	call	0xff0	; 0xff0 <__fixunssfsi>
     30e:	dc 01       	movw	r26, r24
     310:	cb 01       	movw	r24, r22
     312:	a0 e0       	ldi	r26, 0x00	; 0
     314:	b0 e0       	ldi	r27, 0x00	; 0
 ShaftCountRight = 0; 
     316:	10 92 8a 00 	sts	0x008A, r1
     31a:	10 92 8b 00 	sts	0x008B, r1
     31e:	10 92 8c 00 	sts	0x008C, r1
     322:	10 92 8d 00 	sts	0x008D, r1
 ShaftCountLeft = 0; 
     326:	10 92 8e 00 	sts	0x008E, r1
     32a:	10 92 8f 00 	sts	0x008F, r1
     32e:	10 92 90 00 	sts	0x0090, r1
     332:	10 92 91 00 	sts	0x0091, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     336:	f1 e0       	ldi	r31, 0x01	; 1
     338:	c0 e0       	ldi	r28, 0x00	; 0
     33a:	40 91 8a 00 	lds	r20, 0x008A
     33e:	50 91 8b 00 	lds	r21, 0x008B
     342:	60 91 8c 00 	lds	r22, 0x008C
     346:	70 91 8d 00 	lds	r23, 0x008D
     34a:	00 91 8e 00 	lds	r16, 0x008E
     34e:	10 91 8f 00 	lds	r17, 0x008F
     352:	20 91 90 00 	lds	r18, 0x0090
     356:	30 91 91 00 	lds	r19, 0x0091
     35a:	ef 2f       	mov	r30, r31
     35c:	48 17       	cp	r20, r24
     35e:	59 07       	cpc	r21, r25
     360:	6a 07       	cpc	r22, r26
     362:	7b 07       	cpc	r23, r27
     364:	08 f4       	brcc	.+2      	; 0x368 <angle_rotate+0x7a>
     366:	ec 2f       	mov	r30, r28
     368:	ee 23       	and	r30, r30
     36a:	49 f4       	brne	.+18     	; 0x37e <angle_rotate+0x90>
     36c:	4f 2f       	mov	r20, r31
     36e:	08 17       	cp	r16, r24
     370:	19 07       	cpc	r17, r25
     372:	2a 07       	cpc	r18, r26
     374:	3b 07       	cpc	r19, r27
     376:	08 f4       	brcc	.+2      	; 0x37a <angle_rotate+0x8c>
     378:	4c 2f       	mov	r20, r28
     37a:	44 23       	and	r20, r20
     37c:	f1 f2       	breq	.-68     	; 0x33a <angle_rotate+0x4c>
  break;
 }
 stop(); //Stop robot
     37e:	0e 94 00 04 	call	0x800	; 0x800 <stop>
}
     382:	cf 91       	pop	r28
     384:	1f 91       	pop	r17
     386:	0f 91       	pop	r16
     388:	08 95       	ret

0000038a <color_sensor_pin_config>:
unsigned long int green;     // variable to store the green pulse count

void color_sensor_pin_config(void)
{
	
	DDRD = DDRD |0xBF;
     38a:	81 b3       	in	r24, 0x11	; 17
     38c:	8f 6b       	ori	r24, 0xBF	; 191
     38e:	81 bb       	out	0x11, r24	; 17
	PORTD = PORTD |0x40;            //Enable internal pull-up for PORTD 6 pin
     390:	96 9a       	sbi	0x12, 6	; 18
	DDRC =  DDRC|0xF8;            //Initialise pins connected to S0, S1, S2, S3 as output
     392:	84 b3       	in	r24, 0x14	; 20
     394:	88 6f       	ori	r24, 0xF8	; 248
     396:	84 bb       	out	0x14, r24	; 20
	PORTC = PORTC|0x00;            // Set pins as LOW initialially
     398:	85 b3       	in	r24, 0x15	; 21
     39a:	85 bb       	out	0x15, r24	; 21
	
}
     39c:	08 95       	ret

0000039e <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli();               //Clears the global interrupt
     39e:	f8 94       	cli
	TIMSK= TIMSK | 0x20; // Enable input capture pin of timer 1 for color sensor
     3a0:	89 b7       	in	r24, 0x39	; 57
     3a2:	80 62       	ori	r24, 0x20	; 32
     3a4:	89 bf       	out	0x39, r24	; 57
	sei();               // Enables the global interrupt
     3a6:	78 94       	sei
}
     3a8:	08 95       	ret

000003aa <__vector_5>:

ISR(TIMER1_CAPT_vect)
{
     3aa:	1f 92       	push	r1
     3ac:	0f 92       	push	r0
     3ae:	0f b6       	in	r0, 0x3f	; 63
     3b0:	0f 92       	push	r0
     3b2:	11 24       	eor	r1, r1
     3b4:	8f 93       	push	r24
     3b6:	9f 93       	push	r25
     3b8:	af 93       	push	r26
     3ba:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     3bc:	80 91 86 00 	lds	r24, 0x0086
     3c0:	90 91 87 00 	lds	r25, 0x0087
     3c4:	a0 91 88 00 	lds	r26, 0x0088
     3c8:	b0 91 89 00 	lds	r27, 0x0089
     3cc:	01 96       	adiw	r24, 0x01	; 1
     3ce:	a1 1d       	adc	r26, r1
     3d0:	b1 1d       	adc	r27, r1
     3d2:	80 93 86 00 	sts	0x0086, r24
     3d6:	90 93 87 00 	sts	0x0087, r25
     3da:	a0 93 88 00 	sts	0x0088, r26
     3de:	b0 93 89 00 	sts	0x0089, r27
}
     3e2:	bf 91       	pop	r27
     3e4:	af 91       	pop	r26
     3e6:	9f 91       	pop	r25
     3e8:	8f 91       	pop	r24
     3ea:	0f 90       	pop	r0
     3ec:	0f be       	out	0x3f, r0	; 63
     3ee:	0f 90       	pop	r0
     3f0:	1f 90       	pop	r1
     3f2:	18 95       	reti

000003f4 <timer1_init2>:

void timer1_init2(void)
{
	TCNT1H = 0x00;
     3f4:	1d bc       	out	0x2d, r1	; 45
	TCNT1L = 0x00;
     3f6:	1c bc       	out	0x2c, r1	; 44
	OCR1AH = 0x00;
     3f8:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = 0x00;
     3fa:	1a bc       	out	0x2a, r1	; 42
	OCR1BH = 0x00;
     3fc:	19 bc       	out	0x29, r1	; 41
	OCR1BL = 0x00;
     3fe:	18 bc       	out	0x28, r1	; 40
	TCCR1A = 0x00;
     400:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0x01; //at clock frequency
     402:	81 e0       	ldi	r24, 0x01	; 1
     404:	8e bd       	out	0x2e, r24	; 46
	TIMSK = 0x20;
     406:	80 e2       	ldi	r24, 0x20	; 32
     408:	89 bf       	out	0x39, r24	; 57
}
     40a:	08 95       	ret

0000040c <filter_red>:
/////////////////////////////////////////////////////////////////////
//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTC = PORTC & 0xBF; //set S2 low
     40c:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 low
     40e:	af 98       	cbi	0x15, 7	; 21
}
     410:	08 95       	ret

00000412 <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTC= PORTC | 0x40; //set S2 High
     412:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
     414:	af 9a       	sbi	0x15, 7	; 21
}
     416:	08 95       	ret

00000418 <filter_blue>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTC = PORTC & 0xBF; //set S2 low
     418:	ae 98       	cbi	0x15, 6	; 21
	PORTC = PORTC | 0x80; //set S3 High
     41a:	af 9a       	sbi	0x15, 7	; 21
}
     41c:	08 95       	ret

0000041e <filter_clear>:

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
 	PORTC = PORTC | 0x40; //set S2 High
     41e:	ae 9a       	sbi	0x15, 6	; 21
	PORTC = PORTC & 0x7F; //set S3 Low
     420:	af 98       	cbi	0x15, 7	; 21
}
     422:	08 95       	ret

00000424 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTC = PORTC | 0x10; //set S0 high
     424:	ac 9a       	sbi	0x15, 4	; 21
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTC = PORTC | 0x20; //set S1 high
     426:	ad 9a       	sbi	0x15, 5	; 21
}
     428:	08 95       	ret

0000042a <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
     42a:	0e 94 06 02 	call	0x40c	; 0x40c <filter_red>
	pulse=0; //reset the count to 0
     42e:	10 92 86 00 	sts	0x0086, r1
     432:	10 92 87 00 	sts	0x0087, r1
     436:	10 92 88 00 	sts	0x0088, r1
     43a:	10 92 89 00 	sts	0x0089, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     43e:	8f ef       	ldi	r24, 0xFF	; 255
     440:	9f e3       	ldi	r25, 0x3F	; 63
     442:	a2 e0       	ldi	r26, 0x02	; 2
     444:	81 50       	subi	r24, 0x01	; 1
     446:	90 40       	sbci	r25, 0x00	; 0
     448:	a0 40       	sbci	r26, 0x00	; 0
     44a:	e1 f7       	brne	.-8      	; 0x444 <red_read+0x1a>
     44c:	00 c0       	rjmp	.+0      	; 0x44e <red_read+0x24>
     44e:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     450:	80 91 86 00 	lds	r24, 0x0086
     454:	90 91 87 00 	lds	r25, 0x0087
     458:	a0 91 88 00 	lds	r26, 0x0088
     45c:	b0 91 89 00 	lds	r27, 0x0089
     460:	80 93 a5 00 	sts	0x00A5, r24
     464:	90 93 a6 00 	sts	0x00A6, r25
     468:	a0 93 a7 00 	sts	0x00A7, r26
     46c:	b0 93 a8 00 	sts	0x00A8, r27
}
     470:	08 95       	ret

00000472 <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
     472:	0e 94 09 02 	call	0x412	; 0x412 <filter_green>
	pulse=0; //reset the count to 0
     476:	10 92 86 00 	sts	0x0086, r1
     47a:	10 92 87 00 	sts	0x0087, r1
     47e:	10 92 88 00 	sts	0x0088, r1
     482:	10 92 89 00 	sts	0x0089, r1
     486:	8f ef       	ldi	r24, 0xFF	; 255
     488:	9f e3       	ldi	r25, 0x3F	; 63
     48a:	a2 e0       	ldi	r26, 0x02	; 2
     48c:	81 50       	subi	r24, 0x01	; 1
     48e:	90 40       	sbci	r25, 0x00	; 0
     490:	a0 40       	sbci	r26, 0x00	; 0
     492:	e1 f7       	brne	.-8      	; 0x48c <green_read+0x1a>
     494:	00 c0       	rjmp	.+0      	; 0x496 <green_read+0x24>
     496:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
     498:	80 91 86 00 	lds	r24, 0x0086
     49c:	90 91 87 00 	lds	r25, 0x0087
     4a0:	a0 91 88 00 	lds	r26, 0x0088
     4a4:	b0 91 89 00 	lds	r27, 0x0089
     4a8:	80 93 a1 00 	sts	0x00A1, r24
     4ac:	90 93 a2 00 	sts	0x00A2, r25
     4b0:	a0 93 a3 00 	sts	0x00A3, r26
     4b4:	b0 93 a4 00 	sts	0x00A4, r27
}
     4b8:	08 95       	ret

000004ba <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
     4ba:	0e 94 0c 02 	call	0x418	; 0x418 <filter_blue>
	pulse=0; //reset the count to 0
     4be:	10 92 86 00 	sts	0x0086, r1
     4c2:	10 92 87 00 	sts	0x0087, r1
     4c6:	10 92 88 00 	sts	0x0088, r1
     4ca:	10 92 89 00 	sts	0x0089, r1
     4ce:	8f ef       	ldi	r24, 0xFF	; 255
     4d0:	9f e3       	ldi	r25, 0x3F	; 63
     4d2:	a2 e0       	ldi	r26, 0x02	; 2
     4d4:	81 50       	subi	r24, 0x01	; 1
     4d6:	90 40       	sbci	r25, 0x00	; 0
     4d8:	a0 40       	sbci	r26, 0x00	; 0
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <blue_read+0x1a>
     4dc:	00 c0       	rjmp	.+0      	; 0x4de <blue_read+0x24>
     4de:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
     4e0:	80 91 86 00 	lds	r24, 0x0086
     4e4:	90 91 87 00 	lds	r25, 0x0087
     4e8:	a0 91 88 00 	lds	r26, 0x0088
     4ec:	b0 91 89 00 	lds	r27, 0x0089
     4f0:	80 93 9a 00 	sts	0x009A, r24
     4f4:	90 93 9b 00 	sts	0x009B, r25
     4f8:	a0 93 9c 00 	sts	0x009C, r26
     4fc:	b0 93 9d 00 	sts	0x009D, r27
}
     500:	08 95       	ret

00000502 <colourDetect>:
{
	/*Blue-->0
	Red-->1
	Green-->2*/
	int colour;
	timer1_init2();
     502:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <timer1_init2>
	color_sensor_pin_interrupt_init();	
     506:	0e 94 cf 01 	call	0x39e	; 0x39e <color_sensor_pin_interrupt_init>
	color_sensor_pin_config();
     50a:	0e 94 c5 01 	call	0x38a	; 0x38a <color_sensor_pin_config>
	color_sensor_scaling();
     50e:	0e 94 12 02 	call	0x424	; 0x424 <color_sensor_scaling>
	
		red_read(); //display the pulse count when red filter is selected
     512:	0e 94 15 02 	call	0x42a	; 0x42a <red_read>
		green_read(); //display the pulse count when green filter is selected
     516:	0e 94 39 02 	call	0x472	; 0x472 <green_read>
		blue_read(); //display the pulse count when blue filter is selected	
     51a:	0e 94 5d 02 	call	0x4ba	; 0x4ba <blue_read>
		
	if((blue>green)&&(blue>red))
     51e:	80 91 9a 00 	lds	r24, 0x009A
     522:	90 91 9b 00 	lds	r25, 0x009B
     526:	a0 91 9c 00 	lds	r26, 0x009C
     52a:	b0 91 9d 00 	lds	r27, 0x009D
     52e:	40 91 a1 00 	lds	r20, 0x00A1
     532:	50 91 a2 00 	lds	r21, 0x00A2
     536:	60 91 a3 00 	lds	r22, 0x00A3
     53a:	70 91 a4 00 	lds	r23, 0x00A4
     53e:	48 17       	cp	r20, r24
     540:	59 07       	cpc	r21, r25
     542:	6a 07       	cpc	r22, r26
     544:	7b 07       	cpc	r23, r27
     546:	d0 f4       	brcc	.+52     	; 0x57c <colourDetect+0x7a>
     548:	40 91 a5 00 	lds	r20, 0x00A5
     54c:	50 91 a6 00 	lds	r21, 0x00A6
     550:	60 91 a7 00 	lds	r22, 0x00A7
     554:	70 91 a8 00 	lds	r23, 0x00A8
     558:	48 17       	cp	r20, r24
     55a:	59 07       	cpc	r21, r25
     55c:	6a 07       	cpc	r22, r26
     55e:	7b 07       	cpc	r23, r27
     560:	68 f4       	brcc	.+26     	; 0x57c <colourDetect+0x7a>
	{
		colour=0;
		buzzer_on();
     562:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
		PORTC |= 0b00000001;
     566:	a8 9a       	sbi	0x15, 0	; 21
     568:	8f ef       	ldi	r24, 0xFF	; 255
     56a:	9f e7       	ldi	r25, 0x7F	; 127
     56c:	a6 e1       	ldi	r26, 0x16	; 22
     56e:	81 50       	subi	r24, 0x01	; 1
     570:	90 40       	sbci	r25, 0x00	; 0
     572:	a0 40       	sbci	r26, 0x00	; 0
     574:	e1 f7       	brne	.-8      	; 0x56e <colourDetect+0x6c>
     576:	00 c0       	rjmp	.+0      	; 0x578 <colourDetect+0x76>
     578:	00 00       	nop
		_delay_ms(1000);
		PORTC &= 0b11111110;
     57a:	a8 98       	cbi	0x15, 0	; 21
		
	}
	if((red>green)&&(red>blue))
     57c:	80 91 a5 00 	lds	r24, 0x00A5
     580:	90 91 a6 00 	lds	r25, 0x00A6
     584:	a0 91 a7 00 	lds	r26, 0x00A7
     588:	b0 91 a8 00 	lds	r27, 0x00A8
     58c:	40 91 a1 00 	lds	r20, 0x00A1
     590:	50 91 a2 00 	lds	r21, 0x00A2
     594:	60 91 a3 00 	lds	r22, 0x00A3
     598:	70 91 a4 00 	lds	r23, 0x00A4
     59c:	48 17       	cp	r20, r24
     59e:	59 07       	cpc	r21, r25
     5a0:	6a 07       	cpc	r22, r26
     5a2:	7b 07       	cpc	r23, r27
     5a4:	d0 f4       	brcc	.+52     	; 0x5da <colourDetect+0xd8>
     5a6:	40 91 9a 00 	lds	r20, 0x009A
     5aa:	50 91 9b 00 	lds	r21, 0x009B
     5ae:	60 91 9c 00 	lds	r22, 0x009C
     5b2:	70 91 9d 00 	lds	r23, 0x009D
     5b6:	48 17       	cp	r20, r24
     5b8:	59 07       	cpc	r21, r25
     5ba:	6a 07       	cpc	r22, r26
     5bc:	7b 07       	cpc	r23, r27
     5be:	68 f4       	brcc	.+26     	; 0x5da <colourDetect+0xd8>
	{
		colour=1;
		buzzer_off();
     5c0:	0e 94 4b 00 	call	0x96	; 0x96 <buzzer_off>
		PORTC |= 0b00000100;
     5c4:	aa 9a       	sbi	0x15, 2	; 21
     5c6:	8f ef       	ldi	r24, 0xFF	; 255
     5c8:	9f e7       	ldi	r25, 0x7F	; 127
     5ca:	a6 e1       	ldi	r26, 0x16	; 22
     5cc:	81 50       	subi	r24, 0x01	; 1
     5ce:	90 40       	sbci	r25, 0x00	; 0
     5d0:	a0 40       	sbci	r26, 0x00	; 0
     5d2:	e1 f7       	brne	.-8      	; 0x5cc <colourDetect+0xca>
     5d4:	00 c0       	rjmp	.+0      	; 0x5d6 <colourDetect+0xd4>
     5d6:	00 00       	nop
		_delay_ms(1000);
		PORTC &= 0b11111011;
     5d8:	aa 98       	cbi	0x15, 2	; 21
	}
	if((green>red)&&(green>blue))
     5da:	80 91 a1 00 	lds	r24, 0x00A1
     5de:	90 91 a2 00 	lds	r25, 0x00A2
     5e2:	a0 91 a3 00 	lds	r26, 0x00A3
     5e6:	b0 91 a4 00 	lds	r27, 0x00A4
     5ea:	40 91 a5 00 	lds	r20, 0x00A5
     5ee:	50 91 a6 00 	lds	r21, 0x00A6
     5f2:	60 91 a7 00 	lds	r22, 0x00A7
     5f6:	70 91 a8 00 	lds	r23, 0x00A8
     5fa:	48 17       	cp	r20, r24
     5fc:	59 07       	cpc	r21, r25
     5fe:	6a 07       	cpc	r22, r26
     600:	7b 07       	cpc	r23, r27
     602:	d0 f4       	brcc	.+52     	; 0x638 <colourDetect+0x136>
     604:	40 91 9a 00 	lds	r20, 0x009A
     608:	50 91 9b 00 	lds	r21, 0x009B
     60c:	60 91 9c 00 	lds	r22, 0x009C
     610:	70 91 9d 00 	lds	r23, 0x009D
     614:	48 17       	cp	r20, r24
     616:	59 07       	cpc	r21, r25
     618:	6a 07       	cpc	r22, r26
     61a:	7b 07       	cpc	r23, r27
     61c:	68 f4       	brcc	.+26     	; 0x638 <colourDetect+0x136>
	{
		colour=2;
		buzzer_on();
     61e:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
		PORTC |= 0b00000010;
     622:	a9 9a       	sbi	0x15, 1	; 21
     624:	8f ef       	ldi	r24, 0xFF	; 255
     626:	9f e7       	ldi	r25, 0x7F	; 127
     628:	a6 e1       	ldi	r26, 0x16	; 22
     62a:	81 50       	subi	r24, 0x01	; 1
     62c:	90 40       	sbci	r25, 0x00	; 0
     62e:	a0 40       	sbci	r26, 0x00	; 0
     630:	e1 f7       	brne	.-8      	; 0x62a <colourDetect+0x128>
     632:	00 c0       	rjmp	.+0      	; 0x634 <colourDetect+0x132>
     634:	00 00       	nop
		_delay_ms(1000);
		PORTC &= 0b11111101;
     636:	a9 98       	cbi	0x15, 1	; 21
     638:	08 95       	ret

0000063a <plantDetect>:
	}
}


int plantDetect(int flag)
{
     63a:	cf 93       	push	r28
     63c:	df 93       	push	r29
     63e:	ec 01       	movw	r28, r24
	int val;
	float volts;
	adc_init();
     640:	0e 94 c7 00 	call	0x18e	; 0x18e <adc_init>
	adc_pin_config();
     644:	0e 94 b4 00 	call	0x168	; 0x168 <adc_pin_config>
	val=ADC_Conversion(2);
     648:	82 e0       	ldi	r24, 0x02	; 2
     64a:	0e 94 cf 00 	call	0x19e	; 0x19e <ADC_Conversion>
	volts=val*0.0196078431;
     64e:	68 2f       	mov	r22, r24
     650:	70 e0       	ldi	r23, 0x00	; 0
     652:	80 e0       	ldi	r24, 0x00	; 0
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	0e 94 26 08 	call	0x104c	; 0x104c <__floatsisf>
     65a:	21 ea       	ldi	r18, 0xA1	; 161
     65c:	30 ea       	ldi	r19, 0xA0	; 160
     65e:	40 ea       	ldi	r20, 0xA0	; 160
     660:	5c e3       	ldi	r21, 0x3C	; 60
     662:	0e 94 b2 08 	call	0x1164	; 0x1164 <__mulsf3>
     666:	9b 01       	movw	r18, r22
     668:	ac 01       	movw	r20, r24
	int distance = 13*pow(volts, -1);
     66a:	60 e0       	ldi	r22, 0x00	; 0
     66c:	70 e0       	ldi	r23, 0x00	; 0
     66e:	80 e8       	ldi	r24, 0x80	; 128
     670:	9f e3       	ldi	r25, 0x3F	; 63
     672:	0e 94 8b 07 	call	0xf16	; 0xf16 <__divsf3>
     676:	20 e0       	ldi	r18, 0x00	; 0
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	40 e5       	ldi	r20, 0x50	; 80
     67c:	51 e4       	ldi	r21, 0x41	; 65
     67e:	0e 94 b2 08 	call	0x1164	; 0x1164 <__mulsf3>
     682:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <__fixsfsi>
     686:	dc 01       	movw	r26, r24
     688:	cb 01       	movw	r24, r22
	if(distance<6 && flag == 0)
     68a:	86 30       	cpi	r24, 0x06	; 6
     68c:	91 05       	cpc	r25, r1
     68e:	3c f4       	brge	.+14     	; 0x69e <plantDetect+0x64>
		PORTC &= 0b11111101;
	}
}


int plantDetect(int flag)
     690:	81 e0       	ldi	r24, 0x01	; 1
     692:	90 e0       	ldi	r25, 0x00	; 0
     694:	20 97       	sbiw	r28, 0x00	; 0
     696:	29 f0       	breq	.+10     	; 0x6a2 <plantDetect+0x68>
     698:	80 e0       	ldi	r24, 0x00	; 0
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	02 c0       	rjmp	.+4      	; 0x6a2 <plantDetect+0x68>
	if(distance<6 && flag == 0)
		{
			flag = 1;
			return 1;
		}
	return 0; 
     69e:	80 e0       	ldi	r24, 0x00	; 0
     6a0:	90 e0       	ldi	r25, 0x00	; 0
}
     6a2:	df 91       	pop	r29
     6a4:	cf 91       	pop	r28
     6a6:	08 95       	ret

000006a8 <buzzer_pin_config>:
int plant_number = 3;
int toSend[3];
//Buzzer Configurations
void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     6a8:	a3 9a       	sbi	0x14, 3	; 20
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     6aa:	ab 98       	cbi	0x15, 3	; 21
}
     6ac:	08 95       	ret

000006ae <readSensor>:


//Line Follower 

void readSensor()
{
     6ae:	cf 93       	push	r28
     6b0:	df 93       	push	r29
	highcurrent=0;
     6b2:	10 92 71 00 	sts	0x0071, r1
     6b6:	10 92 70 00 	sts	0x0070, r1
	highcount=0;
     6ba:	10 92 73 00 	sts	0x0073, r1
     6be:	10 92 72 00 	sts	0x0072, r1
	sensor(0,th[0],avg[0]);
     6c2:	c8 ed       	ldi	r28, 0xD8	; 216
     6c4:	d0 e0       	ldi	r29, 0x00	; 0
     6c6:	60 91 78 00 	lds	r22, 0x0078
     6ca:	70 91 79 00 	lds	r23, 0x0079
     6ce:	40 91 68 00 	lds	r20, 0x0068
     6d2:	50 91 69 00 	lds	r21, 0x0069
     6d6:	80 e0       	ldi	r24, 0x00	; 0
     6d8:	90 e0       	ldi	r25, 0x00	; 0
     6da:	fe 01       	movw	r30, r28
     6dc:	09 95       	icall
	sensor(1,th[1],avg[1]);
     6de:	60 91 7a 00 	lds	r22, 0x007A
     6e2:	70 91 7b 00 	lds	r23, 0x007B
     6e6:	40 91 6a 00 	lds	r20, 0x006A
     6ea:	50 91 6b 00 	lds	r21, 0x006B
     6ee:	81 e0       	ldi	r24, 0x01	; 1
     6f0:	90 e0       	ldi	r25, 0x00	; 0
     6f2:	fe 01       	movw	r30, r28
     6f4:	09 95       	icall
	sensor(2,th[2],avg[2]);
     6f6:	60 91 7c 00 	lds	r22, 0x007C
     6fa:	70 91 7d 00 	lds	r23, 0x007D
     6fe:	40 91 6c 00 	lds	r20, 0x006C
     702:	50 91 6d 00 	lds	r21, 0x006D
     706:	82 e0       	ldi	r24, 0x02	; 2
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	fe 01       	movw	r30, r28
     70c:	09 95       	icall
	if(th[1]==1){PORTC |= 0b00000010;}	
	else if(th[1]==0){PORTC &= 0b11111101;}
	if(th[2] == 1){PORTC |= 0b00000100;}
	else if(th[2] == 1){PORTC &= 0b11111011;}*/
	
}
     70e:	df 91       	pop	r29
     710:	cf 91       	pop	r28
     712:	08 95       	ret

00000714 <proportional>:
		th[n]=0;
	}
	//lcd_print(1, 3-n, th[n], 1);
}
void proportional()
{
     714:	cf 92       	push	r12
     716:	df 92       	push	r13
     718:	ef 92       	push	r14
     71a:	ff 92       	push	r15
	error = ((double)highcurrent/highcount)-target;
     71c:	60 91 70 00 	lds	r22, 0x0070
     720:	70 91 71 00 	lds	r23, 0x0071
     724:	88 27       	eor	r24, r24
     726:	77 fd       	sbrc	r23, 7
     728:	80 95       	com	r24
     72a:	98 2f       	mov	r25, r24
     72c:	0e 94 26 08 	call	0x104c	; 0x104c <__floatsisf>
     730:	6b 01       	movw	r12, r22
     732:	7c 01       	movw	r14, r24
     734:	60 91 72 00 	lds	r22, 0x0072
     738:	70 91 73 00 	lds	r23, 0x0073
     73c:	88 27       	eor	r24, r24
     73e:	77 fd       	sbrc	r23, 7
     740:	80 95       	com	r24
     742:	98 2f       	mov	r25, r24
     744:	0e 94 26 08 	call	0x104c	; 0x104c <__floatsisf>
     748:	9b 01       	movw	r18, r22
     74a:	ac 01       	movw	r20, r24
     74c:	c7 01       	movw	r24, r14
     74e:	b6 01       	movw	r22, r12
     750:	0e 94 8b 07 	call	0xf16	; 0xf16 <__divsf3>
     754:	6b 01       	movw	r12, r22
     756:	7c 01       	movw	r14, r24
     758:	60 91 66 00 	lds	r22, 0x0066
     75c:	70 91 67 00 	lds	r23, 0x0067
     760:	88 27       	eor	r24, r24
     762:	77 fd       	sbrc	r23, 7
     764:	80 95       	com	r24
     766:	98 2f       	mov	r25, r24
     768:	0e 94 26 08 	call	0x104c	; 0x104c <__floatsisf>
     76c:	9b 01       	movw	r18, r22
     76e:	ac 01       	movw	r20, r24
     770:	c7 01       	movw	r24, r14
     772:	b6 01       	movw	r22, r12
     774:	0e 94 26 07 	call	0xe4c	; 0xe4c <__subsf3>
     778:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <__fixsfsi>
     77c:	ab 01       	movw	r20, r22
     77e:	bc 01       	movw	r22, r24
     780:	ca 01       	movw	r24, r20
     782:	50 93 77 00 	sts	0x0077, r21
     786:	40 93 76 00 	sts	0x0076, r20
	p=(kp*error);
     78a:	40 91 64 00 	lds	r20, 0x0064
     78e:	50 91 65 00 	lds	r21, 0x0065
     792:	84 9f       	mul	r24, r20
     794:	90 01       	movw	r18, r0
     796:	85 9f       	mul	r24, r21
     798:	30 0d       	add	r19, r0
     79a:	94 9f       	mul	r25, r20
     79c:	30 0d       	add	r19, r0
     79e:	11 24       	eor	r1, r1
     7a0:	30 93 75 00 	sts	0x0075, r19
     7a4:	20 93 74 00 	sts	0x0074, r18
	if(th[0]==0 && th[1]==0 && th[2]==0)
     7a8:	80 91 78 00 	lds	r24, 0x0078
     7ac:	90 91 79 00 	lds	r25, 0x0079
     7b0:	00 97       	sbiw	r24, 0x00	; 0
     7b2:	81 f4       	brne	.+32     	; 0x7d4 <proportional+0xc0>
     7b4:	80 91 7a 00 	lds	r24, 0x007A
     7b8:	90 91 7b 00 	lds	r25, 0x007B
     7bc:	00 97       	sbiw	r24, 0x00	; 0
     7be:	51 f4       	brne	.+20     	; 0x7d4 <proportional+0xc0>
     7c0:	80 91 7c 00 	lds	r24, 0x007C
     7c4:	90 91 7d 00 	lds	r25, 0x007D
     7c8:	00 97       	sbiw	r24, 0x00	; 0
     7ca:	21 f4       	brne	.+8      	; 0x7d4 <proportional+0xc0>
	{
		p=0;
     7cc:	10 92 75 00 	sts	0x0075, r1
     7d0:	10 92 74 00 	sts	0x0074, r1
	}
}
     7d4:	ff 90       	pop	r15
     7d6:	ef 90       	pop	r14
     7d8:	df 90       	pop	r13
     7da:	cf 90       	pop	r12
     7dc:	08 95       	ret

000007de <port_init>:
//Line Follower Ends


void port_init()
{
	buzzer_pin_config();
     7de:	0e 94 54 03 	call	0x6a8	; 0x6a8 <buzzer_pin_config>
	//lcd_port_config();
	adc_pin_config();
     7e2:	0e 94 b4 00 	call	0x168	; 0x168 <adc_pin_config>
	motion_pin_config();
     7e6:	0e 94 4d 00 	call	0x9a	; 0x9a <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
     7ea:	0e 94 15 01 	call	0x22a	; 0x22a <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
     7ee:	0e 94 18 01 	call	0x230	; 0x230 <right_encoder_pin_config>
}
     7f2:	08 95       	ret

000007f4 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
	PortBRestore = PORTB; 			// reading the PORTB's original status
     7f4:	98 b3       	in	r25, 0x18	; 24
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
     7f6:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
	unsigned char PortBRestore = 0;

	Direction &= 0x0F; 			// removing upper nibbel as it is not needed
     7f8:	8f 70       	andi	r24, 0x0F	; 15
	PortBRestore = PORTB; 			// reading the PORTB's original status
	PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
	PortBRestore |= Direction; 	// adding lower nibbel for direction command and restoring the PORTB status
     7fa:	98 2b       	or	r25, r24
	PORTB = PortBRestore; 			// setting the command to the port
     7fc:	98 bb       	out	0x18, r25	; 24
}
     7fe:	08 95       	ret

00000800 <stop>:
	motion_set(0x08);
}

void stop (void)
{
	motion_set(0x00);
     800:	80 e0       	ldi	r24, 0x00	; 0
     802:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <motion_set>
}
     806:	08 95       	ret

00000808 <init_devices>:
	PORTB = PortBRestore; 			// setting the command to the port
}

void init_devices (void)
{
	cli(); //Clears the global interrupts
     808:	f8 94       	cli
	port_init();
     80a:	0e 94 ef 03 	call	0x7de	; 0x7de <port_init>
	adc_init();
     80e:	0e 94 c7 00 	call	0x18e	; 0x18e <adc_init>
	timer1_init();
     812:	0e 94 b7 00 	call	0x16e	; 0x16e <timer1_init>
	uart0_init();
     816:	0e 94 5a 00 	call	0xb4	; 0xb4 <uart0_init>
	left_position_encoder_interrupt_init();
     81a:	0e 94 1b 01 	call	0x236	; 0x236 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     81e:	0e 94 24 01 	call	0x248	; 0x248 <right_position_encoder_interrupt_init>
	
	uart0_init();
     822:	0e 94 5a 00 	call	0xb4	; 0xb4 <uart0_init>
	sei();   //Enables the global interrupts
     826:	78 94       	sei
}
     828:	08 95       	ret

0000082a <forward>:


//Movement Configs
void forward (void) //both wheels forward
{
	motion_set(0x06);
     82a:	86 e0       	ldi	r24, 0x06	; 6
     82c:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <motion_set>
}
     830:	08 95       	ret

00000832 <back>:

void back (void) //both wheels backward
{
	motion_set(0x09);
     832:	89 e0       	ldi	r24, 0x09	; 9
     834:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <motion_set>
}
     838:	08 95       	ret

0000083a <linear_distance_mm>:
}


//Function used for moving robot forward by specified distance
void linear_distance_mm(unsigned int DistanceInMM, int sign, char purpose)
{
     83a:	9f 92       	push	r9
     83c:	af 92       	push	r10
     83e:	bf 92       	push	r11
     840:	cf 92       	push	r12
     842:	df 92       	push	r13
     844:	ef 92       	push	r14
     846:	ff 92       	push	r15
     848:	0f 93       	push	r16
     84a:	1f 93       	push	r17
     84c:	cf 93       	push	r28
     84e:	df 93       	push	r29
     850:	eb 01       	movw	r28, r22
     852:	94 2e       	mov	r9, r20
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0, pendingShaftCount = 0;
	int plant_trigger=0;
	ReqdShaftCount = DistanceInMM / 12.92; // division by resolution to get shaft count
     854:	bc 01       	movw	r22, r24
     856:	80 e0       	ldi	r24, 0x00	; 0
     858:	90 e0       	ldi	r25, 0x00	; 0
     85a:	0e 94 24 08 	call	0x1048	; 0x1048 <__floatunsisf>
     85e:	22 e5       	ldi	r18, 0x52	; 82
     860:	38 eb       	ldi	r19, 0xB8	; 184
     862:	4e e4       	ldi	r20, 0x4E	; 78
     864:	51 e4       	ldi	r21, 0x41	; 65
     866:	0e 94 8b 07 	call	0xf16	; 0xf16 <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     86a:	0e 94 f8 07 	call	0xff0	; 0xff0 <__fixunssfsi>
     86e:	c6 2e       	mov	r12, r22
     870:	d7 2e       	mov	r13, r23
     872:	e8 2e       	mov	r14, r24
     874:	f9 2e       	mov	r15, r25
	
	ShaftCountRight = 0;
     876:	10 92 8a 00 	sts	0x008A, r1
     87a:	10 92 8b 00 	sts	0x008B, r1
     87e:	10 92 8c 00 	sts	0x008C, r1
     882:	10 92 8d 00 	sts	0x008D, r1
		readSensor();
		proportional();	
		
		if(sign > 0){forward();}
		else if(sign < 0){ back();}		
		velocity(baseLine+p,baseLine-p);	
     886:	02 e6       	ldi	r16, 0x62	; 98
     888:	10 e0       	ldi	r17, 0x00	; 0
     88a:	0f 2e       	mov	r0, r31
     88c:	f4 e7       	ldi	r31, 0x74	; 116
     88e:	af 2e       	mov	r10, r31
     890:	f0 e0       	ldi	r31, 0x00	; 0
     892:	bf 2e       	mov	r11, r31
     894:	f0 2d       	mov	r31, r0
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
	
	ShaftCountRight = 0;
	while(1)
	{		
		readSensor();
     896:	0e 94 57 03 	call	0x6ae	; 0x6ae <readSensor>
		proportional();	
     89a:	0e 94 8a 03 	call	0x714	; 0x714 <proportional>
		
		if(sign > 0){forward();}
     89e:	1c 16       	cp	r1, r28
     8a0:	1d 06       	cpc	r1, r29
     8a2:	1c f4       	brge	.+6      	; 0x8aa <linear_distance_mm+0x70>
     8a4:	0e 94 15 04 	call	0x82a	; 0x82a <forward>
     8a8:	04 c0       	rjmp	.+8      	; 0x8b2 <linear_distance_mm+0x78>
		else if(sign < 0){ back();}		
     8aa:	dd 23       	and	r29, r29
     8ac:	14 f4       	brge	.+4      	; 0x8b2 <linear_distance_mm+0x78>
     8ae:	0e 94 19 04 	call	0x832	; 0x832 <back>
		velocity(baseLine+p,baseLine-p);	
     8b2:	d8 01       	movw	r26, r16
     8b4:	8c 91       	ld	r24, X
     8b6:	f5 01       	movw	r30, r10
     8b8:	90 81       	ld	r25, Z
     8ba:	68 2f       	mov	r22, r24
     8bc:	69 1b       	sub	r22, r25
     8be:	89 0f       	add	r24, r25
     8c0:	0e 94 10 01 	call	0x220	; 0x220 <velocity>
		plant_trigger = plantDetect(0);
     8c4:	80 e0       	ldi	r24, 0x00	; 0
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	0e 94 1d 03 	call	0x63a	; 0x63a <plantDetect>
		if(plant_trigger == 1){
     8cc:	81 30       	cpi	r24, 0x01	; 1
     8ce:	91 05       	cpc	r25, r1
     8d0:	b1 f5       	brne	.+108    	; 0x93e <linear_distance_mm+0x104>
			velocity(0, 0);
     8d2:	80 e0       	ldi	r24, 0x00	; 0
     8d4:	60 e0       	ldi	r22, 0x00	; 0
     8d6:	0e 94 10 01 	call	0x220	; 0x220 <velocity>
			pendingShaftCount = ReqdShaftCountInt - ShaftCountRight;
     8da:	80 91 8a 00 	lds	r24, 0x008A
     8de:	90 91 8b 00 	lds	r25, 0x008B
     8e2:	a0 91 8c 00 	lds	r26, 0x008C
     8e6:	b0 91 8d 00 	lds	r27, 0x008D
			if(purpose == 'S'){ 	
     8ea:	f3 e5       	ldi	r31, 0x53	; 83
     8ec:	9f 16       	cp	r9, r31
     8ee:	c9 f4       	brne	.+50     	; 0x922 <linear_distance_mm+0xe8>
				buzzer_on();	
     8f0:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
     8f4:	8f ef       	ldi	r24, 0xFF	; 255
     8f6:	9f e7       	ldi	r25, 0x7F	; 127
     8f8:	a6 e1       	ldi	r26, 0x16	; 22
     8fa:	81 50       	subi	r24, 0x01	; 1
     8fc:	90 40       	sbci	r25, 0x00	; 0
     8fe:	a0 40       	sbci	r26, 0x00	; 0
     900:	e1 f7       	brne	.-8      	; 0x8fa <linear_distance_mm+0xc0>
     902:	00 c0       	rjmp	.+0      	; 0x904 <linear_distance_mm+0xca>
     904:	00 00       	nop
				_delay_ms(1000);
				buzzer_off();
     906:	0e 94 4b 00 	call	0x96	; 0x96 <buzzer_off>
				forward();
     90a:	0e 94 15 04 	call	0x82a	; 0x82a <forward>
     90e:	8f ef       	ldi	r24, 0xFF	; 255
     910:	9f ef       	ldi	r25, 0xFF	; 255
     912:	ac e2       	ldi	r26, 0x2C	; 44
     914:	81 50       	subi	r24, 0x01	; 1
     916:	90 40       	sbci	r25, 0x00	; 0
     918:	a0 40       	sbci	r26, 0x00	; 0
     91a:	e1 f7       	brne	.-8      	; 0x914 <linear_distance_mm+0xda>
     91c:	00 c0       	rjmp	.+0      	; 0x91e <linear_distance_mm+0xe4>
     91e:	00 00       	nop
     920:	0e c0       	rjmp	.+28     	; 0x93e <linear_distance_mm+0x104>
					current_Y = y_D;
					update(color, current_X, current_Y, face);
				}				
				//timer1_init();
			}
			else if(purpose == 'W'){
     922:	97 e5       	ldi	r25, 0x57	; 87
     924:	99 16       	cp	r9, r25
     926:	59 f4       	brne	.+22     	; 0x93e <linear_distance_mm+0x104>
				buzzer_on();
     928:	0e 94 49 00 	call	0x92	; 0x92 <buzzer_on>
     92c:	8f ef       	ldi	r24, 0xFF	; 255
     92e:	9f e7       	ldi	r25, 0x7F	; 127
     930:	a3 e4       	ldi	r26, 0x43	; 67
     932:	81 50       	subi	r24, 0x01	; 1
     934:	90 40       	sbci	r25, 0x00	; 0
     936:	a0 40       	sbci	r26, 0x00	; 0
     938:	e1 f7       	brne	.-8      	; 0x932 <linear_distance_mm+0xf8>
     93a:	00 c0       	rjmp	.+0      	; 0x93c <linear_distance_mm+0x102>
     93c:	00 00       	nop
				_delay_ms(3000);
				//servoAction();				
			} 
		}
		if(ShaftCountRight > ReqdShaftCountInt)
     93e:	80 91 8a 00 	lds	r24, 0x008A
     942:	90 91 8b 00 	lds	r25, 0x008B
     946:	a0 91 8c 00 	lds	r26, 0x008C
     94a:	b0 91 8d 00 	lds	r27, 0x008D
     94e:	c8 16       	cp	r12, r24
     950:	d9 06       	cpc	r13, r25
     952:	ea 06       	cpc	r14, r26
     954:	fb 06       	cpc	r15, r27
     956:	08 f0       	brcs	.+2      	; 0x95a <linear_distance_mm+0x120>
     958:	9e cf       	rjmp	.-196    	; 0x896 <linear_distance_mm+0x5c>
		{
			break; 
		}
	}
	stop(); //Stop robot
     95a:	0e 94 00 04 	call	0x800	; 0x800 <stop>
}
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	ff 90       	pop	r15
     968:	ef 90       	pop	r14
     96a:	df 90       	pop	r13
     96c:	cf 90       	pop	r12
     96e:	bf 90       	pop	r11
     970:	af 90       	pop	r10
     972:	9f 90       	pop	r9
     974:	08 95       	ret

00000976 <left>:
	motion_set(0x09);
}

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
     976:	85 e0       	ldi	r24, 0x05	; 5
     978:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <motion_set>
}
     97c:	08 95       	ret

0000097e <right>:

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
     97e:	8a e0       	ldi	r24, 0x0A	; 10
     980:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <motion_set>
}
     984:	08 95       	ret

00000986 <soft_left>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
	motion_set(0x04);
     986:	84 e0       	ldi	r24, 0x04	; 4
     988:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <motion_set>
}
     98c:	08 95       	ret

0000098e <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
	motion_set(0x02);
     98e:	82 e0       	ldi	r24, 0x02	; 2
     990:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <motion_set>
}
     994:	08 95       	ret

00000996 <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set(0x01);
     996:	81 e0       	ldi	r24, 0x01	; 1
     998:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <motion_set>
}
     99c:	08 95       	ret

0000099e <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set(0x08);
     99e:	88 e0       	ldi	r24, 0x08	; 8
     9a0:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <motion_set>
}
     9a4:	08 95       	ret

000009a6 <forward_mm>:
{
	motion_set(0x00);
}

void forward_mm(unsigned int DistanceInMM, char purpose)
{
     9a6:	46 2f       	mov	r20, r22
	
	linear_distance_mm(DistanceInMM, 1, purpose);
     9a8:	61 e0       	ldi	r22, 0x01	; 1
     9aa:	70 e0       	ldi	r23, 0x00	; 0
     9ac:	50 e0       	ldi	r21, 0x00	; 0
     9ae:	0e 94 1d 04 	call	0x83a	; 0x83a <linear_distance_mm>
}
     9b2:	08 95       	ret

000009b4 <back_mm>:

void back_mm(unsigned int DistanceInMM, char purpose)
{
     9b4:	46 2f       	mov	r20, r22
	linear_distance_mm(DistanceInMM, -1, purpose);
     9b6:	6f ef       	ldi	r22, 0xFF	; 255
     9b8:	7f ef       	ldi	r23, 0xFF	; 255
     9ba:	50 e0       	ldi	r21, 0x00	; 0
     9bc:	0e 94 1d 04 	call	0x83a	; 0x83a <linear_distance_mm>
}
     9c0:	08 95       	ret

000009c2 <left_degrees>:

//Rotation Configs


void left_degrees(unsigned int Degrees)
{
     9c2:	cf 93       	push	r28
     9c4:	df 93       	push	r29
     9c6:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
     9c8:	0e 94 bb 04 	call	0x976	; 0x976 <left>
	angle_rotate(Degrees);
     9cc:	ce 01       	movw	r24, r28
     9ce:	0e 94 77 01 	call	0x2ee	; 0x2ee <angle_rotate>
}
     9d2:	df 91       	pop	r29
     9d4:	cf 91       	pop	r28
     9d6:	08 95       	ret

000009d8 <right_degrees>:



void right_degrees(unsigned int Degrees)
{
     9d8:	cf 93       	push	r28
     9da:	df 93       	push	r29
     9dc:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right(); //Turn right
     9de:	0e 94 bf 04 	call	0x97e	; 0x97e <right>
	angle_rotate(Degrees);
     9e2:	ce 01       	movw	r24, r28
     9e4:	0e 94 77 01 	call	0x2ee	; 0x2ee <angle_rotate>
}
     9e8:	df 91       	pop	r29
     9ea:	cf 91       	pop	r28
     9ec:	08 95       	ret

000009ee <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
     9ee:	cf 93       	push	r28
     9f0:	df 93       	push	r29
     9f2:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
     9f4:	0e 94 c3 04 	call	0x986	; 0x986 <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     9f8:	ce 01       	movw	r24, r28
     9fa:	88 0f       	add	r24, r24
     9fc:	99 1f       	adc	r25, r25
     9fe:	0e 94 77 01 	call	0x2ee	; 0x2ee <angle_rotate>
}
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	08 95       	ret

00000a08 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     a08:	cf 93       	push	r28
     a0a:	df 93       	push	r29
     a0c:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
     a0e:	0e 94 c7 04 	call	0x98e	; 0x98e <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     a12:	ce 01       	movw	r24, r28
     a14:	88 0f       	add	r24, r24
     a16:	99 1f       	adc	r25, r25
     a18:	0e 94 77 01 	call	0x2ee	; 0x2ee <angle_rotate>
}
     a1c:	df 91       	pop	r29
     a1e:	cf 91       	pop	r28
     a20:	08 95       	ret

00000a22 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     a22:	cf 93       	push	r28
     a24:	df 93       	push	r29
     a26:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
     a28:	0e 94 cb 04 	call	0x996	; 0x996 <soft_left_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     a2c:	ce 01       	movw	r24, r28
     a2e:	88 0f       	add	r24, r24
     a30:	99 1f       	adc	r25, r25
     a32:	0e 94 77 01 	call	0x2ee	; 0x2ee <angle_rotate>
}
     a36:	df 91       	pop	r29
     a38:	cf 91       	pop	r28
     a3a:	08 95       	ret

00000a3c <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     a3c:	cf 93       	push	r28
     a3e:	df 93       	push	r29
     a40:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2();  //Turn reverse soft right
     a42:	0e 94 cf 04 	call	0x99e	; 0x99e <soft_right_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     a46:	ce 01       	movw	r24, r28
     a48:	88 0f       	add	r24, r24
     a4a:	99 1f       	adc	r25, r25
     a4c:	0e 94 77 01 	call	0x2ee	; 0x2ee <angle_rotate>
}
     a50:	df 91       	pop	r29
     a52:	cf 91       	pop	r28
     a54:	08 95       	ret

00000a56 <manoeuvre>:

void manoeuvre(int x_F, int y_F,char dir_F){
	int x_origin = 4;
	int y_origin = 'D';	
	
	int x_middle = x_F - x_origin;
     a56:	9c 01       	movw	r18, r24
     a58:	24 50       	subi	r18, 0x04	; 4
     a5a:	30 40       	sbci	r19, 0x00	; 0
	int y_middle = y_F - y_origin;
     a5c:	64 54       	subi	r22, 0x44	; 68
     a5e:	70 40       	sbci	r23, 0x00	; 0
	
	//For determining the final destination x-coordinate
	if( (x_middle) > 0 ){ x_D = 7; }
     a60:	12 16       	cp	r1, r18
     a62:	13 06       	cpc	r1, r19
     a64:	3c f4       	brge	.+14     	; 0xa74 <manoeuvre+0x1e>
     a66:	87 e0       	ldi	r24, 0x07	; 7
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	90 93 81 00 	sts	0x0081, r25
     a6e:	80 93 80 00 	sts	0x0080, r24
     a72:	06 c0       	rjmp	.+12     	; 0xa80 <manoeuvre+0x2a>
	else { x_D = 1; }
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	90 e0       	ldi	r25, 0x00	; 0
     a78:	90 93 81 00 	sts	0x0081, r25
     a7c:	80 93 80 00 	sts	0x0080, r24
	int x_intermediate = x_D - x_origin;
     a80:	80 91 80 00 	lds	r24, 0x0080
     a84:	90 91 81 00 	lds	r25, 0x0081
     a88:	fc 01       	movw	r30, r24
     a8a:	34 97       	sbiw	r30, 0x04	; 4
	
	//For determining the final destination y-coordinate	
	if((y_middle) > 0){ y_D = 'F'; }	
     a8c:	16 16       	cp	r1, r22
     a8e:	17 06       	cpc	r1, r23
     a90:	3c f4       	brge	.+14     	; 0xaa0 <manoeuvre+0x4a>
     a92:	86 e4       	ldi	r24, 0x46	; 70
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	90 93 7f 00 	sts	0x007F, r25
     a9a:	80 93 7e 00 	sts	0x007E, r24
     a9e:	10 c0       	rjmp	.+32     	; 0xac0 <manoeuvre+0x6a>
	else if((y_middle) == 0){ y_D = 'D'; }
     aa0:	61 15       	cp	r22, r1
     aa2:	71 05       	cpc	r23, r1
     aa4:	39 f4       	brne	.+14     	; 0xab4 <manoeuvre+0x5e>
     aa6:	84 e4       	ldi	r24, 0x44	; 68
     aa8:	90 e0       	ldi	r25, 0x00	; 0
     aaa:	90 93 7f 00 	sts	0x007F, r25
     aae:	80 93 7e 00 	sts	0x007E, r24
     ab2:	06 c0       	rjmp	.+12     	; 0xac0 <manoeuvre+0x6a>
	else { y_D = 'B'; } 
     ab4:	82 e4       	ldi	r24, 0x42	; 66
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	90 93 7f 00 	sts	0x007F, r25
     abc:	80 93 7e 00 	sts	0x007E, r24
	int y_intermediate = y_D - y_origin;	
     ac0:	80 91 7e 00 	lds	r24, 0x007E
     ac4:	90 91 7f 00 	lds	r25, 0x007F
     ac8:	84 54       	subi	r24, 0x44	; 68
     aca:	90 40       	sbci	r25, 0x00	; 0
	
	//How much to manoeuvre
	vertical = 	x_middle - x_intermediate;
     acc:	2e 1b       	sub	r18, r30
     ace:	3f 0b       	sbc	r19, r31
     ad0:	30 93 85 00 	sts	0x0085, r19
     ad4:	20 93 84 00 	sts	0x0084, r18
	horizontal = y_middle - y_intermediate;
     ad8:	68 1b       	sub	r22, r24
     ada:	79 0b       	sbc	r23, r25
     adc:	70 93 83 00 	sts	0x0083, r23
     ae0:	60 93 82 00 	sts	0x0082, r22
	direction = dir_F;	
     ae4:	40 93 aa 00 	sts	0x00AA, r20
}
     ae8:	08 95       	ret

00000aea <rotate>:

void rotate(char face){
	switch(direction){
     aea:	90 91 aa 00 	lds	r25, 0x00AA
     aee:	9e 34       	cpi	r25, 0x4E	; 78
     af0:	61 f0       	breq	.+24     	; 0xb0a <rotate+0x20>
     af2:	9f 34       	cpi	r25, 0x4F	; 79
     af4:	20 f4       	brcc	.+8      	; 0xafe <rotate+0x14>
     af6:	95 34       	cpi	r25, 0x45	; 69
     af8:	09 f0       	breq	.+2      	; 0xafc <rotate+0x12>
     afa:	5b c0       	rjmp	.+182    	; 0xbb2 <rotate+0xc8>
     afc:	46 c0       	rjmp	.+140    	; 0xb8a <rotate+0xa0>
     afe:	93 35       	cpi	r25, 0x53	; 83
     b00:	79 f1       	breq	.+94     	; 0xb60 <rotate+0x76>
     b02:	97 35       	cpi	r25, 0x57	; 87
     b04:	09 f0       	breq	.+2      	; 0xb08 <rotate+0x1e>
     b06:	55 c0       	rjmp	.+170    	; 0xbb2 <rotate+0xc8>
     b08:	16 c0       	rjmp	.+44     	; 0xb36 <rotate+0x4c>
		case 'N':{
			if(face == 'S'){right_degrees(180);}
     b0a:	83 35       	cpi	r24, 0x53	; 83
     b0c:	29 f4       	brne	.+10     	; 0xb18 <rotate+0x2e>
     b0e:	84 eb       	ldi	r24, 0xB4	; 180
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <right_degrees>
     b16:	08 95       	ret
			else if(face == 'E'){right_degrees(90);}
     b18:	85 34       	cpi	r24, 0x45	; 69
     b1a:	29 f4       	brne	.+10     	; 0xb26 <rotate+0x3c>
     b1c:	8a e5       	ldi	r24, 0x5A	; 90
     b1e:	90 e0       	ldi	r25, 0x00	; 0
     b20:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <right_degrees>
     b24:	08 95       	ret
			else if(face == 'W'){left_degrees(90);}
     b26:	87 35       	cpi	r24, 0x57	; 87
     b28:	09 f0       	breq	.+2      	; 0xb2c <rotate+0x42>
     b2a:	43 c0       	rjmp	.+134    	; 0xbb2 <rotate+0xc8>
     b2c:	8a e5       	ldi	r24, 0x5A	; 90
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <left_degrees>
     b34:	08 95       	ret
				break;
		}
		case 'W':{
			if(face == 'S'){left_degrees(90);}
     b36:	83 35       	cpi	r24, 0x53	; 83
     b38:	29 f4       	brne	.+10     	; 0xb44 <rotate+0x5a>
     b3a:	8a e5       	ldi	r24, 0x5A	; 90
     b3c:	90 e0       	ldi	r25, 0x00	; 0
     b3e:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <left_degrees>
     b42:	08 95       	ret
			else if(face == 'E'){right_degrees(180);}
     b44:	85 34       	cpi	r24, 0x45	; 69
     b46:	29 f4       	brne	.+10     	; 0xb52 <rotate+0x68>
     b48:	84 eb       	ldi	r24, 0xB4	; 180
     b4a:	90 e0       	ldi	r25, 0x00	; 0
     b4c:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <right_degrees>
     b50:	08 95       	ret
			else if(face == 'N'){right_degrees(90);}
     b52:	8e 34       	cpi	r24, 0x4E	; 78
     b54:	71 f5       	brne	.+92     	; 0xbb2 <rotate+0xc8>
     b56:	8a e5       	ldi	r24, 0x5A	; 90
     b58:	90 e0       	ldi	r25, 0x00	; 0
     b5a:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <right_degrees>
     b5e:	08 95       	ret
				break;
		}
		case 'S':{
			if(face == 'N'){right_degrees(180);}
     b60:	8e 34       	cpi	r24, 0x4E	; 78
     b62:	29 f4       	brne	.+10     	; 0xb6e <rotate+0x84>
     b64:	84 eb       	ldi	r24, 0xB4	; 180
     b66:	90 e0       	ldi	r25, 0x00	; 0
     b68:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <right_degrees>
     b6c:	08 95       	ret
			else if(face == 'W'){right_degrees(90);}
     b6e:	87 35       	cpi	r24, 0x57	; 87
     b70:	29 f4       	brne	.+10     	; 0xb7c <rotate+0x92>
     b72:	8a e5       	ldi	r24, 0x5A	; 90
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <right_degrees>
     b7a:	08 95       	ret
			else if(face == 'E'){left_degrees(90);}
     b7c:	85 34       	cpi	r24, 0x45	; 69
     b7e:	c9 f4       	brne	.+50     	; 0xbb2 <rotate+0xc8>
     b80:	8a e5       	ldi	r24, 0x5A	; 90
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <left_degrees>
     b88:	08 95       	ret
				break;
		}
		case 'E':{
			if(face == 'W'){right_degrees(180);}
     b8a:	87 35       	cpi	r24, 0x57	; 87
     b8c:	29 f4       	brne	.+10     	; 0xb98 <rotate+0xae>
     b8e:	84 eb       	ldi	r24, 0xB4	; 180
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <right_degrees>
     b96:	08 95       	ret
			else if(face == 'S'){right_degrees(90);}
     b98:	83 35       	cpi	r24, 0x53	; 83
     b9a:	29 f4       	brne	.+10     	; 0xba6 <rotate+0xbc>
     b9c:	8a e5       	ldi	r24, 0x5A	; 90
     b9e:	90 e0       	ldi	r25, 0x00	; 0
     ba0:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <right_degrees>
     ba4:	08 95       	ret
			else if(face == 'N'){left_degrees(90);}
     ba6:	8e 34       	cpi	r24, 0x4E	; 78
     ba8:	21 f4       	brne	.+8      	; 0xbb2 <rotate+0xc8>
     baa:	8a e5       	ldi	r24, 0x5A	; 90
     bac:	90 e0       	ldi	r25, 0x00	; 0
     bae:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <left_degrees>
     bb2:	08 95       	ret

00000bb4 <vertical_motion>:
	}
}

void vertical_motion(){
	
	if(vertical < 0){ 
     bb4:	80 91 84 00 	lds	r24, 0x0084
     bb8:	90 91 85 00 	lds	r25, 0x0085
     bbc:	99 23       	and	r25, r25
     bbe:	24 f4       	brge	.+8      	; 0xbc8 <vertical_motion+0x14>
		face = 'S';
     bc0:	83 e5       	ldi	r24, 0x53	; 83
     bc2:	80 93 99 00 	sts	0x0099, r24
     bc6:	03 c0       	rjmp	.+6      	; 0xbce <vertical_motion+0x1a>
	}
	else{
		face = 'N';
     bc8:	8e e4       	ldi	r24, 0x4E	; 78
     bca:	80 93 99 00 	sts	0x0099, r24
	}
	rotate(face);
     bce:	80 91 99 00 	lds	r24, 0x0099
     bd2:	0e 94 75 05 	call	0xaea	; 0xaea <rotate>
	direction = face;	
     bd6:	80 91 99 00 	lds	r24, 0x0099
     bda:	80 93 aa 00 	sts	0x00AA, r24
	vertical = abs(vertical);
     bde:	20 91 84 00 	lds	r18, 0x0084
     be2:	30 91 85 00 	lds	r19, 0x0085
     be6:	33 23       	and	r19, r19
     be8:	1c f4       	brge	.+6      	; 0xbf0 <vertical_motion+0x3c>
     bea:	30 95       	com	r19
     bec:	21 95       	neg	r18
     bee:	3f 4f       	sbci	r19, 0xFF	; 255
     bf0:	30 93 85 00 	sts	0x0085, r19
     bf4:	20 93 84 00 	sts	0x0084, r18
	//lcd_print(1,3, vertical, 3);
	
	forward_mm(vertical * 340, 'R');
     bf8:	84 e5       	ldi	r24, 0x54	; 84
     bfa:	91 e0       	ldi	r25, 0x01	; 1
     bfc:	ac 01       	movw	r20, r24
     bfe:	24 9f       	mul	r18, r20
     c00:	c0 01       	movw	r24, r0
     c02:	25 9f       	mul	r18, r21
     c04:	90 0d       	add	r25, r0
     c06:	34 9f       	mul	r19, r20
     c08:	90 0d       	add	r25, r0
     c0a:	11 24       	eor	r1, r1
     c0c:	62 e5       	ldi	r22, 0x52	; 82
     c0e:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <forward_mm>
	
}
     c12:	08 95       	ret

00000c14 <horizontal_motion>:
void horizontal_motion(){
	
	if(horizontal < 0){ 
     c14:	80 91 82 00 	lds	r24, 0x0082
     c18:	90 91 83 00 	lds	r25, 0x0083
     c1c:	99 23       	and	r25, r25
     c1e:	24 f4       	brge	.+8      	; 0xc28 <horizontal_motion+0x14>
		face = 'E';
     c20:	85 e4       	ldi	r24, 0x45	; 69
     c22:	80 93 99 00 	sts	0x0099, r24
     c26:	03 c0       	rjmp	.+6      	; 0xc2e <horizontal_motion+0x1a>
	}
	else{
		face = 'W';
     c28:	87 e5       	ldi	r24, 0x57	; 87
     c2a:	80 93 99 00 	sts	0x0099, r24
	}
	rotate(face);
     c2e:	80 91 99 00 	lds	r24, 0x0099
     c32:	0e 94 75 05 	call	0xaea	; 0xaea <rotate>
	direction = face;
     c36:	80 91 99 00 	lds	r24, 0x0099
     c3a:	80 93 aa 00 	sts	0x00AA, r24
	horizontal = abs(horizontal);
     c3e:	20 91 82 00 	lds	r18, 0x0082
     c42:	30 91 83 00 	lds	r19, 0x0083
     c46:	33 23       	and	r19, r19
     c48:	1c f4       	brge	.+6      	; 0xc50 <horizontal_motion+0x3c>
     c4a:	30 95       	com	r19
     c4c:	21 95       	neg	r18
     c4e:	3f 4f       	sbci	r19, 0xFF	; 255
     c50:	30 93 83 00 	sts	0x0083, r19
     c54:	20 93 82 00 	sts	0x0082, r18
	forward_mm(horizontal * 340, 'R');
     c58:	84 e5       	ldi	r24, 0x54	; 84
     c5a:	91 e0       	ldi	r25, 0x01	; 1
     c5c:	ac 01       	movw	r20, r24
     c5e:	24 9f       	mul	r18, r20
     c60:	c0 01       	movw	r24, r0
     c62:	25 9f       	mul	r18, r21
     c64:	90 0d       	add	r25, r0
     c66:	34 9f       	mul	r19, r20
     c68:	90 0d       	add	r25, r0
     c6a:	11 24       	eor	r1, r1
     c6c:	62 e5       	ldi	r22, 0x52	; 82
     c6e:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <forward_mm>
}
     c72:	08 95       	ret

00000c74 <scan>:


void scan(int nodes){
     c74:	8f 92       	push	r8
     c76:	9f 92       	push	r9
     c78:	af 92       	push	r10
     c7a:	bf 92       	push	r11
     c7c:	cf 92       	push	r12
     c7e:	df 92       	push	r13
     c80:	ef 92       	push	r14
     c82:	ff 92       	push	r15
     c84:	0f 93       	push	r16
     c86:	1f 93       	push	r17
     c88:	cf 93       	push	r28
     c8a:	df 93       	push	r29
			x_D = 1;
		}
		rotate(face);
		direction = face;
		_delay_ms(1000);
		forward_mm(((nodes-1) * 340), 'S');
     c8c:	9c 01       	movw	r18, r24
     c8e:	21 50       	subi	r18, 0x01	; 1
     c90:	30 40       	sbci	r19, 0x00	; 0
     c92:	84 e5       	ldi	r24, 0x54	; 84
     c94:	91 e0       	ldi	r25, 0x01	; 1
     c96:	28 9f       	mul	r18, r24
     c98:	70 01       	movw	r14, r0
     c9a:	29 9f       	mul	r18, r25
     c9c:	f0 0c       	add	r15, r0
     c9e:	38 9f       	mul	r19, r24
     ca0:	f0 0c       	add	r15, r0
     ca2:	11 24       	eor	r1, r1
     ca4:	c2 e0       	ldi	r28, 0x02	; 2
     ca6:	d0 e0       	ldi	r29, 0x00	; 0
		if(x_D == 1){
			face = 'S';
			x_D = 7; 
		}
		else if(x_D == 7){
			face = 'N';
     ca8:	0e e4       	ldi	r16, 0x4E	; 78
			x_D = 1;
     caa:	aa 24       	eor	r10, r10
     cac:	bb 24       	eor	r11, r11
     cae:	a3 94       	inc	r10


void scan(int nodes){
	for(int i=0;i<2;i++){	
		if(x_D == 1){
			face = 'S';
     cb0:	13 e5       	ldi	r17, 0x53	; 83
			x_D = 7; 
     cb2:	0f 2e       	mov	r0, r31
     cb4:	f7 e0       	ldi	r31, 0x07	; 7
     cb6:	cf 2e       	mov	r12, r31
     cb8:	dd 24       	eor	r13, r13
     cba:	f0 2d       	mov	r31, r0
		direction = face;
		_delay_ms(1000);
		forward_mm(((nodes-1) * 340), 'S');
		_delay_ms(1000);
		if(ReceivedByte == 'E'){
		transmit_findings(toSend);
     cbc:	0f 2e       	mov	r0, r31
     cbe:	fb ea       	ldi	r31, 0xAB	; 171
     cc0:	8f 2e       	mov	r8, r31
     cc2:	f0 e0       	ldi	r31, 0x00	; 0
     cc4:	9f 2e       	mov	r9, r31
     cc6:	f0 2d       	mov	r31, r0
}


void scan(int nodes){
	for(int i=0;i<2;i++){	
		if(x_D == 1){
     cc8:	80 91 80 00 	lds	r24, 0x0080
     ccc:	90 91 81 00 	lds	r25, 0x0081
     cd0:	81 30       	cpi	r24, 0x01	; 1
     cd2:	91 05       	cpc	r25, r1
     cd4:	39 f4       	brne	.+14     	; 0xce4 <scan+0x70>
			face = 'S';
     cd6:	10 93 99 00 	sts	0x0099, r17
			x_D = 7; 
     cda:	d0 92 81 00 	sts	0x0081, r13
     cde:	c0 92 80 00 	sts	0x0080, r12
     ce2:	09 c0       	rjmp	.+18     	; 0xcf6 <scan+0x82>
		}
		else if(x_D == 7){
     ce4:	87 30       	cpi	r24, 0x07	; 7
     ce6:	91 05       	cpc	r25, r1
     ce8:	31 f4       	brne	.+12     	; 0xcf6 <scan+0x82>
			face = 'N';
     cea:	00 93 99 00 	sts	0x0099, r16
			x_D = 1;
     cee:	b0 92 81 00 	sts	0x0081, r11
     cf2:	a0 92 80 00 	sts	0x0080, r10
		}
		rotate(face);
     cf6:	80 91 99 00 	lds	r24, 0x0099
     cfa:	0e 94 75 05 	call	0xaea	; 0xaea <rotate>
		direction = face;
     cfe:	80 91 99 00 	lds	r24, 0x0099
     d02:	80 93 aa 00 	sts	0x00AA, r24
     d06:	8f ef       	ldi	r24, 0xFF	; 255
     d08:	9f e7       	ldi	r25, 0x7F	; 127
     d0a:	a6 e1       	ldi	r26, 0x16	; 22
     d0c:	81 50       	subi	r24, 0x01	; 1
     d0e:	90 40       	sbci	r25, 0x00	; 0
     d10:	a0 40       	sbci	r26, 0x00	; 0
     d12:	e1 f7       	brne	.-8      	; 0xd0c <scan+0x98>
     d14:	00 c0       	rjmp	.+0      	; 0xd16 <scan+0xa2>
     d16:	00 00       	nop
		_delay_ms(1000);
		forward_mm(((nodes-1) * 340), 'S');
     d18:	c7 01       	movw	r24, r14
     d1a:	61 2f       	mov	r22, r17
     d1c:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <forward_mm>
     d20:	8f ef       	ldi	r24, 0xFF	; 255
     d22:	9f e7       	ldi	r25, 0x7F	; 127
     d24:	a6 e1       	ldi	r26, 0x16	; 22
     d26:	81 50       	subi	r24, 0x01	; 1
     d28:	90 40       	sbci	r25, 0x00	; 0
     d2a:	a0 40       	sbci	r26, 0x00	; 0
     d2c:	e1 f7       	brne	.-8      	; 0xd26 <scan+0xb2>
     d2e:	00 c0       	rjmp	.+0      	; 0xd30 <scan+0xbc>
     d30:	00 00       	nop
		_delay_ms(1000);
		if(ReceivedByte == 'E'){
     d32:	80 91 9e 00 	lds	r24, 0x009E
     d36:	85 34       	cpi	r24, 0x45	; 69
     d38:	19 f4       	brne	.+6      	; 0xd40 <scan+0xcc>
		transmit_findings(toSend);
     d3a:	c4 01       	movw	r24, r8
     d3c:	0e 94 b2 06 	call	0xd64	; 0xd64 <transmit_findings>
     d40:	21 97       	sbiw	r28, 0x01	; 1
	forward_mm(horizontal * 340, 'R');
}


void scan(int nodes){
	for(int i=0;i<2;i++){	
     d42:	11 f6       	brne	.-124    	; 0xcc8 <scan+0x54>
		if(ReceivedByte == 'E'){
		transmit_findings(toSend);
		}		
	}
			
}
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	ff 90       	pop	r15
     d4e:	ef 90       	pop	r14
     d50:	df 90       	pop	r13
     d52:	cf 90       	pop	r12
     d54:	bf 90       	pop	r11
     d56:	af 90       	pop	r10
     d58:	9f 90       	pop	r9
     d5a:	8f 90       	pop	r8
     d5c:	08 95       	ret

00000d5e <transmit>:

transmit(int grid_number){
	//char v = (device_id*100)+grid_number;
	USART_Transmit(grid_number);
     d5e:	0e 94 62 00 	call	0xc4	; 0xc4 <USART_Transmit>
}
     d62:	08 95       	ret

00000d64 <transmit_findings>:


void transmit_findings(int array[]){
     d64:	cf 93       	push	r28
     d66:	df 93       	push	r29
     d68:	ec 01       	movw	r28, r24
	transmit(65);
     d6a:	81 e4       	ldi	r24, 0x41	; 65
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	0e 94 af 06 	call	0xd5e	; 0xd5e <transmit>
	for (int i=0;i<sizeof(array);i++){
		transmit(array[i]);
     d72:	88 81       	ld	r24, Y
     d74:	99 81       	ldd	r25, Y+1	; 0x01
     d76:	0e 94 af 06 	call	0xd5e	; 0xd5e <transmit>
     d7a:	8a 81       	ldd	r24, Y+2	; 0x02
     d7c:	9b 81       	ldd	r25, Y+3	; 0x03
     d7e:	0e 94 af 06 	call	0xd5e	; 0xd5e <transmit>
	}
	transmit(69);
     d82:	85 e4       	ldi	r24, 0x45	; 69
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	0e 94 af 06 	call	0xd5e	; 0xd5e <transmit>
}
     d8a:	df 91       	pop	r29
     d8c:	cf 91       	pop	r28
     d8e:	08 95       	ret

00000d90 <update>:



void update(int color, int current_X, char current_Y, char current_Direction){
     d90:	dc 01       	movw	r26, r24
	int r = 0, g = 1, b = 2;
	int block;
	if(current_Direction = 'N'){
		current_X--;
	}
	block = ((current_X - 1)*6)+((int)current_Y - 64);
     d92:	62 50       	subi	r22, 0x02	; 2
     d94:	70 40       	sbci	r23, 0x00	; 0
     d96:	9b 01       	movw	r18, r22
     d98:	22 0f       	add	r18, r18
     d9a:	33 1f       	adc	r19, r19
     d9c:	62 0f       	add	r22, r18
     d9e:	73 1f       	adc	r23, r19
     da0:	66 0f       	add	r22, r22
     da2:	77 1f       	adc	r23, r23
     da4:	50 e0       	ldi	r21, 0x00	; 0
     da6:	40 54       	subi	r20, 0x40	; 64
     da8:	50 40       	sbci	r21, 0x00	; 0
     daa:	46 0f       	add	r20, r22
     dac:	57 1f       	adc	r21, r23
	global_array[block - 1] = color;
     dae:	fa 01       	movw	r30, r20
     db0:	ee 0f       	add	r30, r30
     db2:	ff 1f       	adc	r31, r31
     db4:	e1 55       	subi	r30, 0x51	; 81
     db6:	ff 4f       	sbci	r31, 0xFF	; 255
     db8:	91 83       	std	Z+1, r25	; 0x01
     dba:	80 83       	st	Z, r24
	if(plant_number>0){		
     dbc:	e0 91 60 00 	lds	r30, 0x0060
     dc0:	f0 91 61 00 	lds	r31, 0x0061
     dc4:	1e 16       	cp	r1, r30
     dc6:	1f 06       	cpc	r1, r31
     dc8:	b4 f4       	brge	.+44     	; 0xdf6 <update+0x66>
		toSend[--plant_number] = (color * 100) + block;
     dca:	31 97       	sbiw	r30, 0x01	; 1
     dcc:	f0 93 61 00 	sts	0x0061, r31
     dd0:	e0 93 60 00 	sts	0x0060, r30
     dd4:	ee 0f       	add	r30, r30
     dd6:	ff 1f       	adc	r31, r31
     dd8:	e5 55       	subi	r30, 0x55	; 85
     dda:	ff 4f       	sbci	r31, 0xFF	; 255
     ddc:	84 e6       	ldi	r24, 0x64	; 100
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	a8 9f       	mul	r26, r24
     de2:	90 01       	movw	r18, r0
     de4:	a9 9f       	mul	r26, r25
     de6:	30 0d       	add	r19, r0
     de8:	b8 9f       	mul	r27, r24
     dea:	30 0d       	add	r19, r0
     dec:	11 24       	eor	r1, r1
     dee:	24 0f       	add	r18, r20
     df0:	35 1f       	adc	r19, r21
     df2:	31 83       	std	Z+1, r19	; 0x01
     df4:	20 83       	st	Z, r18
     df6:	08 95       	ret

00000df8 <main>:
}

int main(void)
{	
	
	init_devices();		
     df8:	0e 94 04 04 	call	0x808	; 0x808 <init_devices>
		int x_F = 3;
		int y_F = 'C';
		char dir_F = 'E';
		
		//This function will set the nodes to travel in the vertical & horizontal direction for the bot to reach its standard spot
		manoeuvre(x_F, y_F, dir_F);	
     dfc:	83 e0       	ldi	r24, 0x03	; 3
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	63 e4       	ldi	r22, 0x43	; 67
     e02:	70 e0       	ldi	r23, 0x00	; 0
     e04:	45 e4       	ldi	r20, 0x45	; 69
     e06:	0e 94 2b 05 	call	0xa56	; 0xa56 <manoeuvre>
		
		//int grid_number = (vertical-1)*7) + (horizontal-64);
		//transmit(grid_number);
		
		vertical_motion();
     e0a:	0e 94 da 05 	call	0xbb4	; 0xbb4 <vertical_motion>
		stop();
     e0e:	0e 94 00 04 	call	0x800	; 0x800 <stop>
     e12:	8f ef       	ldi	r24, 0xFF	; 255
     e14:	9f e7       	ldi	r25, 0x7F	; 127
     e16:	a6 e1       	ldi	r26, 0x16	; 22
     e18:	81 50       	subi	r24, 0x01	; 1
     e1a:	90 40       	sbci	r25, 0x00	; 0
     e1c:	a0 40       	sbci	r26, 0x00	; 0
     e1e:	e1 f7       	brne	.-8      	; 0xe18 <main+0x20>
     e20:	00 c0       	rjmp	.+0      	; 0xe22 <main+0x2a>
     e22:	00 00       	nop
		_delay_ms(1000);
		horizontal_motion();
     e24:	0e 94 0a 06 	call	0xc14	; 0xc14 <horizontal_motion>
     e28:	8f ef       	ldi	r24, 0xFF	; 255
     e2a:	9f e7       	ldi	r25, 0x7F	; 127
     e2c:	a6 e1       	ldi	r26, 0x16	; 22
     e2e:	81 50       	subi	r24, 0x01	; 1
     e30:	90 40       	sbci	r25, 0x00	; 0
     e32:	a0 40       	sbci	r26, 0x00	; 0
     e34:	e1 f7       	brne	.-8      	; 0xe2e <main+0x36>
     e36:	00 c0       	rjmp	.+0      	; 0xe38 <main+0x40>
     e38:	00 00       	nop
		_delay_ms(1000);
		
		scan(STOPS);	
     e3a:	87 e0       	ldi	r24, 0x07	; 7
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	0e 94 3a 06 	call	0xc74	; 0xc74 <scan>
		stop();
     e42:	0e 94 00 04 	call	0x800	; 0x800 <stop>
		
		
		
		return 0;
     e46:	80 e0       	ldi	r24, 0x00	; 0
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	08 95       	ret

00000e4c <__subsf3>:
     e4c:	50 58       	subi	r21, 0x80	; 128

00000e4e <__addsf3>:
     e4e:	bb 27       	eor	r27, r27
     e50:	aa 27       	eor	r26, r26
     e52:	0e d0       	rcall	.+28     	; 0xe70 <__addsf3x>
     e54:	4d c1       	rjmp	.+666    	; 0x10f0 <__fp_round>
     e56:	3e d1       	rcall	.+636    	; 0x10d4 <__fp_pscA>
     e58:	30 f0       	brcs	.+12     	; 0xe66 <__addsf3+0x18>
     e5a:	43 d1       	rcall	.+646    	; 0x10e2 <__fp_pscB>
     e5c:	20 f0       	brcs	.+8      	; 0xe66 <__addsf3+0x18>
     e5e:	31 f4       	brne	.+12     	; 0xe6c <__addsf3+0x1e>
     e60:	9f 3f       	cpi	r25, 0xFF	; 255
     e62:	11 f4       	brne	.+4      	; 0xe68 <__addsf3+0x1a>
     e64:	1e f4       	brtc	.+6      	; 0xe6c <__addsf3+0x1e>
     e66:	33 c1       	rjmp	.+614    	; 0x10ce <__fp_nan>
     e68:	0e f4       	brtc	.+2      	; 0xe6c <__addsf3+0x1e>
     e6a:	e0 95       	com	r30
     e6c:	e7 fb       	bst	r30, 7
     e6e:	29 c1       	rjmp	.+594    	; 0x10c2 <__fp_inf>

00000e70 <__addsf3x>:
     e70:	e9 2f       	mov	r30, r25
     e72:	4f d1       	rcall	.+670    	; 0x1112 <__fp_split3>
     e74:	80 f3       	brcs	.-32     	; 0xe56 <__addsf3+0x8>
     e76:	ba 17       	cp	r27, r26
     e78:	62 07       	cpc	r22, r18
     e7a:	73 07       	cpc	r23, r19
     e7c:	84 07       	cpc	r24, r20
     e7e:	95 07       	cpc	r25, r21
     e80:	18 f0       	brcs	.+6      	; 0xe88 <__addsf3x+0x18>
     e82:	71 f4       	brne	.+28     	; 0xea0 <__addsf3x+0x30>
     e84:	9e f5       	brtc	.+102    	; 0xeec <__addsf3x+0x7c>
     e86:	67 c1       	rjmp	.+718    	; 0x1156 <__fp_zero>
     e88:	0e f4       	brtc	.+2      	; 0xe8c <__addsf3x+0x1c>
     e8a:	e0 95       	com	r30
     e8c:	0b 2e       	mov	r0, r27
     e8e:	ba 2f       	mov	r27, r26
     e90:	a0 2d       	mov	r26, r0
     e92:	0b 01       	movw	r0, r22
     e94:	b9 01       	movw	r22, r18
     e96:	90 01       	movw	r18, r0
     e98:	0c 01       	movw	r0, r24
     e9a:	ca 01       	movw	r24, r20
     e9c:	a0 01       	movw	r20, r0
     e9e:	11 24       	eor	r1, r1
     ea0:	ff 27       	eor	r31, r31
     ea2:	59 1b       	sub	r21, r25
     ea4:	99 f0       	breq	.+38     	; 0xecc <__addsf3x+0x5c>
     ea6:	59 3f       	cpi	r21, 0xF9	; 249
     ea8:	50 f4       	brcc	.+20     	; 0xebe <__addsf3x+0x4e>
     eaa:	50 3e       	cpi	r21, 0xE0	; 224
     eac:	68 f1       	brcs	.+90     	; 0xf08 <__addsf3x+0x98>
     eae:	1a 16       	cp	r1, r26
     eb0:	f0 40       	sbci	r31, 0x00	; 0
     eb2:	a2 2f       	mov	r26, r18
     eb4:	23 2f       	mov	r18, r19
     eb6:	34 2f       	mov	r19, r20
     eb8:	44 27       	eor	r20, r20
     eba:	58 5f       	subi	r21, 0xF8	; 248
     ebc:	f3 cf       	rjmp	.-26     	; 0xea4 <__addsf3x+0x34>
     ebe:	46 95       	lsr	r20
     ec0:	37 95       	ror	r19
     ec2:	27 95       	ror	r18
     ec4:	a7 95       	ror	r26
     ec6:	f0 40       	sbci	r31, 0x00	; 0
     ec8:	53 95       	inc	r21
     eca:	c9 f7       	brne	.-14     	; 0xebe <__addsf3x+0x4e>
     ecc:	7e f4       	brtc	.+30     	; 0xeec <__addsf3x+0x7c>
     ece:	1f 16       	cp	r1, r31
     ed0:	ba 0b       	sbc	r27, r26
     ed2:	62 0b       	sbc	r22, r18
     ed4:	73 0b       	sbc	r23, r19
     ed6:	84 0b       	sbc	r24, r20
     ed8:	ba f0       	brmi	.+46     	; 0xf08 <__addsf3x+0x98>
     eda:	91 50       	subi	r25, 0x01	; 1
     edc:	a1 f0       	breq	.+40     	; 0xf06 <__addsf3x+0x96>
     ede:	ff 0f       	add	r31, r31
     ee0:	bb 1f       	adc	r27, r27
     ee2:	66 1f       	adc	r22, r22
     ee4:	77 1f       	adc	r23, r23
     ee6:	88 1f       	adc	r24, r24
     ee8:	c2 f7       	brpl	.-16     	; 0xeda <__addsf3x+0x6a>
     eea:	0e c0       	rjmp	.+28     	; 0xf08 <__addsf3x+0x98>
     eec:	ba 0f       	add	r27, r26
     eee:	62 1f       	adc	r22, r18
     ef0:	73 1f       	adc	r23, r19
     ef2:	84 1f       	adc	r24, r20
     ef4:	48 f4       	brcc	.+18     	; 0xf08 <__addsf3x+0x98>
     ef6:	87 95       	ror	r24
     ef8:	77 95       	ror	r23
     efa:	67 95       	ror	r22
     efc:	b7 95       	ror	r27
     efe:	f7 95       	ror	r31
     f00:	9e 3f       	cpi	r25, 0xFE	; 254
     f02:	08 f0       	brcs	.+2      	; 0xf06 <__addsf3x+0x96>
     f04:	b3 cf       	rjmp	.-154    	; 0xe6c <__addsf3+0x1e>
     f06:	93 95       	inc	r25
     f08:	88 0f       	add	r24, r24
     f0a:	08 f0       	brcs	.+2      	; 0xf0e <__addsf3x+0x9e>
     f0c:	99 27       	eor	r25, r25
     f0e:	ee 0f       	add	r30, r30
     f10:	97 95       	ror	r25
     f12:	87 95       	ror	r24
     f14:	08 95       	ret

00000f16 <__divsf3>:
     f16:	0c d0       	rcall	.+24     	; 0xf30 <__divsf3x>
     f18:	eb c0       	rjmp	.+470    	; 0x10f0 <__fp_round>
     f1a:	e3 d0       	rcall	.+454    	; 0x10e2 <__fp_pscB>
     f1c:	40 f0       	brcs	.+16     	; 0xf2e <__divsf3+0x18>
     f1e:	da d0       	rcall	.+436    	; 0x10d4 <__fp_pscA>
     f20:	30 f0       	brcs	.+12     	; 0xf2e <__divsf3+0x18>
     f22:	21 f4       	brne	.+8      	; 0xf2c <__divsf3+0x16>
     f24:	5f 3f       	cpi	r21, 0xFF	; 255
     f26:	19 f0       	breq	.+6      	; 0xf2e <__divsf3+0x18>
     f28:	cc c0       	rjmp	.+408    	; 0x10c2 <__fp_inf>
     f2a:	51 11       	cpse	r21, r1
     f2c:	15 c1       	rjmp	.+554    	; 0x1158 <__fp_szero>
     f2e:	cf c0       	rjmp	.+414    	; 0x10ce <__fp_nan>

00000f30 <__divsf3x>:
     f30:	f0 d0       	rcall	.+480    	; 0x1112 <__fp_split3>
     f32:	98 f3       	brcs	.-26     	; 0xf1a <__divsf3+0x4>

00000f34 <__divsf3_pse>:
     f34:	99 23       	and	r25, r25
     f36:	c9 f3       	breq	.-14     	; 0xf2a <__divsf3+0x14>
     f38:	55 23       	and	r21, r21
     f3a:	b1 f3       	breq	.-20     	; 0xf28 <__divsf3+0x12>
     f3c:	95 1b       	sub	r25, r21
     f3e:	55 0b       	sbc	r21, r21
     f40:	bb 27       	eor	r27, r27
     f42:	aa 27       	eor	r26, r26
     f44:	62 17       	cp	r22, r18
     f46:	73 07       	cpc	r23, r19
     f48:	84 07       	cpc	r24, r20
     f4a:	38 f0       	brcs	.+14     	; 0xf5a <__divsf3_pse+0x26>
     f4c:	9f 5f       	subi	r25, 0xFF	; 255
     f4e:	5f 4f       	sbci	r21, 0xFF	; 255
     f50:	22 0f       	add	r18, r18
     f52:	33 1f       	adc	r19, r19
     f54:	44 1f       	adc	r20, r20
     f56:	aa 1f       	adc	r26, r26
     f58:	a9 f3       	breq	.-22     	; 0xf44 <__divsf3_pse+0x10>
     f5a:	33 d0       	rcall	.+102    	; 0xfc2 <__divsf3_pse+0x8e>
     f5c:	0e 2e       	mov	r0, r30
     f5e:	3a f0       	brmi	.+14     	; 0xf6e <__divsf3_pse+0x3a>
     f60:	e0 e8       	ldi	r30, 0x80	; 128
     f62:	30 d0       	rcall	.+96     	; 0xfc4 <__divsf3_pse+0x90>
     f64:	91 50       	subi	r25, 0x01	; 1
     f66:	50 40       	sbci	r21, 0x00	; 0
     f68:	e6 95       	lsr	r30
     f6a:	00 1c       	adc	r0, r0
     f6c:	ca f7       	brpl	.-14     	; 0xf60 <__divsf3_pse+0x2c>
     f6e:	29 d0       	rcall	.+82     	; 0xfc2 <__divsf3_pse+0x8e>
     f70:	fe 2f       	mov	r31, r30
     f72:	27 d0       	rcall	.+78     	; 0xfc2 <__divsf3_pse+0x8e>
     f74:	66 0f       	add	r22, r22
     f76:	77 1f       	adc	r23, r23
     f78:	88 1f       	adc	r24, r24
     f7a:	bb 1f       	adc	r27, r27
     f7c:	26 17       	cp	r18, r22
     f7e:	37 07       	cpc	r19, r23
     f80:	48 07       	cpc	r20, r24
     f82:	ab 07       	cpc	r26, r27
     f84:	b0 e8       	ldi	r27, 0x80	; 128
     f86:	09 f0       	breq	.+2      	; 0xf8a <__divsf3_pse+0x56>
     f88:	bb 0b       	sbc	r27, r27
     f8a:	80 2d       	mov	r24, r0
     f8c:	bf 01       	movw	r22, r30
     f8e:	ff 27       	eor	r31, r31
     f90:	93 58       	subi	r25, 0x83	; 131
     f92:	5f 4f       	sbci	r21, 0xFF	; 255
     f94:	2a f0       	brmi	.+10     	; 0xfa0 <__divsf3_pse+0x6c>
     f96:	9e 3f       	cpi	r25, 0xFE	; 254
     f98:	51 05       	cpc	r21, r1
     f9a:	68 f0       	brcs	.+26     	; 0xfb6 <__divsf3_pse+0x82>
     f9c:	92 c0       	rjmp	.+292    	; 0x10c2 <__fp_inf>
     f9e:	dc c0       	rjmp	.+440    	; 0x1158 <__fp_szero>
     fa0:	5f 3f       	cpi	r21, 0xFF	; 255
     fa2:	ec f3       	brlt	.-6      	; 0xf9e <__divsf3_pse+0x6a>
     fa4:	98 3e       	cpi	r25, 0xE8	; 232
     fa6:	dc f3       	brlt	.-10     	; 0xf9e <__divsf3_pse+0x6a>
     fa8:	86 95       	lsr	r24
     faa:	77 95       	ror	r23
     fac:	67 95       	ror	r22
     fae:	b7 95       	ror	r27
     fb0:	f7 95       	ror	r31
     fb2:	9f 5f       	subi	r25, 0xFF	; 255
     fb4:	c9 f7       	brne	.-14     	; 0xfa8 <__divsf3_pse+0x74>
     fb6:	88 0f       	add	r24, r24
     fb8:	91 1d       	adc	r25, r1
     fba:	96 95       	lsr	r25
     fbc:	87 95       	ror	r24
     fbe:	97 f9       	bld	r25, 7
     fc0:	08 95       	ret
     fc2:	e1 e0       	ldi	r30, 0x01	; 1
     fc4:	66 0f       	add	r22, r22
     fc6:	77 1f       	adc	r23, r23
     fc8:	88 1f       	adc	r24, r24
     fca:	bb 1f       	adc	r27, r27
     fcc:	62 17       	cp	r22, r18
     fce:	73 07       	cpc	r23, r19
     fd0:	84 07       	cpc	r24, r20
     fd2:	ba 07       	cpc	r27, r26
     fd4:	20 f0       	brcs	.+8      	; 0xfde <__divsf3_pse+0xaa>
     fd6:	62 1b       	sub	r22, r18
     fd8:	73 0b       	sbc	r23, r19
     fda:	84 0b       	sbc	r24, r20
     fdc:	ba 0b       	sbc	r27, r26
     fde:	ee 1f       	adc	r30, r30
     fe0:	88 f7       	brcc	.-30     	; 0xfc4 <__divsf3_pse+0x90>
     fe2:	e0 95       	com	r30
     fe4:	08 95       	ret

00000fe6 <__fixsfsi>:
     fe6:	04 d0       	rcall	.+8      	; 0xff0 <__fixunssfsi>
     fe8:	68 94       	set
     fea:	b1 11       	cpse	r27, r1
     fec:	b5 c0       	rjmp	.+362    	; 0x1158 <__fp_szero>
     fee:	08 95       	ret

00000ff0 <__fixunssfsi>:
     ff0:	98 d0       	rcall	.+304    	; 0x1122 <__fp_splitA>
     ff2:	88 f0       	brcs	.+34     	; 0x1016 <__fixunssfsi+0x26>
     ff4:	9f 57       	subi	r25, 0x7F	; 127
     ff6:	90 f0       	brcs	.+36     	; 0x101c <__fixunssfsi+0x2c>
     ff8:	b9 2f       	mov	r27, r25
     ffa:	99 27       	eor	r25, r25
     ffc:	b7 51       	subi	r27, 0x17	; 23
     ffe:	a0 f0       	brcs	.+40     	; 0x1028 <__fixunssfsi+0x38>
    1000:	d1 f0       	breq	.+52     	; 0x1036 <__fixunssfsi+0x46>
    1002:	66 0f       	add	r22, r22
    1004:	77 1f       	adc	r23, r23
    1006:	88 1f       	adc	r24, r24
    1008:	99 1f       	adc	r25, r25
    100a:	1a f0       	brmi	.+6      	; 0x1012 <__fixunssfsi+0x22>
    100c:	ba 95       	dec	r27
    100e:	c9 f7       	brne	.-14     	; 0x1002 <__fixunssfsi+0x12>
    1010:	12 c0       	rjmp	.+36     	; 0x1036 <__fixunssfsi+0x46>
    1012:	b1 30       	cpi	r27, 0x01	; 1
    1014:	81 f0       	breq	.+32     	; 0x1036 <__fixunssfsi+0x46>
    1016:	9f d0       	rcall	.+318    	; 0x1156 <__fp_zero>
    1018:	b1 e0       	ldi	r27, 0x01	; 1
    101a:	08 95       	ret
    101c:	9c c0       	rjmp	.+312    	; 0x1156 <__fp_zero>
    101e:	67 2f       	mov	r22, r23
    1020:	78 2f       	mov	r23, r24
    1022:	88 27       	eor	r24, r24
    1024:	b8 5f       	subi	r27, 0xF8	; 248
    1026:	39 f0       	breq	.+14     	; 0x1036 <__fixunssfsi+0x46>
    1028:	b9 3f       	cpi	r27, 0xF9	; 249
    102a:	cc f3       	brlt	.-14     	; 0x101e <__fixunssfsi+0x2e>
    102c:	86 95       	lsr	r24
    102e:	77 95       	ror	r23
    1030:	67 95       	ror	r22
    1032:	b3 95       	inc	r27
    1034:	d9 f7       	brne	.-10     	; 0x102c <__fixunssfsi+0x3c>
    1036:	3e f4       	brtc	.+14     	; 0x1046 <__fixunssfsi+0x56>
    1038:	90 95       	com	r25
    103a:	80 95       	com	r24
    103c:	70 95       	com	r23
    103e:	61 95       	neg	r22
    1040:	7f 4f       	sbci	r23, 0xFF	; 255
    1042:	8f 4f       	sbci	r24, 0xFF	; 255
    1044:	9f 4f       	sbci	r25, 0xFF	; 255
    1046:	08 95       	ret

00001048 <__floatunsisf>:
    1048:	e8 94       	clt
    104a:	09 c0       	rjmp	.+18     	; 0x105e <__floatsisf+0x12>

0000104c <__floatsisf>:
    104c:	97 fb       	bst	r25, 7
    104e:	3e f4       	brtc	.+14     	; 0x105e <__floatsisf+0x12>
    1050:	90 95       	com	r25
    1052:	80 95       	com	r24
    1054:	70 95       	com	r23
    1056:	61 95       	neg	r22
    1058:	7f 4f       	sbci	r23, 0xFF	; 255
    105a:	8f 4f       	sbci	r24, 0xFF	; 255
    105c:	9f 4f       	sbci	r25, 0xFF	; 255
    105e:	99 23       	and	r25, r25
    1060:	a9 f0       	breq	.+42     	; 0x108c <__floatsisf+0x40>
    1062:	f9 2f       	mov	r31, r25
    1064:	96 e9       	ldi	r25, 0x96	; 150
    1066:	bb 27       	eor	r27, r27
    1068:	93 95       	inc	r25
    106a:	f6 95       	lsr	r31
    106c:	87 95       	ror	r24
    106e:	77 95       	ror	r23
    1070:	67 95       	ror	r22
    1072:	b7 95       	ror	r27
    1074:	f1 11       	cpse	r31, r1
    1076:	f8 cf       	rjmp	.-16     	; 0x1068 <__floatsisf+0x1c>
    1078:	fa f4       	brpl	.+62     	; 0x10b8 <__floatsisf+0x6c>
    107a:	bb 0f       	add	r27, r27
    107c:	11 f4       	brne	.+4      	; 0x1082 <__floatsisf+0x36>
    107e:	60 ff       	sbrs	r22, 0
    1080:	1b c0       	rjmp	.+54     	; 0x10b8 <__floatsisf+0x6c>
    1082:	6f 5f       	subi	r22, 0xFF	; 255
    1084:	7f 4f       	sbci	r23, 0xFF	; 255
    1086:	8f 4f       	sbci	r24, 0xFF	; 255
    1088:	9f 4f       	sbci	r25, 0xFF	; 255
    108a:	16 c0       	rjmp	.+44     	; 0x10b8 <__floatsisf+0x6c>
    108c:	88 23       	and	r24, r24
    108e:	11 f0       	breq	.+4      	; 0x1094 <__floatsisf+0x48>
    1090:	96 e9       	ldi	r25, 0x96	; 150
    1092:	11 c0       	rjmp	.+34     	; 0x10b6 <__floatsisf+0x6a>
    1094:	77 23       	and	r23, r23
    1096:	21 f0       	breq	.+8      	; 0x10a0 <__floatsisf+0x54>
    1098:	9e e8       	ldi	r25, 0x8E	; 142
    109a:	87 2f       	mov	r24, r23
    109c:	76 2f       	mov	r23, r22
    109e:	05 c0       	rjmp	.+10     	; 0x10aa <__floatsisf+0x5e>
    10a0:	66 23       	and	r22, r22
    10a2:	71 f0       	breq	.+28     	; 0x10c0 <__floatsisf+0x74>
    10a4:	96 e8       	ldi	r25, 0x86	; 134
    10a6:	86 2f       	mov	r24, r22
    10a8:	70 e0       	ldi	r23, 0x00	; 0
    10aa:	60 e0       	ldi	r22, 0x00	; 0
    10ac:	2a f0       	brmi	.+10     	; 0x10b8 <__floatsisf+0x6c>
    10ae:	9a 95       	dec	r25
    10b0:	66 0f       	add	r22, r22
    10b2:	77 1f       	adc	r23, r23
    10b4:	88 1f       	adc	r24, r24
    10b6:	da f7       	brpl	.-10     	; 0x10ae <__floatsisf+0x62>
    10b8:	88 0f       	add	r24, r24
    10ba:	96 95       	lsr	r25
    10bc:	87 95       	ror	r24
    10be:	97 f9       	bld	r25, 7
    10c0:	08 95       	ret

000010c2 <__fp_inf>:
    10c2:	97 f9       	bld	r25, 7
    10c4:	9f 67       	ori	r25, 0x7F	; 127
    10c6:	80 e8       	ldi	r24, 0x80	; 128
    10c8:	70 e0       	ldi	r23, 0x00	; 0
    10ca:	60 e0       	ldi	r22, 0x00	; 0
    10cc:	08 95       	ret

000010ce <__fp_nan>:
    10ce:	9f ef       	ldi	r25, 0xFF	; 255
    10d0:	80 ec       	ldi	r24, 0xC0	; 192
    10d2:	08 95       	ret

000010d4 <__fp_pscA>:
    10d4:	00 24       	eor	r0, r0
    10d6:	0a 94       	dec	r0
    10d8:	16 16       	cp	r1, r22
    10da:	17 06       	cpc	r1, r23
    10dc:	18 06       	cpc	r1, r24
    10de:	09 06       	cpc	r0, r25
    10e0:	08 95       	ret

000010e2 <__fp_pscB>:
    10e2:	00 24       	eor	r0, r0
    10e4:	0a 94       	dec	r0
    10e6:	12 16       	cp	r1, r18
    10e8:	13 06       	cpc	r1, r19
    10ea:	14 06       	cpc	r1, r20
    10ec:	05 06       	cpc	r0, r21
    10ee:	08 95       	ret

000010f0 <__fp_round>:
    10f0:	09 2e       	mov	r0, r25
    10f2:	03 94       	inc	r0
    10f4:	00 0c       	add	r0, r0
    10f6:	11 f4       	brne	.+4      	; 0x10fc <__fp_round+0xc>
    10f8:	88 23       	and	r24, r24
    10fa:	52 f0       	brmi	.+20     	; 0x1110 <__fp_round+0x20>
    10fc:	bb 0f       	add	r27, r27
    10fe:	40 f4       	brcc	.+16     	; 0x1110 <__fp_round+0x20>
    1100:	bf 2b       	or	r27, r31
    1102:	11 f4       	brne	.+4      	; 0x1108 <__fp_round+0x18>
    1104:	60 ff       	sbrs	r22, 0
    1106:	04 c0       	rjmp	.+8      	; 0x1110 <__fp_round+0x20>
    1108:	6f 5f       	subi	r22, 0xFF	; 255
    110a:	7f 4f       	sbci	r23, 0xFF	; 255
    110c:	8f 4f       	sbci	r24, 0xFF	; 255
    110e:	9f 4f       	sbci	r25, 0xFF	; 255
    1110:	08 95       	ret

00001112 <__fp_split3>:
    1112:	57 fd       	sbrc	r21, 7
    1114:	90 58       	subi	r25, 0x80	; 128
    1116:	44 0f       	add	r20, r20
    1118:	55 1f       	adc	r21, r21
    111a:	59 f0       	breq	.+22     	; 0x1132 <__fp_splitA+0x10>
    111c:	5f 3f       	cpi	r21, 0xFF	; 255
    111e:	71 f0       	breq	.+28     	; 0x113c <__fp_splitA+0x1a>
    1120:	47 95       	ror	r20

00001122 <__fp_splitA>:
    1122:	88 0f       	add	r24, r24
    1124:	97 fb       	bst	r25, 7
    1126:	99 1f       	adc	r25, r25
    1128:	61 f0       	breq	.+24     	; 0x1142 <__fp_splitA+0x20>
    112a:	9f 3f       	cpi	r25, 0xFF	; 255
    112c:	79 f0       	breq	.+30     	; 0x114c <__fp_splitA+0x2a>
    112e:	87 95       	ror	r24
    1130:	08 95       	ret
    1132:	12 16       	cp	r1, r18
    1134:	13 06       	cpc	r1, r19
    1136:	14 06       	cpc	r1, r20
    1138:	55 1f       	adc	r21, r21
    113a:	f2 cf       	rjmp	.-28     	; 0x1120 <__fp_split3+0xe>
    113c:	46 95       	lsr	r20
    113e:	f1 df       	rcall	.-30     	; 0x1122 <__fp_splitA>
    1140:	08 c0       	rjmp	.+16     	; 0x1152 <__fp_splitA+0x30>
    1142:	16 16       	cp	r1, r22
    1144:	17 06       	cpc	r1, r23
    1146:	18 06       	cpc	r1, r24
    1148:	99 1f       	adc	r25, r25
    114a:	f1 cf       	rjmp	.-30     	; 0x112e <__fp_splitA+0xc>
    114c:	86 95       	lsr	r24
    114e:	71 05       	cpc	r23, r1
    1150:	61 05       	cpc	r22, r1
    1152:	08 94       	sec
    1154:	08 95       	ret

00001156 <__fp_zero>:
    1156:	e8 94       	clt

00001158 <__fp_szero>:
    1158:	bb 27       	eor	r27, r27
    115a:	66 27       	eor	r22, r22
    115c:	77 27       	eor	r23, r23
    115e:	cb 01       	movw	r24, r22
    1160:	97 f9       	bld	r25, 7
    1162:	08 95       	ret

00001164 <__mulsf3>:
    1164:	0b d0       	rcall	.+22     	; 0x117c <__mulsf3x>
    1166:	c4 cf       	rjmp	.-120    	; 0x10f0 <__fp_round>
    1168:	b5 df       	rcall	.-150    	; 0x10d4 <__fp_pscA>
    116a:	28 f0       	brcs	.+10     	; 0x1176 <__mulsf3+0x12>
    116c:	ba df       	rcall	.-140    	; 0x10e2 <__fp_pscB>
    116e:	18 f0       	brcs	.+6      	; 0x1176 <__mulsf3+0x12>
    1170:	95 23       	and	r25, r21
    1172:	09 f0       	breq	.+2      	; 0x1176 <__mulsf3+0x12>
    1174:	a6 cf       	rjmp	.-180    	; 0x10c2 <__fp_inf>
    1176:	ab cf       	rjmp	.-170    	; 0x10ce <__fp_nan>
    1178:	11 24       	eor	r1, r1
    117a:	ee cf       	rjmp	.-36     	; 0x1158 <__fp_szero>

0000117c <__mulsf3x>:
    117c:	ca df       	rcall	.-108    	; 0x1112 <__fp_split3>
    117e:	a0 f3       	brcs	.-24     	; 0x1168 <__mulsf3+0x4>

00001180 <__mulsf3_pse>:
    1180:	95 9f       	mul	r25, r21
    1182:	d1 f3       	breq	.-12     	; 0x1178 <__mulsf3+0x14>
    1184:	95 0f       	add	r25, r21
    1186:	50 e0       	ldi	r21, 0x00	; 0
    1188:	55 1f       	adc	r21, r21
    118a:	62 9f       	mul	r22, r18
    118c:	f0 01       	movw	r30, r0
    118e:	72 9f       	mul	r23, r18
    1190:	bb 27       	eor	r27, r27
    1192:	f0 0d       	add	r31, r0
    1194:	b1 1d       	adc	r27, r1
    1196:	63 9f       	mul	r22, r19
    1198:	aa 27       	eor	r26, r26
    119a:	f0 0d       	add	r31, r0
    119c:	b1 1d       	adc	r27, r1
    119e:	aa 1f       	adc	r26, r26
    11a0:	64 9f       	mul	r22, r20
    11a2:	66 27       	eor	r22, r22
    11a4:	b0 0d       	add	r27, r0
    11a6:	a1 1d       	adc	r26, r1
    11a8:	66 1f       	adc	r22, r22
    11aa:	82 9f       	mul	r24, r18
    11ac:	22 27       	eor	r18, r18
    11ae:	b0 0d       	add	r27, r0
    11b0:	a1 1d       	adc	r26, r1
    11b2:	62 1f       	adc	r22, r18
    11b4:	73 9f       	mul	r23, r19
    11b6:	b0 0d       	add	r27, r0
    11b8:	a1 1d       	adc	r26, r1
    11ba:	62 1f       	adc	r22, r18
    11bc:	83 9f       	mul	r24, r19
    11be:	a0 0d       	add	r26, r0
    11c0:	61 1d       	adc	r22, r1
    11c2:	22 1f       	adc	r18, r18
    11c4:	74 9f       	mul	r23, r20
    11c6:	33 27       	eor	r19, r19
    11c8:	a0 0d       	add	r26, r0
    11ca:	61 1d       	adc	r22, r1
    11cc:	23 1f       	adc	r18, r19
    11ce:	84 9f       	mul	r24, r20
    11d0:	60 0d       	add	r22, r0
    11d2:	21 1d       	adc	r18, r1
    11d4:	82 2f       	mov	r24, r18
    11d6:	76 2f       	mov	r23, r22
    11d8:	6a 2f       	mov	r22, r26
    11da:	11 24       	eor	r1, r1
    11dc:	9f 57       	subi	r25, 0x7F	; 127
    11de:	50 40       	sbci	r21, 0x00	; 0
    11e0:	8a f0       	brmi	.+34     	; 0x1204 <__mulsf3_pse+0x84>
    11e2:	e1 f0       	breq	.+56     	; 0x121c <__mulsf3_pse+0x9c>
    11e4:	88 23       	and	r24, r24
    11e6:	4a f0       	brmi	.+18     	; 0x11fa <__mulsf3_pse+0x7a>
    11e8:	ee 0f       	add	r30, r30
    11ea:	ff 1f       	adc	r31, r31
    11ec:	bb 1f       	adc	r27, r27
    11ee:	66 1f       	adc	r22, r22
    11f0:	77 1f       	adc	r23, r23
    11f2:	88 1f       	adc	r24, r24
    11f4:	91 50       	subi	r25, 0x01	; 1
    11f6:	50 40       	sbci	r21, 0x00	; 0
    11f8:	a9 f7       	brne	.-22     	; 0x11e4 <__mulsf3_pse+0x64>
    11fa:	9e 3f       	cpi	r25, 0xFE	; 254
    11fc:	51 05       	cpc	r21, r1
    11fe:	70 f0       	brcs	.+28     	; 0x121c <__mulsf3_pse+0x9c>
    1200:	60 cf       	rjmp	.-320    	; 0x10c2 <__fp_inf>
    1202:	aa cf       	rjmp	.-172    	; 0x1158 <__fp_szero>
    1204:	5f 3f       	cpi	r21, 0xFF	; 255
    1206:	ec f3       	brlt	.-6      	; 0x1202 <__mulsf3_pse+0x82>
    1208:	98 3e       	cpi	r25, 0xE8	; 232
    120a:	dc f3       	brlt	.-10     	; 0x1202 <__mulsf3_pse+0x82>
    120c:	86 95       	lsr	r24
    120e:	77 95       	ror	r23
    1210:	67 95       	ror	r22
    1212:	b7 95       	ror	r27
    1214:	f7 95       	ror	r31
    1216:	e7 95       	ror	r30
    1218:	9f 5f       	subi	r25, 0xFF	; 255
    121a:	c1 f7       	brne	.-16     	; 0x120c <__mulsf3_pse+0x8c>
    121c:	fe 2b       	or	r31, r30
    121e:	88 0f       	add	r24, r24
    1220:	91 1d       	adc	r25, r1
    1222:	96 95       	lsr	r25
    1224:	87 95       	ror	r24
    1226:	97 f9       	bld	r25, 7
    1228:	08 95       	ret

0000122a <__divmodhi4>:
    122a:	97 fb       	bst	r25, 7
    122c:	09 2e       	mov	r0, r25
    122e:	07 26       	eor	r0, r23
    1230:	0a d0       	rcall	.+20     	; 0x1246 <__divmodhi4_neg1>
    1232:	77 fd       	sbrc	r23, 7
    1234:	04 d0       	rcall	.+8      	; 0x123e <__divmodhi4_neg2>
    1236:	0c d0       	rcall	.+24     	; 0x1250 <__udivmodhi4>
    1238:	06 d0       	rcall	.+12     	; 0x1246 <__divmodhi4_neg1>
    123a:	00 20       	and	r0, r0
    123c:	1a f4       	brpl	.+6      	; 0x1244 <__divmodhi4_exit>

0000123e <__divmodhi4_neg2>:
    123e:	70 95       	com	r23
    1240:	61 95       	neg	r22
    1242:	7f 4f       	sbci	r23, 0xFF	; 255

00001244 <__divmodhi4_exit>:
    1244:	08 95       	ret

00001246 <__divmodhi4_neg1>:
    1246:	f6 f7       	brtc	.-4      	; 0x1244 <__divmodhi4_exit>
    1248:	90 95       	com	r25
    124a:	81 95       	neg	r24
    124c:	9f 4f       	sbci	r25, 0xFF	; 255
    124e:	08 95       	ret

00001250 <__udivmodhi4>:
    1250:	aa 1b       	sub	r26, r26
    1252:	bb 1b       	sub	r27, r27
    1254:	51 e1       	ldi	r21, 0x11	; 17
    1256:	07 c0       	rjmp	.+14     	; 0x1266 <__udivmodhi4_ep>

00001258 <__udivmodhi4_loop>:
    1258:	aa 1f       	adc	r26, r26
    125a:	bb 1f       	adc	r27, r27
    125c:	a6 17       	cp	r26, r22
    125e:	b7 07       	cpc	r27, r23
    1260:	10 f0       	brcs	.+4      	; 0x1266 <__udivmodhi4_ep>
    1262:	a6 1b       	sub	r26, r22
    1264:	b7 0b       	sbc	r27, r23

00001266 <__udivmodhi4_ep>:
    1266:	88 1f       	adc	r24, r24
    1268:	99 1f       	adc	r25, r25
    126a:	5a 95       	dec	r21
    126c:	a9 f7       	brne	.-22     	; 0x1258 <__udivmodhi4_loop>
    126e:	80 95       	com	r24
    1270:	90 95       	com	r25
    1272:	bc 01       	movw	r22, r24
    1274:	cd 01       	movw	r24, r26
    1276:	08 95       	ret

00001278 <_exit>:
    1278:	f8 94       	cli

0000127a <__stop_program>:
    127a:	ff cf       	rjmp	.-2      	; 0x127a <__stop_program>
